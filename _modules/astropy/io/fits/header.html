<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>astropy.io.fits.header &mdash; NIFITS 0.0.1 documentation</title>
      <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../../../_static/custom.css" type="text/css" />
      <link rel="stylesheet" href="../../../../_static/fonts.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../../../_static/jquery.js?v=5d32c60e"></script>
        <script src="../../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script data-url_root="../../../../" id="documentation_options" src="../../../../_static/documentation_options.js?v=f6245a2f"></script>
        <script src="../../../../_static/doctools.js?v=888ff710"></script>
        <script src="../../../../_static/sphinx_highlight.js?v=4825356b"></script>
    <script src="../../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../../index.html" class="icon icon-home">
            NIFITS
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <!-- Local TOC -->
              <div class="local-toc"></div>
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../index.html">NIFITS</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">astropy.io.fits.header</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for astropy.io.fits.header</h1><div class="highlight"><pre>
<span></span><span class="c1"># Licensed under a 3-clause BSD style license - see PYFITS.rst</span>

<span class="kn">import</span> <span class="nn">collections</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">import</span> <span class="nn">numbers</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">warnings</span>

<span class="kn">from</span> <span class="nn">.card</span> <span class="kn">import</span> <span class="n">Card</span><span class="p">,</span> <span class="n">_pad</span><span class="p">,</span> <span class="n">KEYWORD_LENGTH</span><span class="p">,</span> <span class="n">UNDEFINED</span>
<span class="kn">from</span> <span class="nn">.file</span> <span class="kn">import</span> <span class="n">_File</span>
<span class="kn">from</span> <span class="nn">.util</span> <span class="kn">import</span> <span class="p">(</span><span class="n">encode_ascii</span><span class="p">,</span> <span class="n">decode_ascii</span><span class="p">,</span> <span class="n">fileobj_closed</span><span class="p">,</span>
                   <span class="n">fileobj_is_binary</span><span class="p">,</span> <span class="n">path_like</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">._utils</span> <span class="kn">import</span> <span class="n">parse_header</span>

<span class="kn">from</span> <span class="nn">astropy.utils</span> <span class="kn">import</span> <span class="n">isiterable</span>
<span class="kn">from</span> <span class="nn">astropy.utils.exceptions</span> <span class="kn">import</span> <span class="n">AstropyUserWarning</span>


<span class="n">BLOCK_SIZE</span> <span class="o">=</span> <span class="mi">2880</span>  <span class="c1"># the FITS block size</span>

<span class="c1"># This regular expression can match a *valid* END card which just consists of</span>
<span class="c1"># the string &#39;END&#39; followed by all spaces, or an *invalid* end card which</span>
<span class="c1"># consists of END, followed by any character that is *not* a valid character</span>
<span class="c1"># for a valid FITS keyword (that is, this is not a keyword like &#39;ENDER&#39; which</span>
<span class="c1"># starts with &#39;END&#39; but is not &#39;END&#39;), followed by any arbitrary bytes.  An</span>
<span class="c1"># invalid end card may also consist of just &#39;END&#39; with no trailing bytes.</span>
<span class="n">HEADER_END_RE</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">encode_ascii</span><span class="p">(</span>
    <span class="sa">r</span><span class="s1">&#39;(?:(?P&lt;valid&gt;END </span><span class="si">{77}</span><span class="s1">) *)|(?P&lt;invalid&gt;END$|END {0,76}[^A-Z0-9_-])&#39;</span><span class="p">))</span>


<span class="c1"># According to the FITS standard the only characters that may appear in a</span>
<span class="c1"># header record are the restricted ASCII chars from 0x20 through 0x7E.</span>
<span class="n">VALID_HEADER_CHARS</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">chr</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="mh">0x20</span><span class="p">,</span> <span class="mh">0x7F</span><span class="p">)))</span>
<span class="n">END_CARD</span> <span class="o">=</span> <span class="s1">&#39;END&#39;</span> <span class="o">+</span> <span class="s1">&#39; &#39;</span> <span class="o">*</span> <span class="mi">77</span>


<span class="n">__doctest_skip__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Header&#39;</span><span class="p">,</span> <span class="s1">&#39;Header.comments&#39;</span><span class="p">,</span> <span class="s1">&#39;Header.fromtextfile&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;Header.totextfile&#39;</span><span class="p">,</span> <span class="s1">&#39;Header.set&#39;</span><span class="p">,</span> <span class="s1">&#39;Header.update&#39;</span><span class="p">]</span>


<span class="k">class</span> <span class="nc">Header</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    FITS header class.  This class exposes both a dict-like interface and a</span>
<span class="sd">    list-like interface to FITS headers.</span>

<span class="sd">    The header may be indexed by keyword and, like a dict, the associated value</span>
<span class="sd">    will be returned.  When the header contains cards with duplicate keywords,</span>
<span class="sd">    only the value of the first card with the given keyword will be returned.</span>
<span class="sd">    It is also possible to use a 2-tuple as the index in the form (keyword,</span>
<span class="sd">    n)--this returns the n-th value with that keyword, in the case where there</span>
<span class="sd">    are duplicate keywords.</span>

<span class="sd">    For example::</span>

<span class="sd">        &gt;&gt;&gt; header[&#39;NAXIS&#39;]</span>
<span class="sd">        0</span>
<span class="sd">        &gt;&gt;&gt; header[(&#39;FOO&#39;, 1)]  # Return the value of the second FOO keyword</span>
<span class="sd">        &#39;foo&#39;</span>

<span class="sd">    The header may also be indexed by card number::</span>

<span class="sd">        &gt;&gt;&gt; header[0]  # Return the value of the first card in the header</span>
<span class="sd">        &#39;T&#39;</span>

<span class="sd">    Commentary keywords such as HISTORY and COMMENT are special cases: When</span>
<span class="sd">    indexing the Header object with either &#39;HISTORY&#39; or &#39;COMMENT&#39; a list of all</span>
<span class="sd">    the HISTORY/COMMENT values is returned::</span>

<span class="sd">        &gt;&gt;&gt; header[&#39;HISTORY&#39;]</span>
<span class="sd">        This is the first history entry in this header.</span>
<span class="sd">        This is the second history entry in this header.</span>
<span class="sd">        ...</span>

<span class="sd">    See the Astropy documentation for more details on working with headers.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Although FITS keywords must be exclusively upper case, retrieving an item</span>
<span class="sd">    in a `Header` object is case insensitive.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cards</span><span class="o">=</span><span class="p">[],</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct a `Header` from an iterable and/or text file.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        cards : list of `Card`, optional</span>
<span class="sd">            The cards to initialize the header with. Also allowed are other</span>
<span class="sd">            `Header` (or `dict`-like) objects.</span>

<span class="sd">            .. versionchanged:: 1.2</span>
<span class="sd">                Allowed ``cards`` to be a `dict`-like object.</span>

<span class="sd">        copy : bool, optional</span>

<span class="sd">            If ``True`` copies the ``cards`` if they were another `Header`</span>
<span class="sd">            instance.</span>
<span class="sd">            Default is ``False``.</span>

<span class="sd">            .. versionadded:: 1.3</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cards</span><span class="p">,</span> <span class="n">Header</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">copy</span><span class="p">:</span>
                <span class="n">cards</span> <span class="o">=</span> <span class="n">cards</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">cards</span> <span class="o">=</span> <span class="n">cards</span><span class="o">.</span><span class="n">cards</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cards</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="n">cards</span> <span class="o">=</span> <span class="n">cards</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">card</span> <span class="ow">in</span> <span class="n">cards</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">card</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_modified</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cards</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">card</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cards</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">card</span><span class="o">.</span><span class="n">keyword</span>

    <span class="k">def</span> <span class="fm">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">keyword</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">keyword</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_keyword_indices</span> <span class="ow">or</span> <span class="n">keyword</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rvkc_indices</span><span class="p">:</span>
            <span class="c1"># For the most common case (single, standard form keyword lookup)</span>
            <span class="c1"># this will work and is an O(1) check.  If it fails that doesn&#39;t</span>
            <span class="c1"># guarantee absence, just that we have to perform the full set of</span>
            <span class="c1"># checks in self._cardindex</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cardindex</span><span class="p">(</span><span class="n">keyword</span><span class="p">)</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">KeyError</span><span class="p">,</span> <span class="ne">IndexError</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">([</span><span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cards</span><span class="p">[</span><span class="n">key</span><span class="p">]])</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_haswildcard</span><span class="p">(</span><span class="n">key</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">([</span><span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cards</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span>
                                   <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wildcardmatch</span><span class="p">(</span><span class="n">key</span><span class="p">)])</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">key</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">key</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="ow">in</span> <span class="n">Card</span><span class="o">.</span><span class="n">_commentary_keywords</span><span class="p">:</span>
                <span class="n">key</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>
                <span class="c1"># Special case for commentary cards</span>
                <span class="k">return</span> <span class="n">_HeaderCommentaryCards</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="n">keyword</span> <span class="o">=</span> <span class="n">key</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">keyword</span> <span class="o">=</span> <span class="n">key</span>

        <span class="n">card</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cards</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_cardindex</span><span class="p">(</span><span class="n">key</span><span class="p">)]</span>

        <span class="k">if</span> <span class="n">card</span><span class="o">.</span><span class="n">field_specifier</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">keyword</span> <span class="o">==</span> <span class="n">card</span><span class="o">.</span><span class="n">rawkeyword</span><span class="p">:</span>
            <span class="c1"># This is RVKC; if only the top-level keyword was specified return</span>
            <span class="c1"># the raw value, not the parsed out float value</span>
            <span class="k">return</span> <span class="n">card</span><span class="o">.</span><span class="n">rawvalue</span>

        <span class="n">value</span> <span class="o">=</span> <span class="n">card</span><span class="o">.</span><span class="n">value</span>
        <span class="k">if</span> <span class="n">value</span> <span class="o">==</span> <span class="n">UNDEFINED</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">value</span>

    <span class="k">def</span> <span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_set_slice</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="bp">self</span><span class="p">):</span>
            <span class="k">return</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s1">&#39;A Header item may be set with either a scalar value, &#39;</span>
                    <span class="s1">&#39;a 1-tuple containing a scalar value, or a 2-tuple &#39;</span>
                    <span class="s1">&#39;containing a scalar value and comment string.&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">value</span><span class="p">,</span> <span class="n">comment</span> <span class="o">=</span> <span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="kc">None</span>
                <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">value</span> <span class="o">=</span> <span class="n">UNDEFINED</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">value</span><span class="p">,</span> <span class="n">comment</span> <span class="o">=</span> <span class="n">value</span>
                <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">value</span> <span class="o">=</span> <span class="n">UNDEFINED</span>
                <span class="k">if</span> <span class="n">comment</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">comment</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">comment</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="n">card</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">numbers</span><span class="o">.</span><span class="n">Integral</span><span class="p">):</span>
            <span class="n">card</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cards</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="n">card</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cards</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_cardindex</span><span class="p">(</span><span class="n">key</span><span class="p">)]</span>
        <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">UNDEFINED</span>
        <span class="k">if</span> <span class="n">card</span><span class="p">:</span>
            <span class="n">card</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span>
            <span class="k">if</span> <span class="n">comment</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">card</span><span class="o">.</span><span class="n">comment</span> <span class="o">=</span> <span class="n">comment</span>
            <span class="k">if</span> <span class="n">card</span><span class="o">.</span><span class="n">_modified</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_modified</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># If we get an IndexError that should be raised; we don&#39;t allow</span>
            <span class="c1"># assignment to non-existing indices</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update</span><span class="p">((</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">comment</span><span class="p">))</span>

    <span class="k">def</span> <span class="fm">__delitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">slice</span><span class="p">)</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_haswildcard</span><span class="p">(</span><span class="n">key</span><span class="p">):</span>
            <span class="c1"># This is very inefficient but it&#39;s not a commonly used feature.</span>
            <span class="c1"># If someone out there complains that they make heavy use of slice</span>
            <span class="c1"># deletions and it&#39;s too slow, well, we can worry about it then</span>
            <span class="c1"># [the solution is not too complicated--it would be wait &#39;til all</span>
            <span class="c1"># the cards are deleted before updating _keyword_indices rather</span>
            <span class="c1"># than updating it once for each card that gets deleted]</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
                <span class="n">indices</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="o">*</span><span class="n">key</span><span class="o">.</span><span class="n">indices</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)))</span>
                <span class="c1"># If the slice step is backwards we want to reverse it, because</span>
                <span class="c1"># it will be reversed in a few lines...</span>
                <span class="k">if</span> <span class="n">key</span><span class="o">.</span><span class="n">step</span> <span class="ow">and</span> <span class="n">key</span><span class="o">.</span><span class="n">step</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">indices</span> <span class="o">=</span> <span class="nb">reversed</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wildcardmatch</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="n">indices</span><span class="p">):</span>
                <span class="k">del</span> <span class="bp">self</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
            <span class="k">return</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="c1"># delete ALL cards with the same keyword name</span>
            <span class="n">key</span> <span class="o">=</span> <span class="n">Card</span><span class="o">.</span><span class="n">normalize_keyword</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_keyword_indices</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_keyword_indices</span><span class="p">:</span>
                <span class="n">indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rvkc_indices</span>

            <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">:</span>
                <span class="c1"># if keyword is not present raise KeyError.</span>
                <span class="c1"># To delete keyword without caring if they were present,</span>
                <span class="c1"># Header.remove(Keyword) can be used with optional argument ignore_missing as True</span>
                <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Keyword &#39;</span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2">&#39; not found.&quot;</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="n">indices</span><span class="p">[</span><span class="n">key</span><span class="p">]):</span>
                <span class="c1"># Have to copy the indices list since it will be modified below</span>
                <span class="k">del</span> <span class="bp">self</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
            <span class="k">return</span>

        <span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cardindex</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="n">card</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cards</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
        <span class="n">keyword</span> <span class="o">=</span> <span class="n">card</span><span class="o">.</span><span class="n">keyword</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cards</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
        <span class="n">keyword</span> <span class="o">=</span> <span class="n">Card</span><span class="o">.</span><span class="n">normalize_keyword</span><span class="p">(</span><span class="n">keyword</span><span class="p">)</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_keyword_indices</span><span class="p">[</span><span class="n">keyword</span><span class="p">]</span>
        <span class="n">indices</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">indices</span><span class="p">:</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_keyword_indices</span><span class="p">[</span><span class="n">keyword</span><span class="p">]</span>

        <span class="c1"># Also update RVKC indices if necessary :/</span>
        <span class="k">if</span> <span class="n">card</span><span class="o">.</span><span class="n">field_specifier</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rvkc_indices</span><span class="p">[</span><span class="n">card</span><span class="o">.</span><span class="n">rawkeyword</span><span class="p">]</span>
            <span class="n">indices</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">indices</span><span class="p">:</span>
                <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rvkc_indices</span><span class="p">[</span><span class="n">card</span><span class="o">.</span><span class="n">rawkeyword</span><span class="p">]</span>

        <span class="c1"># We also need to update all other indices</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_updateindices</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">increment</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_modified</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">tostring</span><span class="p">(</span><span class="n">sep</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">endcard</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">padding</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">tostring</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Two Headers are equal only if they have the exact same string</span>
<span class="sd">        representation.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="nb">str</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="n">temp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">strip</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">temp</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">temp</span>

    <span class="k">def</span> <span class="fm">__iadd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">_ipython_key_completions_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__iter__</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">cards</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The underlying physical cards that make up this Header; it can be</span>
<span class="sd">        looked at, but it should not be modified directly.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">_CardAccessor</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">comments</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        View the comments associated with each keyword, if any.</span>

<span class="sd">        For example, to see the comment on the NAXIS keyword:</span>

<span class="sd">            &gt;&gt;&gt; header.comments[&#39;NAXIS&#39;]</span>
<span class="sd">            number of data axes</span>

<span class="sd">        Comments can also be updated through this interface:</span>

<span class="sd">            &gt;&gt;&gt; header.comments[&#39;NAXIS&#39;] = &#39;Number of data axes&#39;</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">_HeaderComments</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_modified</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Whether or not the header has been modified; this is a property so that</span>
<span class="sd">        it can also check each card for modifications--cards may have been</span>
<span class="sd">        modified directly without the header containing it otherwise knowing.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">modified_cards</span> <span class="o">=</span> <span class="nb">any</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">_modified</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cards</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">modified_cards</span><span class="p">:</span>
            <span class="c1"># If any cards were modified then by definition the header was</span>
            <span class="c1"># modified</span>
            <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="s1">&#39;_modified&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="s1">&#39;_modified&#39;</span><span class="p">]</span>

    <span class="nd">@_modified</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">_modified</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="s1">&#39;_modified&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">fromstring</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates an HDU header from a byte string containing the entire header</span>
<span class="sd">        data.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data : str or bytes</span>
<span class="sd">           String or bytes containing the entire header.  In the case of bytes</span>
<span class="sd">           they will be decoded using latin-1 (only plain ASCII characters are</span>
<span class="sd">           allowed in FITS headers but latin-1 allows us to retain any invalid</span>
<span class="sd">           bytes that might appear in malformatted FITS files).</span>

<span class="sd">        sep : str, optional</span>
<span class="sd">            The string separating cards from each other, such as a newline.  By</span>
<span class="sd">            default there is no card separator (as is the case in a raw FITS</span>
<span class="sd">            file).  In general this is only used in cases where a header was</span>
<span class="sd">            printed as text (e.g. with newlines after each card) and you want</span>
<span class="sd">            to create a new `Header` from it by copy/pasting.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        &gt;&gt;&gt; from astropy.io.fits import Header</span>
<span class="sd">        &gt;&gt;&gt; hdr = Header({&#39;SIMPLE&#39;: True})</span>
<span class="sd">        &gt;&gt;&gt; Header.fromstring(hdr.tostring()) == hdr</span>
<span class="sd">        True</span>

<span class="sd">        If you want to create a `Header` from printed text it&#39;s not necessary</span>
<span class="sd">        to have the exact binary structure as it would appear in a FITS file,</span>
<span class="sd">        with the full 80 byte card length.  Rather, each &quot;card&quot; can end in a</span>
<span class="sd">        newline and does not have to be padded out to a full card length as</span>
<span class="sd">        long as it &quot;looks like&quot; a FITS header:</span>

<span class="sd">        &gt;&gt;&gt; hdr = Header.fromstring(\&quot;\&quot;\&quot;\\</span>
<span class="sd">        ... SIMPLE  =                    T / conforms to FITS standard</span>
<span class="sd">        ... BITPIX  =                    8 / array data type</span>
<span class="sd">        ... NAXIS   =                    0 / number of array dimensions</span>
<span class="sd">        ... EXTEND  =                    T</span>
<span class="sd">        ... \&quot;\&quot;\&quot;, sep=&#39;\\n&#39;)</span>
<span class="sd">        &gt;&gt;&gt; hdr[&#39;SIMPLE&#39;]</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; hdr[&#39;BITPIX&#39;]</span>
<span class="sd">        8</span>
<span class="sd">        &gt;&gt;&gt; len(hdr)</span>
<span class="sd">        4</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        `Header`</span>
<span class="sd">            A new `Header` instance.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">cards</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># If the card separator contains characters that may validly appear in</span>
        <span class="c1"># a card, the only way to unambiguously distinguish between cards is to</span>
        <span class="c1"># require that they be Card.length long.  However, if the separator</span>
        <span class="c1"># contains non-valid characters (namely \n) the cards may be split</span>
        <span class="c1"># immediately at the separator</span>
        <span class="n">require_full_cardlength</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">sep</span><span class="p">)</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="n">VALID_HEADER_CHARS</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="nb">bytes</span><span class="p">):</span>
            <span class="c1"># FITS supports only ASCII, but decode as latin1 and just take all</span>
            <span class="c1"># bytes for now; if it results in mojibake due to e.g. UTF-8</span>
            <span class="c1"># encoded data in a FITS header that&#39;s OK because it shouldn&#39;t be</span>
            <span class="c1"># there in the first place--accepting it here still gives us the</span>
            <span class="c1"># opportunity to display warnings later during validation</span>
            <span class="n">CONTINUE</span> <span class="o">=</span> <span class="sa">b</span><span class="s1">&#39;CONTINUE&#39;</span>
            <span class="n">END</span> <span class="o">=</span> <span class="sa">b</span><span class="s1">&#39;END&#39;</span>
            <span class="n">end_card</span> <span class="o">=</span> <span class="n">END_CARD</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;ascii&#39;</span><span class="p">)</span>
            <span class="n">sep</span> <span class="o">=</span> <span class="n">sep</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;latin1&#39;</span><span class="p">)</span>
            <span class="n">empty</span> <span class="o">=</span> <span class="sa">b</span><span class="s1">&#39;&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">CONTINUE</span> <span class="o">=</span> <span class="s1">&#39;CONTINUE&#39;</span>
            <span class="n">END</span> <span class="o">=</span> <span class="s1">&#39;END&#39;</span>
            <span class="n">end_card</span> <span class="o">=</span> <span class="n">END_CARD</span>
            <span class="n">empty</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>

        <span class="c1"># Split the header into individual cards</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">image</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">while</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">require_full_cardlength</span><span class="p">:</span>
                <span class="n">end_idx</span> <span class="o">=</span> <span class="n">idx</span> <span class="o">+</span> <span class="n">Card</span><span class="o">.</span><span class="n">length</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">end_idx</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">sep</span><span class="p">,</span> <span class="n">idx</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                    <span class="n">end_idx</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

            <span class="n">next_image</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">idx</span><span class="p">:</span><span class="n">end_idx</span><span class="p">]</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">end_idx</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">sep</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">image</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">next_image</span><span class="p">[:</span><span class="mi">8</span><span class="p">]</span> <span class="o">==</span> <span class="n">CONTINUE</span><span class="p">:</span>
                    <span class="n">image</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">next_image</span><span class="p">)</span>
                    <span class="k">continue</span>
                <span class="n">cards</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Card</span><span class="o">.</span><span class="n">fromstring</span><span class="p">(</span><span class="n">empty</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">image</span><span class="p">)))</span>

            <span class="k">if</span> <span class="n">require_full_cardlength</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">next_image</span> <span class="o">==</span> <span class="n">end_card</span><span class="p">:</span>
                    <span class="n">image</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">next_image</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">sep</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">rstrip</span><span class="p">()</span> <span class="o">==</span> <span class="n">END</span><span class="p">:</span>
                    <span class="n">image</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="k">break</span>

            <span class="n">image</span> <span class="o">=</span> <span class="p">[</span><span class="n">next_image</span><span class="p">]</span>

        <span class="c1"># Add the last image that was found before the end, if any</span>
        <span class="k">if</span> <span class="n">image</span><span class="p">:</span>
            <span class="n">cards</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Card</span><span class="o">.</span><span class="n">fromstring</span><span class="p">(</span><span class="n">empty</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">image</span><span class="p">)))</span>

        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_fromcards</span><span class="p">(</span><span class="n">cards</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">fromfile</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">fileobj</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">endcard</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">padding</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Similar to :meth:`Header.fromstring`, but reads the header string from</span>
<span class="sd">        a given file-like object or filename.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        fileobj : str, file-like</span>
<span class="sd">            A filename or an open file-like object from which a FITS header is</span>
<span class="sd">            to be read.  For open file handles the file pointer must be at the</span>
<span class="sd">            beginning of the header.</span>

<span class="sd">        sep : str, optional</span>
<span class="sd">            The string separating cards from each other, such as a newline.  By</span>
<span class="sd">            default there is no card separator (as is the case in a raw FITS</span>
<span class="sd">            file).</span>

<span class="sd">        endcard : bool, optional</span>
<span class="sd">            If True (the default) the header must end with an END card in order</span>
<span class="sd">            to be considered valid.  If an END card is not found an</span>
<span class="sd">            `OSError` is raised.</span>

<span class="sd">        padding : bool, optional</span>
<span class="sd">            If True (the default) the header will be required to be padded out</span>
<span class="sd">            to a multiple of 2880, the FITS header block size.  Otherwise any</span>
<span class="sd">            padding, or lack thereof, is ignored.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        `Header`</span>
<span class="sd">            A new `Header` instance.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">close_file</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fileobj</span><span class="p">,</span> <span class="n">path_like</span><span class="p">):</span>
            <span class="c1"># If sep is non-empty we are trying to read a header printed to a</span>
            <span class="c1"># text file, so open in text mode by default to support newline</span>
            <span class="c1"># handling; if a binary-mode file object is passed in, the user is</span>
            <span class="c1"># then on their own w.r.t. newline handling.</span>
            <span class="c1">#</span>
            <span class="c1"># Otherwise assume we are reading from an actual FITS file and open</span>
            <span class="c1"># in binary mode.</span>
            <span class="k">if</span> <span class="n">sep</span><span class="p">:</span>
                <span class="n">fileobj</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">fileobj</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s1">&#39;latin1&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">fileobj</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">fileobj</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span>

            <span class="n">close_file</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">is_binary</span> <span class="o">=</span> <span class="n">fileobj_is_binary</span><span class="p">(</span><span class="n">fileobj</span><span class="p">)</span>

            <span class="k">def</span> <span class="nf">block_iter</span><span class="p">(</span><span class="n">nbytes</span><span class="p">):</span>
                <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
                    <span class="n">data</span> <span class="o">=</span> <span class="n">fileobj</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">nbytes</span><span class="p">)</span>

                    <span class="k">if</span> <span class="n">data</span><span class="p">:</span>
                        <span class="k">yield</span> <span class="n">data</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">break</span>

            <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_from_blocks</span><span class="p">(</span><span class="n">block_iter</span><span class="p">,</span> <span class="n">is_binary</span><span class="p">,</span> <span class="n">sep</span><span class="p">,</span> <span class="n">endcard</span><span class="p">,</span>
                                    <span class="n">padding</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">close_file</span><span class="p">:</span>
                <span class="n">fileobj</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_fromcards</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">cards</span><span class="p">):</span>
        <span class="n">header</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">card</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">cards</span><span class="p">):</span>
            <span class="n">header</span><span class="o">.</span><span class="n">_cards</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">card</span><span class="p">)</span>
            <span class="n">keyword</span> <span class="o">=</span> <span class="n">Card</span><span class="o">.</span><span class="n">normalize_keyword</span><span class="p">(</span><span class="n">card</span><span class="o">.</span><span class="n">keyword</span><span class="p">)</span>
            <span class="n">header</span><span class="o">.</span><span class="n">_keyword_indices</span><span class="p">[</span><span class="n">keyword</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">card</span><span class="o">.</span><span class="n">field_specifier</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">header</span><span class="o">.</span><span class="n">_rvkc_indices</span><span class="p">[</span><span class="n">card</span><span class="o">.</span><span class="n">rawkeyword</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>

        <span class="n">header</span><span class="o">.</span><span class="n">_modified</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="n">header</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_from_blocks</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">block_iter</span><span class="p">,</span> <span class="n">is_binary</span><span class="p">,</span> <span class="n">sep</span><span class="p">,</span> <span class="n">endcard</span><span class="p">,</span> <span class="n">padding</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The meat of `Header.fromfile`; in a separate method so that</span>
<span class="sd">        `Header.fromfile` itself is just responsible for wrapping file</span>
<span class="sd">        handling.  Also used by `_BaseHDU.fromstring`.</span>

<span class="sd">        ``block_iter`` should be a callable which, given a block size n</span>
<span class="sd">        (typically 2880 bytes as used by the FITS standard) returns an iterator</span>
<span class="sd">        of byte strings of that block size.</span>

<span class="sd">        ``is_binary`` specifies whether the returned blocks are bytes or text</span>

<span class="sd">        Returns both the entire header *string*, and the `Header` object</span>
<span class="sd">        returned by Header.fromstring on that string.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">actual_block_size</span> <span class="o">=</span> <span class="n">_block_size</span><span class="p">(</span><span class="n">sep</span><span class="p">)</span>
        <span class="n">clen</span> <span class="o">=</span> <span class="n">Card</span><span class="o">.</span><span class="n">length</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">sep</span><span class="p">)</span>

        <span class="n">blocks</span> <span class="o">=</span> <span class="n">block_iter</span><span class="p">(</span><span class="n">actual_block_size</span><span class="p">)</span>

        <span class="c1"># Read the first header block.</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">block</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">blocks</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">EOFError</span><span class="p">()</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_binary</span><span class="p">:</span>
            <span class="c1"># TODO: There needs to be error handling at *this* level for</span>
            <span class="c1"># non-ASCII characters; maybe at this stage decoding latin-1 might</span>
            <span class="c1"># be safer</span>
            <span class="n">block</span> <span class="o">=</span> <span class="n">encode_ascii</span><span class="p">(</span><span class="n">block</span><span class="p">)</span>

        <span class="n">read_blocks</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">is_eof</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">end_found</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># continue reading header blocks until END card or EOF is reached</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="c1"># find the END card</span>
            <span class="n">end_found</span><span class="p">,</span> <span class="n">block</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_find_end_card</span><span class="p">(</span><span class="n">block</span><span class="p">,</span> <span class="n">clen</span><span class="p">)</span>

            <span class="n">read_blocks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">decode_ascii</span><span class="p">(</span><span class="n">block</span><span class="p">))</span>

            <span class="k">if</span> <span class="n">end_found</span><span class="p">:</span>
                <span class="k">break</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="n">block</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">blocks</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
                <span class="n">is_eof</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">break</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">block</span><span class="p">:</span>
                <span class="n">is_eof</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">break</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">is_binary</span><span class="p">:</span>
                <span class="n">block</span> <span class="o">=</span> <span class="n">encode_ascii</span><span class="p">(</span><span class="n">block</span><span class="p">)</span>

        <span class="n">header_str</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">read_blocks</span><span class="p">)</span>
        <span class="n">_check_padding</span><span class="p">(</span><span class="n">header_str</span><span class="p">,</span> <span class="n">actual_block_size</span><span class="p">,</span> <span class="n">is_eof</span><span class="p">,</span>
                       <span class="n">check_block_size</span><span class="o">=</span><span class="n">padding</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">end_found</span> <span class="ow">and</span> <span class="n">is_eof</span> <span class="ow">and</span> <span class="n">endcard</span><span class="p">:</span>
            <span class="c1"># TODO: Pass this error to validation framework as an ERROR,</span>
            <span class="c1"># rather than raising an exception</span>
            <span class="k">raise</span> <span class="ne">OSError</span><span class="p">(</span><span class="s1">&#39;Header missing END card.&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">header_str</span><span class="p">,</span> <span class="bp">cls</span><span class="o">.</span><span class="n">fromstring</span><span class="p">(</span><span class="n">header_str</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="n">sep</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_find_end_card</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span> <span class="n">card_len</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Utility method to search a header block for the END card and handle</span>
<span class="sd">        invalid END cards.</span>

<span class="sd">        This method can also returned a modified copy of the input header block</span>
<span class="sd">        in case an invalid end card needs to be sanitized.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">for</span> <span class="n">mo</span> <span class="ow">in</span> <span class="n">HEADER_END_RE</span><span class="o">.</span><span class="n">finditer</span><span class="p">(</span><span class="n">block</span><span class="p">):</span>
            <span class="c1"># Ensure the END card was found, and it started on the</span>
            <span class="c1"># boundary of a new card (see ticket #142)</span>
            <span class="k">if</span> <span class="n">mo</span><span class="o">.</span><span class="n">start</span><span class="p">()</span> <span class="o">%</span> <span class="n">card_len</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="c1"># This must be the last header block, otherwise the</span>
            <span class="c1"># file is malformatted</span>
            <span class="k">if</span> <span class="n">mo</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s1">&#39;invalid&#39;</span><span class="p">):</span>
                <span class="n">offset</span> <span class="o">=</span> <span class="n">mo</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
                <span class="n">trailing</span> <span class="o">=</span> <span class="n">block</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">3</span><span class="p">:</span><span class="n">offset</span> <span class="o">+</span> <span class="n">card_len</span> <span class="o">-</span> <span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">rstrip</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">trailing</span><span class="p">:</span>
                    <span class="n">trailing</span> <span class="o">=</span> <span class="nb">repr</span><span class="p">(</span><span class="n">trailing</span><span class="p">)</span><span class="o">.</span><span class="n">lstrip</span><span class="p">(</span><span class="s1">&#39;ub&#39;</span><span class="p">)</span>
                    <span class="c1"># TODO: Pass this warning up to the validation framework</span>
                    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                        <span class="s1">&#39;Unexpected bytes trailing END keyword: </span><span class="si">{}</span><span class="s1">; these &#39;</span>
                        <span class="s1">&#39;bytes will be replaced with spaces on write.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                            <span class="n">trailing</span><span class="p">),</span> <span class="n">AstropyUserWarning</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># TODO: Pass this warning up to the validation framework</span>
                    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                        <span class="s1">&#39;Missing padding to end of the FITS block after the &#39;</span>
                        <span class="s1">&#39;END keyword; additional spaces will be appended to &#39;</span>
                        <span class="s1">&#39;the file upon writing to pad out to </span><span class="si">{}</span><span class="s1"> &#39;</span>
                        <span class="s1">&#39;bytes.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">BLOCK_SIZE</span><span class="p">),</span> <span class="n">AstropyUserWarning</span><span class="p">)</span>

                <span class="c1"># Sanitize out invalid END card now that the appropriate</span>
                <span class="c1"># warnings have been issued</span>
                <span class="n">block</span> <span class="o">=</span> <span class="p">(</span><span class="n">block</span><span class="p">[:</span><span class="n">offset</span><span class="p">]</span> <span class="o">+</span> <span class="n">encode_ascii</span><span class="p">(</span><span class="n">END_CARD</span><span class="p">)</span> <span class="o">+</span>
                         <span class="n">block</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">END_CARD</span><span class="p">):])</span>

            <span class="k">return</span> <span class="kc">True</span><span class="p">,</span> <span class="n">block</span>

        <span class="k">return</span> <span class="kc">False</span><span class="p">,</span> <span class="n">block</span>

    <span class="k">def</span> <span class="nf">tostring</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">endcard</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">padding</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a string representation of the header.</span>

<span class="sd">        By default this uses no separator between cards, adds the END card, and</span>
<span class="sd">        pads the string with spaces to the next multiple of 2880 bytes.  That</span>
<span class="sd">        is, it returns the header exactly as it would appear in a FITS file.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        sep : str, optional</span>
<span class="sd">            The character or string with which to separate cards.  By default</span>
<span class="sd">            there is no separator, but one could use ``&#39;\\n&#39;``, for example, to</span>
<span class="sd">            separate each card with a new line</span>

<span class="sd">        endcard : bool, optional</span>
<span class="sd">            If True (default) adds the END card to the end of the header</span>
<span class="sd">            string</span>

<span class="sd">        padding : bool, optional</span>
<span class="sd">            If True (default) pads the string with spaces out to the next</span>
<span class="sd">            multiple of 2880 characters</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        str</span>
<span class="sd">            A string representing a FITS header.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">lines</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">card</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cards</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">card</span><span class="p">)</span>
            <span class="c1"># Cards with CONTINUE cards may be longer than 80 chars; so break</span>
            <span class="c1"># them into multiple lines</span>
            <span class="k">while</span> <span class="n">s</span><span class="p">:</span>
                <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">s</span><span class="p">[:</span><span class="n">Card</span><span class="o">.</span><span class="n">length</span><span class="p">])</span>
                <span class="n">s</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="n">Card</span><span class="o">.</span><span class="n">length</span><span class="p">:]</span>

        <span class="n">s</span> <span class="o">=</span> <span class="n">sep</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">endcard</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="n">sep</span> <span class="o">+</span> <span class="n">_pad</span><span class="p">(</span><span class="s1">&#39;END&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">padding</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="s1">&#39; &#39;</span> <span class="o">*</span> <span class="n">_pad_length</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">s</span>

    <span class="k">def</span> <span class="nf">tofile</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fileobj</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">endcard</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">padding</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
               <span class="n">overwrite</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Writes the header to file or file-like object.</span>

<span class="sd">        By default this writes the header exactly as it would be written to a</span>
<span class="sd">        FITS file, with the END card included and padding to the next multiple</span>
<span class="sd">        of 2880 bytes.  However, aspects of this may be controlled.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        fileobj : path-like or file-like, optional</span>
<span class="sd">            Either the pathname of a file, or an open file handle or file-like</span>
<span class="sd">            object.</span>

<span class="sd">        sep : str, optional</span>
<span class="sd">            The character or string with which to separate cards.  By default</span>
<span class="sd">            there is no separator, but one could use ``&#39;\\n&#39;``, for example, to</span>
<span class="sd">            separate each card with a new line</span>

<span class="sd">        endcard : bool, optional</span>
<span class="sd">            If `True` (default) adds the END card to the end of the header</span>
<span class="sd">            string</span>

<span class="sd">        padding : bool, optional</span>
<span class="sd">            If `True` (default) pads the string with spaces out to the next</span>
<span class="sd">            multiple of 2880 characters</span>

<span class="sd">        overwrite : bool, optional</span>
<span class="sd">            If ``True``, overwrite the output file if it exists. Raises an</span>
<span class="sd">            ``OSError`` if ``False`` and the output file exists. Default is</span>
<span class="sd">            ``False``.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">close_file</span> <span class="o">=</span> <span class="n">fileobj_closed</span><span class="p">(</span><span class="n">fileobj</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fileobj</span><span class="p">,</span> <span class="n">_File</span><span class="p">):</span>
            <span class="n">fileobj</span> <span class="o">=</span> <span class="n">_File</span><span class="p">(</span><span class="n">fileobj</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;ostream&#39;</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="n">overwrite</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">blocks</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tostring</span><span class="p">(</span><span class="n">sep</span><span class="o">=</span><span class="n">sep</span><span class="p">,</span> <span class="n">endcard</span><span class="o">=</span><span class="n">endcard</span><span class="p">,</span> <span class="n">padding</span><span class="o">=</span><span class="n">padding</span><span class="p">)</span>
            <span class="n">actual_block_size</span> <span class="o">=</span> <span class="n">_block_size</span><span class="p">(</span><span class="n">sep</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">padding</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">blocks</span><span class="p">)</span> <span class="o">%</span> <span class="n">actual_block_size</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">OSError</span><span class="p">(</span>
                    <span class="s1">&#39;Header size (</span><span class="si">{}</span><span class="s1">) is not a multiple of block &#39;</span>
                    <span class="s1">&#39;size (</span><span class="si">{}</span><span class="s1">).&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="nb">len</span><span class="p">(</span><span class="n">blocks</span><span class="p">)</span> <span class="o">-</span> <span class="n">actual_block_size</span> <span class="o">+</span> <span class="n">BLOCK_SIZE</span><span class="p">,</span>
                        <span class="n">BLOCK_SIZE</span><span class="p">))</span>

            <span class="n">fileobj</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>
            <span class="n">fileobj</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">blocks</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;ascii&#39;</span><span class="p">))</span>
            <span class="n">fileobj</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">close_file</span><span class="p">:</span>
                <span class="n">fileobj</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">fromtextfile</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">fileobj</span><span class="p">,</span> <span class="n">endcard</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Read a header from a simple text file or file-like object.</span>

<span class="sd">        Equivalent to::</span>

<span class="sd">            &gt;&gt;&gt; Header.fromfile(fileobj, sep=&#39;\\n&#39;, endcard=False,</span>
<span class="sd">            ...                 padding=False)</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        fromfile</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">fromfile</span><span class="p">(</span><span class="n">fileobj</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">endcard</span><span class="o">=</span><span class="n">endcard</span><span class="p">,</span> <span class="n">padding</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">totextfile</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fileobj</span><span class="p">,</span> <span class="n">endcard</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Write the header as text to a file or a file-like object.</span>

<span class="sd">        Equivalent to::</span>

<span class="sd">            &gt;&gt;&gt; Header.tofile(fileobj, sep=&#39;\\n&#39;, endcard=False,</span>
<span class="sd">            ...               padding=False, overwrite=overwrite)</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        tofile</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">tofile</span><span class="p">(</span><span class="n">fileobj</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">endcard</span><span class="o">=</span><span class="n">endcard</span><span class="p">,</span> <span class="n">padding</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                    <span class="n">overwrite</span><span class="o">=</span><span class="n">overwrite</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">clear</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Remove all cards from the header.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_cards</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_keyword_indices</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_rvkc_indices</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">strip</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Make a copy of the :class:`Header`.</span>

<span class="sd">        .. versionchanged:: 1.3</span>
<span class="sd">            `copy.copy` and `copy.deepcopy` on a `Header` will call this</span>
<span class="sd">            method.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        strip : bool, optional</span>
<span class="sd">            If `True`, strip any headers that are specific to one of the</span>
<span class="sd">            standard HDU types, so that this header can be used in a different</span>
<span class="sd">            HDU.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        `Header`</span>
<span class="sd">            A new :class:`Header` instance.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">tmp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">((</span><span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">card</span><span class="p">)</span> <span class="k">for</span> <span class="n">card</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cards</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">strip</span><span class="p">:</span>
            <span class="n">tmp</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">tmp</span>

    <span class="k">def</span> <span class="nf">__copy__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__deepcopy__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">fromkeys</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">iterable</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Similar to :meth:`dict.fromkeys`--creates a new `Header` from an</span>
<span class="sd">        iterable of keywords and an optional default value.</span>

<span class="sd">        This method is not likely to be particularly useful for creating real</span>
<span class="sd">        world FITS headers, but it is useful for testing.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        iterable</span>
<span class="sd">            Any iterable that returns strings representing FITS keywords.</span>

<span class="sd">        value : optional</span>
<span class="sd">            A default value to assign to each keyword; must be a valid type for</span>
<span class="sd">            FITS keywords.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        `Header`</span>
<span class="sd">            A new `Header` instance.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">d</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="n">value</span> <span class="o">=</span> <span class="p">(</span><span class="n">value</span><span class="p">,)</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">iterable</span><span class="p">:</span>
            <span class="n">d</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">key</span><span class="p">,)</span> <span class="o">+</span> <span class="n">value</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">d</span>

    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Similar to :meth:`dict.get`--returns the value associated with keyword</span>
<span class="sd">        in the header, or a default value if the keyword is not found.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        key : str</span>
<span class="sd">            A keyword that may or may not be in the header.</span>

<span class="sd">        default : optional</span>
<span class="sd">            A default value to return if the keyword is not found in the</span>
<span class="sd">            header.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        value: str, number, complex, bool, or ``astropy.io.fits.card.Undefined``</span>
<span class="sd">            The value associated with the given keyword, or the default value</span>
<span class="sd">            if the keyword is not in the header.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">KeyError</span><span class="p">,</span> <span class="ne">IndexError</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">default</span>

    <span class="k">def</span> <span class="nf">set</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">keyword</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">comment</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">before</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">after</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the value and/or comment and/or position of a specified keyword.</span>

<span class="sd">        If the keyword does not already exist in the header, a new keyword is</span>
<span class="sd">        created in the specified position, or appended to the end of the header</span>
<span class="sd">        if no position is specified.</span>

<span class="sd">        This method is similar to :meth:`Header.update` prior to Astropy v0.1.</span>

<span class="sd">        .. note::</span>
<span class="sd">            It should be noted that ``header.set(keyword, value)`` and</span>
<span class="sd">            ``header.set(keyword, value, comment)`` are equivalent to</span>
<span class="sd">            ``header[keyword] = value`` and</span>
<span class="sd">            ``header[keyword] = (value, comment)`` respectively.</span>

<span class="sd">            New keywords can also be inserted relative to existing keywords</span>
<span class="sd">            using, for example::</span>

<span class="sd">                &gt;&gt;&gt; header.insert(&#39;NAXIS1&#39;, (&#39;NAXIS&#39;, 2, &#39;Number of axes&#39;))</span>

<span class="sd">            to insert before an existing keyword, or::</span>

<span class="sd">                &gt;&gt;&gt; header.insert(&#39;NAXIS&#39;, (&#39;NAXIS1&#39;, 4096), after=True)</span>

<span class="sd">            to insert after an existing keyword.</span>

<span class="sd">            The only advantage of using :meth:`Header.set` is that it</span>
<span class="sd">            easily replaces the old usage of :meth:`Header.update` both</span>
<span class="sd">            conceptually and in terms of function signature.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        keyword : str</span>
<span class="sd">            A header keyword</span>

<span class="sd">        value : str, optional</span>
<span class="sd">            The value to set for the given keyword; if None the existing value</span>
<span class="sd">            is kept, but &#39;&#39; may be used to set a blank value</span>

<span class="sd">        comment : str, optional</span>
<span class="sd">            The comment to set for the given keyword; if None the existing</span>
<span class="sd">            comment is kept, but ``&#39;&#39;`` may be used to set a blank comment</span>

<span class="sd">        before : str, int, optional</span>
<span class="sd">            Name of the keyword, or index of the `Card` before which this card</span>
<span class="sd">            should be located in the header.  The argument ``before`` takes</span>
<span class="sd">            precedence over ``after`` if both specified.</span>

<span class="sd">        after : str, int, optional</span>
<span class="sd">            Name of the keyword, or index of the `Card` after which this card</span>
<span class="sd">            should be located in the header.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Create a temporary card that looks like the one being set; if the</span>
        <span class="c1"># temporary card turns out to be a RVKC this will make it easier to</span>
        <span class="c1"># deal with the idiosyncrasies thereof</span>
        <span class="c1"># Don&#39;t try to make a temporary card though if they keyword looks like</span>
        <span class="c1"># it might be a HIERARCH card or is otherwise invalid--this step is</span>
        <span class="c1"># only for validating RVKCs.</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">keyword</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">KEYWORD_LENGTH</span> <span class="ow">and</span>
            <span class="n">Card</span><span class="o">.</span><span class="n">_keywd_FSC_RE</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">keyword</span><span class="p">)</span> <span class="ow">and</span>
                <span class="n">keyword</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_keyword_indices</span><span class="p">):</span>
            <span class="n">new_card</span> <span class="o">=</span> <span class="n">Card</span><span class="p">(</span><span class="n">keyword</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">comment</span><span class="p">)</span>
            <span class="n">new_keyword</span> <span class="o">=</span> <span class="n">new_card</span><span class="o">.</span><span class="n">keyword</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">new_keyword</span> <span class="o">=</span> <span class="n">keyword</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">new_keyword</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">Card</span><span class="o">.</span><span class="n">_commentary_keywords</span> <span class="ow">and</span>
                <span class="n">new_keyword</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">comment</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">comment</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comments</span><span class="p">[</span><span class="n">keyword</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">keyword</span><span class="p">]</span>

            <span class="bp">self</span><span class="p">[</span><span class="n">keyword</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">comment</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">before</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">after</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">card</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cards</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_cardindex</span><span class="p">(</span><span class="n">keyword</span><span class="p">)]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_relativeinsert</span><span class="p">(</span><span class="n">card</span><span class="p">,</span> <span class="n">before</span><span class="o">=</span><span class="n">before</span><span class="p">,</span> <span class="n">after</span><span class="o">=</span><span class="n">after</span><span class="p">,</span>
                                     <span class="n">replace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">before</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">after</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_relativeinsert</span><span class="p">((</span><span class="n">keyword</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">comment</span><span class="p">),</span> <span class="n">before</span><span class="o">=</span><span class="n">before</span><span class="p">,</span>
                                 <span class="n">after</span><span class="o">=</span><span class="n">after</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="p">[</span><span class="n">keyword</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">comment</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">items</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Like :meth:`dict.items`.&quot;&quot;&quot;</span>

        <span class="k">for</span> <span class="n">card</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cards</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">card</span><span class="o">.</span><span class="n">keyword</span><span class="p">,</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">card</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="n">UNDEFINED</span> <span class="k">else</span> <span class="n">card</span><span class="o">.</span><span class="n">value</span>

    <span class="k">def</span> <span class="nf">keys</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Like :meth:`dict.keys`--iterating directly over the `Header`</span>
<span class="sd">        instance has the same behavior.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">for</span> <span class="n">card</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cards</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">card</span><span class="o">.</span><span class="n">keyword</span>

    <span class="k">def</span> <span class="nf">values</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Like :meth:`dict.values`.&quot;&quot;&quot;</span>

        <span class="k">for</span> <span class="n">card</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cards</span><span class="p">:</span>
            <span class="k">yield</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">card</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="n">UNDEFINED</span> <span class="k">else</span> <span class="n">card</span><span class="o">.</span><span class="n">value</span>

    <span class="k">def</span> <span class="nf">pop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Works like :meth:`list.pop` if no arguments or an index argument are</span>
<span class="sd">        supplied; otherwise works like :meth:`dict.pop`.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Header.pop expected at most 2 arguments, got </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">key</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">key</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">KeyError</span><span class="p">,</span> <span class="ne">IndexError</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">raise</span>

        <span class="k">del</span> <span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">value</span>

    <span class="k">def</span> <span class="nf">popitem</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Similar to :meth:`dict.popitem`.&quot;&quot;&quot;</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
        <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s1">&#39;Header is empty&#39;</span><span class="p">)</span>
        <span class="k">del</span> <span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span>

    <span class="k">def</span> <span class="nf">setdefault</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Similar to :meth:`dict.setdefault`.&quot;&quot;&quot;</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">KeyError</span><span class="p">,</span> <span class="ne">IndexError</span><span class="p">):</span>
            <span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">default</span>
        <span class="k">return</span> <span class="n">default</span>

    <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Update the Header with new keyword values, updating the values of</span>
<span class="sd">        existing keywords and appending new keywords otherwise; similar to</span>
<span class="sd">        `dict.update`.</span>

<span class="sd">        `update` accepts either a dict-like object or an iterable.  In the</span>
<span class="sd">        former case the keys must be header keywords and the values may be</span>
<span class="sd">        either scalar values or (value, comment) tuples.  In the case of an</span>
<span class="sd">        iterable the items must be (keyword, value) tuples or (keyword, value,</span>
<span class="sd">        comment) tuples.</span>

<span class="sd">        Arbitrary arguments are also accepted, in which case the update() is</span>
<span class="sd">        called again with the kwargs dict as its only argument.  That is,</span>

<span class="sd">        ::</span>

<span class="sd">            &gt;&gt;&gt; header.update(NAXIS1=100, NAXIS2=100)</span>

<span class="sd">        is equivalent to::</span>

<span class="sd">            header.update({&#39;NAXIS1&#39;: 100, &#39;NAXIS2&#39;: 100})</span>

<span class="sd">        .. warning::</span>
<span class="sd">            As this method works similarly to `dict.update` it is very</span>
<span class="sd">            different from the ``Header.update()`` method in Astropy v0.1.</span>
<span class="sd">            Use of the old API was</span>
<span class="sd">            **deprecated** for a long time and is now removed. Most uses of the</span>
<span class="sd">            old API can be replaced as follows:</span>

<span class="sd">            * Replace ::</span>

<span class="sd">                  header.update(keyword, value)</span>

<span class="sd">              with ::</span>

<span class="sd">                  header[keyword] = value</span>

<span class="sd">            * Replace ::</span>

<span class="sd">                  header.update(keyword, value, comment=comment)</span>

<span class="sd">              with ::</span>

<span class="sd">                  header[keyword] = (value, comment)</span>

<span class="sd">            * Replace ::</span>

<span class="sd">                  header.update(keyword, value, before=before_keyword)</span>

<span class="sd">              with ::</span>

<span class="sd">                  header.insert(before_keyword, (keyword, value))</span>

<span class="sd">            * Replace ::</span>

<span class="sd">                  header.update(keyword, value, after=after_keyword)</span>

<span class="sd">              with ::</span>

<span class="sd">                  header.insert(after_keyword, (keyword, value),</span>
<span class="sd">                                after=True)</span>

<span class="sd">            See also :meth:`Header.set` which is a new method that provides an</span>
<span class="sd">            interface similar to the old ``Header.update()`` and may help make</span>
<span class="sd">            transition a little easier.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">args</span><span class="p">:</span>
            <span class="n">other</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">other</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">def</span> <span class="nf">update_from_dict</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
                <span class="n">card</span> <span class="o">=</span> <span class="n">Card</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
            <span class="k">elif</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">card</span> <span class="o">=</span> <span class="n">Card</span><span class="p">(</span><span class="o">*</span><span class="p">((</span><span class="n">k</span><span class="p">,)</span> <span class="o">+</span> <span class="n">v</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s1">&#39;Header update value for key </span><span class="si">%r</span><span class="s1"> is invalid; the &#39;</span>
                    <span class="s1">&#39;value must be either a scalar, a 1-tuple &#39;</span>
                    <span class="s1">&#39;containing the scalar value, or a 2-tuple &#39;</span>
                    <span class="s1">&#39;containing the value and a comment string.&#39;</span> <span class="o">%</span> <span class="n">k</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update</span><span class="p">(</span><span class="n">card</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">other</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Header</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">card</span> <span class="ow">in</span> <span class="n">other</span><span class="o">.</span><span class="n">cards</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_update</span><span class="p">(</span><span class="n">card</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="s1">&#39;items&#39;</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">other</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">update_from_dict</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="s1">&#39;keys&#39;</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">other</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">update_from_dict</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">other</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">card</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">card</span><span class="p">,</span> <span class="n">Card</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_update</span><span class="p">(</span><span class="n">card</span><span class="p">)</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">card</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">card</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">3</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_update</span><span class="p">(</span><span class="n">Card</span><span class="p">(</span><span class="o">*</span><span class="n">card</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s1">&#39;Header update sequence item #</span><span class="si">{}</span><span class="s1"> is invalid; &#39;</span>
                        <span class="s1">&#39;the item must either be a 2-tuple containing &#39;</span>
                        <span class="s1">&#39;a keyword and value, or a 3-tuple containing &#39;</span>
                        <span class="s1">&#39;a keyword, value, and comment string.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">idx</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">append</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">card</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">useblanks</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">bottom</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Appends a new keyword+value card to the end of the Header, similar</span>
<span class="sd">        to `list.append`.</span>

<span class="sd">        By default if the last cards in the Header have commentary keywords,</span>
<span class="sd">        this will append the new keyword before the commentary (unless the new</span>
<span class="sd">        keyword is also commentary).</span>

<span class="sd">        Also differs from `list.append` in that it can be called with no</span>
<span class="sd">        arguments: In this case a blank card is appended to the end of the</span>
<span class="sd">        Header.  In the case all the keyword arguments are ignored.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        card : str, tuple</span>
<span class="sd">            A keyword or a (keyword, value, [comment]) tuple representing a</span>
<span class="sd">            single header card; the comment is optional in which case a</span>
<span class="sd">            2-tuple may be used</span>

<span class="sd">        useblanks : bool, optional</span>
<span class="sd">            If there are blank cards at the end of the Header, replace the</span>
<span class="sd">            first blank card so that the total number of cards in the Header</span>
<span class="sd">            does not increase.  Otherwise preserve the number of blank cards.</span>

<span class="sd">        bottom : bool, optional</span>
<span class="sd">            If True, instead of appending after the last non-commentary card,</span>
<span class="sd">            append after the last non-blank card.</span>

<span class="sd">        end : bool, optional</span>
<span class="sd">            If True, ignore the useblanks and bottom options, and append at the</span>
<span class="sd">            very end of the Header.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">card</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">card</span> <span class="o">=</span> <span class="n">Card</span><span class="p">(</span><span class="n">card</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">card</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="n">card</span> <span class="o">=</span> <span class="n">Card</span><span class="p">(</span><span class="o">*</span><span class="n">card</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">card</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">card</span> <span class="o">=</span> <span class="n">Card</span><span class="p">()</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">card</span><span class="p">,</span> <span class="n">Card</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s1">&#39;The value appended to a Header must be either a keyword or &#39;</span>
                <span class="s1">&#39;(keyword, value, [comment]) tuple; got: </span><span class="si">{!r}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">card</span><span class="p">))</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">end</span> <span class="ow">and</span> <span class="n">card</span><span class="o">.</span><span class="n">is_blank</span><span class="p">:</span>
            <span class="c1"># Blank cards should always just be appended to the end</span>
            <span class="n">end</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">if</span> <span class="n">end</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cards</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">card</span><span class="p">)</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cards</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cards</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="k">while</span> <span class="n">idx</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cards</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">is_blank</span><span class="p">:</span>
                <span class="n">idx</span> <span class="o">-=</span> <span class="mi">1</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">bottom</span> <span class="ow">and</span> <span class="n">card</span><span class="o">.</span><span class="n">keyword</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">Card</span><span class="o">.</span><span class="n">_commentary_keywords</span><span class="p">:</span>
                <span class="k">while</span> <span class="p">(</span><span class="n">idx</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">and</span>
                       <span class="bp">self</span><span class="o">.</span><span class="n">_cards</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">keyword</span> <span class="ow">in</span> <span class="n">Card</span><span class="o">.</span><span class="n">_commentary_keywords</span><span class="p">):</span>
                    <span class="n">idx</span> <span class="o">-=</span> <span class="mi">1</span>

            <span class="n">idx</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cards</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">card</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_updateindices</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>

        <span class="n">keyword</span> <span class="o">=</span> <span class="n">Card</span><span class="o">.</span><span class="n">normalize_keyword</span><span class="p">(</span><span class="n">card</span><span class="o">.</span><span class="n">keyword</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_keyword_indices</span><span class="p">[</span><span class="n">keyword</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">card</span><span class="o">.</span><span class="n">field_specifier</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_rvkc_indices</span><span class="p">[</span><span class="n">card</span><span class="o">.</span><span class="n">rawkeyword</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">end</span><span class="p">:</span>
            <span class="c1"># If the appended card was a commentary card, and it was appended</span>
            <span class="c1"># before existing cards with the same keyword, the indices for</span>
            <span class="c1"># cards with that keyword may have changed</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">bottom</span> <span class="ow">and</span> <span class="n">card</span><span class="o">.</span><span class="n">keyword</span> <span class="ow">in</span> <span class="n">Card</span><span class="o">.</span><span class="n">_commentary_keywords</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_keyword_indices</span><span class="p">[</span><span class="n">keyword</span><span class="p">]</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>

            <span class="c1"># Finally, if useblanks, delete a blank cards from the end</span>
            <span class="k">if</span> <span class="n">useblanks</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_countblanks</span><span class="p">():</span>
                <span class="c1"># Don&#39;t do this unless there is at least one blanks at the end</span>
                <span class="c1"># of the header; we need to convert the card to its string</span>
                <span class="c1"># image to see how long it is.  In the vast majority of cases</span>
                <span class="c1"># this will just be 80 (Card.length) but it may be longer for</span>
                <span class="c1"># CONTINUE cards</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_useblanks</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">card</span><span class="p">))</span> <span class="o">//</span> <span class="n">Card</span><span class="o">.</span><span class="n">length</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_modified</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">extend</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cards</span><span class="p">,</span> <span class="n">strip</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">unique</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">update</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
               <span class="n">update_first</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">useblanks</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">bottom</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Appends multiple keyword+value cards to the end of the header, similar</span>
<span class="sd">        to `list.extend`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        cards : iterable</span>
<span class="sd">            An iterable of (keyword, value, [comment]) tuples; see</span>
<span class="sd">            `Header.append`.</span>

<span class="sd">        strip : bool, optional</span>
<span class="sd">            Remove any keywords that have meaning only to specific types of</span>
<span class="sd">            HDUs, so that only more general keywords are added from extension</span>
<span class="sd">            Header or Card list (default: `True`).</span>

<span class="sd">        unique : bool, optional</span>
<span class="sd">            If `True`, ensures that no duplicate keywords are appended;</span>
<span class="sd">            keywords already in this header are simply discarded.  The</span>
<span class="sd">            exception is commentary keywords (COMMENT, HISTORY, etc.): they are</span>
<span class="sd">            only treated as duplicates if their values match.</span>

<span class="sd">        update : bool, optional</span>
<span class="sd">            If `True`, update the current header with the values and comments</span>
<span class="sd">            from duplicate keywords in the input header.  This supersedes the</span>
<span class="sd">            ``unique`` argument.  Commentary keywords are treated the same as</span>
<span class="sd">            if ``unique=True``.</span>

<span class="sd">        update_first : bool, optional</span>
<span class="sd">            If the first keyword in the header is &#39;SIMPLE&#39;, and the first</span>
<span class="sd">            keyword in the input header is &#39;XTENSION&#39;, the &#39;SIMPLE&#39; keyword is</span>
<span class="sd">            replaced by the &#39;XTENSION&#39; keyword.  Likewise if the first keyword</span>
<span class="sd">            in the header is &#39;XTENSION&#39; and the first keyword in the input</span>
<span class="sd">            header is &#39;SIMPLE&#39;, the &#39;XTENSION&#39; keyword is replaced by the</span>
<span class="sd">            &#39;SIMPLE&#39; keyword.  This behavior is otherwise dumb as to whether or</span>
<span class="sd">            not the resulting header is a valid primary or extension header.</span>
<span class="sd">            This is mostly provided to support backwards compatibility with the</span>
<span class="sd">            old ``Header.fromTxtFile`` method, and only applies if</span>
<span class="sd">            ``update=True``.</span>

<span class="sd">        useblanks, bottom, end : bool, optional</span>
<span class="sd">            These arguments are passed to :meth:`Header.append` while appending</span>
<span class="sd">            new cards to the header.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">temp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">cards</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">strip</span><span class="p">:</span>
            <span class="n">temp</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="n">first</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cards</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">keyword</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">first</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># We don&#39;t immediately modify the header, because first we need to sift</span>
        <span class="c1"># out any duplicates in the new header prior to adding them to the</span>
        <span class="c1"># existing header, but while *allowing* duplicates from the header</span>
        <span class="c1"># being extended from (see ticket #156)</span>
        <span class="n">extend_cards</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">card</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">temp</span><span class="o">.</span><span class="n">cards</span><span class="p">):</span>
            <span class="n">keyword</span> <span class="o">=</span> <span class="n">card</span><span class="o">.</span><span class="n">keyword</span>
            <span class="k">if</span> <span class="n">keyword</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">Card</span><span class="o">.</span><span class="n">_commentary_keywords</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">unique</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">update</span> <span class="ow">and</span> <span class="n">keyword</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="k">elif</span> <span class="n">update</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">idx</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">update_first</span><span class="p">:</span>
                        <span class="c1"># Dumbly update the first keyword to either SIMPLE or</span>
                        <span class="c1"># XTENSION as the case may be, as was in the case in</span>
                        <span class="c1"># Header.fromTxtFile</span>
                        <span class="k">if</span> <span class="p">((</span><span class="n">keyword</span> <span class="o">==</span> <span class="s1">&#39;SIMPLE&#39;</span> <span class="ow">and</span> <span class="n">first</span> <span class="o">==</span> <span class="s1">&#39;XTENSION&#39;</span><span class="p">)</span> <span class="ow">or</span>
                                <span class="p">(</span><span class="n">keyword</span> <span class="o">==</span> <span class="s1">&#39;XTENSION&#39;</span> <span class="ow">and</span> <span class="n">first</span> <span class="o">==</span> <span class="s1">&#39;SIMPLE&#39;</span><span class="p">)):</span>
                            <span class="k">del</span> <span class="bp">self</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">card</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="bp">self</span><span class="p">[</span><span class="n">keyword</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">card</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">card</span><span class="o">.</span><span class="n">comment</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="n">keyword</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
                        <span class="bp">self</span><span class="p">[</span><span class="n">keyword</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">card</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">card</span><span class="o">.</span><span class="n">comment</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">extend_cards</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">card</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">extend_cards</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">card</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">unique</span> <span class="ow">or</span> <span class="n">update</span><span class="p">)</span> <span class="ow">and</span> <span class="n">keyword</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">card</span><span class="o">.</span><span class="n">is_blank</span><span class="p">:</span>
                        <span class="n">extend_cards</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">card</span><span class="p">)</span>
                        <span class="k">continue</span>

                    <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">[</span><span class="n">keyword</span><span class="p">]:</span>
                        <span class="k">if</span> <span class="n">value</span> <span class="o">==</span> <span class="n">card</span><span class="o">.</span><span class="n">value</span><span class="p">:</span>
                            <span class="k">break</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">extend_cards</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">card</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">extend_cards</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">card</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">card</span> <span class="ow">in</span> <span class="n">extend_cards</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">card</span><span class="p">,</span> <span class="n">useblanks</span><span class="o">=</span><span class="n">useblanks</span><span class="p">,</span> <span class="n">bottom</span><span class="o">=</span><span class="n">bottom</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="n">end</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">count</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">keyword</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the count of the given keyword in the header, similar to</span>
<span class="sd">        `list.count` if the Header object is treated as a list of keywords.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        keyword : str</span>
<span class="sd">            The keyword to count instances of in the header</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">keyword</span> <span class="o">=</span> <span class="n">Card</span><span class="o">.</span><span class="n">normalize_keyword</span><span class="p">(</span><span class="n">keyword</span><span class="p">)</span>

        <span class="c1"># We have to look before we leap, since otherwise _keyword_indices,</span>
        <span class="c1"># being a defaultdict, will create an entry for the nonexistent keyword</span>
        <span class="k">if</span> <span class="n">keyword</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_keyword_indices</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Keyword </span><span class="si">{</span><span class="n">keyword</span><span class="si">!r}</span><span class="s2"> not found.&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_keyword_indices</span><span class="p">[</span><span class="n">keyword</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">keyword</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">stop</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the index if the first instance of the given keyword in the</span>
<span class="sd">        header, similar to `list.index` if the Header object is treated as a</span>
<span class="sd">        list of keywords.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        keyword : str</span>
<span class="sd">            The keyword to look up in the list of all keywords in the header</span>

<span class="sd">        start : int, optional</span>
<span class="sd">            The lower bound for the index</span>

<span class="sd">        stop : int, optional</span>
<span class="sd">            The upper bound for the index</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">start</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">if</span> <span class="n">stop</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">stop</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cards</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">stop</span> <span class="o">&lt;</span> <span class="n">start</span><span class="p">:</span>
            <span class="n">step</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">step</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="n">norm_keyword</span> <span class="o">=</span> <span class="n">Card</span><span class="o">.</span><span class="n">normalize_keyword</span><span class="p">(</span><span class="n">keyword</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cards</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">keyword</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="o">==</span> <span class="n">norm_keyword</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">idx</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;The keyword </span><span class="si">{</span><span class="n">keyword</span><span class="si">!r}</span><span class="s1"> is not in the  header.&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">insert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">card</span><span class="p">,</span> <span class="n">useblanks</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">after</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Inserts a new keyword+value card into the Header at a given location,</span>
<span class="sd">        similar to `list.insert`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        key : int, str, or tuple</span>
<span class="sd">            The index into the list of header keywords before which the</span>
<span class="sd">            new keyword should be inserted, or the name of a keyword before</span>
<span class="sd">            which the new keyword should be inserted.  Can also accept a</span>
<span class="sd">            (keyword, index) tuple for inserting around duplicate keywords.</span>

<span class="sd">        card : str, tuple</span>
<span class="sd">            A keyword or a (keyword, value, [comment]) tuple; see</span>
<span class="sd">            `Header.append`</span>

<span class="sd">        useblanks : bool, optional</span>
<span class="sd">            If there are blank cards at the end of the Header, replace the</span>
<span class="sd">            first blank card so that the total number of cards in the Header</span>
<span class="sd">            does not increase.  Otherwise preserve the number of blank cards.</span>

<span class="sd">        after : bool, optional</span>
<span class="sd">            If set to `True`, insert *after* the specified index or keyword,</span>
<span class="sd">            rather than before it.  Defaults to `False`.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">numbers</span><span class="o">.</span><span class="n">Integral</span><span class="p">):</span>
            <span class="c1"># Don&#39;t pass through ints to _cardindex because it will not take</span>
            <span class="c1"># kindly to indices outside the existing number of cards in the</span>
            <span class="c1"># header, which insert needs to be able to support (for example</span>
            <span class="c1"># when inserting into empty headers)</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cardindex</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">key</span>

        <span class="k">if</span> <span class="n">after</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">idx</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cards</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">idx</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="n">idx</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cards</span><span class="p">):</span>
            <span class="c1"># This is just an append (Though it must be an append absolutely to</span>
            <span class="c1"># the bottom, ignoring blanks, etc.--the point of the insert method</span>
            <span class="c1"># is that you get exactly what you asked for with no surprises)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">card</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">card</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">card</span> <span class="o">=</span> <span class="n">Card</span><span class="p">(</span><span class="n">card</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">card</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="n">card</span> <span class="o">=</span> <span class="n">Card</span><span class="p">(</span><span class="o">*</span><span class="n">card</span><span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">card</span><span class="p">,</span> <span class="n">Card</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s1">&#39;The value inserted into a Header must be either a keyword or &#39;</span>
                <span class="s1">&#39;(keyword, value, [comment]) tuple; got: </span><span class="si">{!r}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">card</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_cards</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">card</span><span class="p">)</span>

        <span class="n">keyword</span> <span class="o">=</span> <span class="n">card</span><span class="o">.</span><span class="n">keyword</span>

        <span class="c1"># If idx was &lt; 0, determine the actual index according to the rules</span>
        <span class="c1"># used by list.insert()</span>
        <span class="k">if</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">idx</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cards</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># All the keyword indices above the insertion point must be updated</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_updateindices</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>

        <span class="n">keyword</span> <span class="o">=</span> <span class="n">Card</span><span class="o">.</span><span class="n">normalize_keyword</span><span class="p">(</span><span class="n">keyword</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_keyword_indices</span><span class="p">[</span><span class="n">keyword</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
        <span class="n">count</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_keyword_indices</span><span class="p">[</span><span class="n">keyword</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">count</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># There were already keywords with this same name</span>
            <span class="k">if</span> <span class="n">keyword</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">Card</span><span class="o">.</span><span class="n">_commentary_keywords</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="s1">&#39;A </span><span class="si">{!r}</span><span class="s1"> keyword already exists in this header.  Inserting &#39;</span>
                    <span class="s1">&#39;duplicate keyword.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">keyword</span><span class="p">),</span> <span class="n">AstropyUserWarning</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_keyword_indices</span><span class="p">[</span><span class="n">keyword</span><span class="p">]</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">card</span><span class="o">.</span><span class="n">field_specifier</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Update the index of RVKC as well</span>
            <span class="n">rvkc_indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rvkc_indices</span><span class="p">[</span><span class="n">card</span><span class="o">.</span><span class="n">rawkeyword</span><span class="p">]</span>
            <span class="n">rvkc_indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
            <span class="n">rvkc_indices</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">useblanks</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_useblanks</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">card</span><span class="p">))</span> <span class="o">//</span> <span class="n">Card</span><span class="o">.</span><span class="n">length</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_modified</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">remove</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">keyword</span><span class="p">,</span> <span class="n">ignore_missing</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">remove_all</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Removes the first instance of the given keyword from the header similar</span>
<span class="sd">        to `list.remove` if the Header object is treated as a list of keywords.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        keyword : str</span>
<span class="sd">            The keyword of which to remove the first instance in the header.</span>

<span class="sd">        ignore_missing : bool, optional</span>
<span class="sd">            When True, ignores missing keywords.  Otherwise, if the keyword</span>
<span class="sd">            is not present in the header a KeyError is raised.</span>

<span class="sd">        remove_all : bool, optional</span>
<span class="sd">            When True, all instances of keyword will be removed.</span>
<span class="sd">            Otherwise only the first instance of the given keyword is removed.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">keyword</span> <span class="o">=</span> <span class="n">Card</span><span class="o">.</span><span class="n">normalize_keyword</span><span class="p">(</span><span class="n">keyword</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">keyword</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_keyword_indices</span><span class="p">:</span>
            <span class="k">del</span> <span class="bp">self</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_keyword_indices</span><span class="p">[</span><span class="n">keyword</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span>
            <span class="k">if</span> <span class="n">remove_all</span><span class="p">:</span>
                <span class="k">while</span> <span class="n">keyword</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_keyword_indices</span><span class="p">:</span>
                    <span class="k">del</span> <span class="bp">self</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_keyword_indices</span><span class="p">[</span><span class="n">keyword</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="n">ignore_missing</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Keyword &#39;</span><span class="si">{</span><span class="n">keyword</span><span class="si">}</span><span class="s2">&#39; not found.&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">rename_keyword</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">oldkeyword</span><span class="p">,</span> <span class="n">newkeyword</span><span class="p">,</span> <span class="n">force</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Rename a card&#39;s keyword in the header.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        oldkeyword : str or int</span>
<span class="sd">            Old keyword or card index</span>

<span class="sd">        newkeyword : str</span>
<span class="sd">            New keyword</span>

<span class="sd">        force : bool, optional</span>
<span class="sd">            When `True`, if the new keyword already exists in the header, force</span>
<span class="sd">            the creation of a duplicate keyword. Otherwise a</span>
<span class="sd">            `ValueError` is raised.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">oldkeyword</span> <span class="o">=</span> <span class="n">Card</span><span class="o">.</span><span class="n">normalize_keyword</span><span class="p">(</span><span class="n">oldkeyword</span><span class="p">)</span>
        <span class="n">newkeyword</span> <span class="o">=</span> <span class="n">Card</span><span class="o">.</span><span class="n">normalize_keyword</span><span class="p">(</span><span class="n">newkeyword</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">newkeyword</span> <span class="o">==</span> <span class="s1">&#39;CONTINUE&#39;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Can not rename to CONTINUE&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">newkeyword</span> <span class="ow">in</span> <span class="n">Card</span><span class="o">.</span><span class="n">_commentary_keywords</span> <span class="ow">or</span>
                <span class="n">oldkeyword</span> <span class="ow">in</span> <span class="n">Card</span><span class="o">.</span><span class="n">_commentary_keywords</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">newkeyword</span> <span class="ow">in</span> <span class="n">Card</span><span class="o">.</span><span class="n">_commentary_keywords</span> <span class="ow">and</span>
                    <span class="n">oldkeyword</span> <span class="ow">in</span> <span class="n">Card</span><span class="o">.</span><span class="n">_commentary_keywords</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Regular and commentary keys can not be &#39;</span>
                                 <span class="s1">&#39;renamed to each other.&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="n">force</span> <span class="ow">and</span> <span class="n">newkeyword</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Intended keyword </span><span class="si">{</span><span class="n">newkeyword</span><span class="si">}</span><span class="s1"> already exists in header.&#39;</span><span class="p">)</span>

        <span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">oldkeyword</span><span class="p">)</span>
        <span class="n">card</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cards</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
        <span class="k">del</span> <span class="bp">self</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="p">(</span><span class="n">newkeyword</span><span class="p">,</span> <span class="n">card</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">card</span><span class="o">.</span><span class="n">comment</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">add_history</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">before</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">after</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add a ``HISTORY`` card.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        value : str</span>
<span class="sd">            History text to be added.</span>

<span class="sd">        before : str or int, optional</span>
<span class="sd">            Same as in `Header.update`</span>

<span class="sd">        after : str or int, optional</span>
<span class="sd">            Same as in `Header.update`</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_add_commentary</span><span class="p">(</span><span class="s1">&#39;HISTORY&#39;</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">before</span><span class="o">=</span><span class="n">before</span><span class="p">,</span> <span class="n">after</span><span class="o">=</span><span class="n">after</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">add_comment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">before</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">after</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add a ``COMMENT`` card.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        value : str</span>
<span class="sd">            Text to be added.</span>

<span class="sd">        before : str or int, optional</span>
<span class="sd">            Same as in `Header.update`</span>

<span class="sd">        after : str or int, optional</span>
<span class="sd">            Same as in `Header.update`</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_add_commentary</span><span class="p">(</span><span class="s1">&#39;COMMENT&#39;</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">before</span><span class="o">=</span><span class="n">before</span><span class="p">,</span> <span class="n">after</span><span class="o">=</span><span class="n">after</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">add_blank</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">before</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">after</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add a blank card.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        value : str, optional</span>
<span class="sd">            Text to be added.</span>

<span class="sd">        before : str or int, optional</span>
<span class="sd">            Same as in `Header.update`</span>

<span class="sd">        after : str or int, optional</span>
<span class="sd">            Same as in `Header.update`</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_add_commentary</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">before</span><span class="o">=</span><span class="n">before</span><span class="p">,</span> <span class="n">after</span><span class="o">=</span><span class="n">after</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">strip</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Strip cards specific to a certain kind of header.</span>

<span class="sd">        Strip cards like ``SIMPLE``, ``BITPIX``, etc. so the rest of</span>
<span class="sd">        the header can be used to reconstruct another kind of header.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># TODO: Previously this only deleted some cards specific to an HDU if</span>
        <span class="c1"># _hdutype matched that type.  But it seemed simple enough to just</span>
        <span class="c1"># delete all desired cards anyways, and just ignore the KeyErrors if</span>
        <span class="c1"># they don&#39;t exist.</span>
        <span class="c1"># However, it might be desirable to make this extendable somehow--have</span>
        <span class="c1"># a way for HDU classes to specify some headers that are specific only</span>
        <span class="c1"># to that type, and should be removed otherwise.</span>

        <span class="n">naxis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;NAXIS&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">tfields</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;TFIELDS&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">naxis</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="s1">&#39;NAXIS&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">ignore_missing</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;TFORM&#39;</span><span class="p">,</span> <span class="s1">&#39;TSCAL&#39;</span><span class="p">,</span> <span class="s1">&#39;TZERO&#39;</span><span class="p">,</span> <span class="s1">&#39;TNULL&#39;</span><span class="p">,</span> <span class="s1">&#39;TTYPE&#39;</span><span class="p">,</span>
                     <span class="s1">&#39;TUNIT&#39;</span><span class="p">,</span> <span class="s1">&#39;TDISP&#39;</span><span class="p">,</span> <span class="s1">&#39;TDIM&#39;</span><span class="p">,</span> <span class="s1">&#39;THEAP&#39;</span><span class="p">,</span> <span class="s1">&#39;TBCOL&#39;</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">tfields</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">name</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">ignore_missing</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;SIMPLE&#39;</span><span class="p">,</span> <span class="s1">&#39;XTENSION&#39;</span><span class="p">,</span> <span class="s1">&#39;BITPIX&#39;</span><span class="p">,</span> <span class="s1">&#39;NAXIS&#39;</span><span class="p">,</span> <span class="s1">&#39;EXTEND&#39;</span><span class="p">,</span>
                     <span class="s1">&#39;PCOUNT&#39;</span><span class="p">,</span> <span class="s1">&#39;GCOUNT&#39;</span><span class="p">,</span> <span class="s1">&#39;GROUPS&#39;</span><span class="p">,</span> <span class="s1">&#39;BSCALE&#39;</span><span class="p">,</span> <span class="s1">&#39;BZERO&#39;</span><span class="p">,</span>
                     <span class="s1">&#39;TFIELDS&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">ignore_missing</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">data_size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the size (in bytes) of the data portion following the `Header`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_hdr_data_size</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">data_size_padded</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the size (in bytes) of the data portion following the `Header`</span>
<span class="sd">        including padding.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_size</span>
        <span class="k">return</span> <span class="n">size</span> <span class="o">+</span> <span class="n">_pad_length</span><span class="p">(</span><span class="n">size</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">card</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The real update code.  If keyword already exists, its value and/or</span>
<span class="sd">        comment will be updated.  Otherwise a new card will be appended.</span>

<span class="sd">        This will not create a duplicate keyword except in the case of</span>
<span class="sd">        commentary cards.  The only other way to force creation of a duplicate</span>
<span class="sd">        is to use the insert(), append(), or extend() methods.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">keyword</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">comment</span> <span class="o">=</span> <span class="n">card</span>

        <span class="c1"># Lookups for existing/known keywords are case-insensitive</span>
        <span class="n">keyword</span> <span class="o">=</span> <span class="n">keyword</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">keyword</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;HIERARCH &#39;</span><span class="p">):</span>
            <span class="n">keyword</span> <span class="o">=</span> <span class="n">keyword</span><span class="p">[</span><span class="mi">9</span><span class="p">:]</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">keyword</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">Card</span><span class="o">.</span><span class="n">_commentary_keywords</span> <span class="ow">and</span>
                <span class="n">keyword</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_keyword_indices</span><span class="p">):</span>
            <span class="c1"># Easy; just update the value/comment</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_keyword_indices</span><span class="p">[</span><span class="n">keyword</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">existing_card</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cards</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
            <span class="n">existing_card</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span>
            <span class="k">if</span> <span class="n">comment</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># &#39;&#39; should be used to explicitly blank a comment</span>
                <span class="n">existing_card</span><span class="o">.</span><span class="n">comment</span> <span class="o">=</span> <span class="n">comment</span>
            <span class="k">if</span> <span class="n">existing_card</span><span class="o">.</span><span class="n">_modified</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_modified</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">elif</span> <span class="n">keyword</span> <span class="ow">in</span> <span class="n">Card</span><span class="o">.</span><span class="n">_commentary_keywords</span><span class="p">:</span>
            <span class="n">cards</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_splitcommentary</span><span class="p">(</span><span class="n">keyword</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">keyword</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_keyword_indices</span><span class="p">:</span>
                <span class="c1"># Append after the last keyword of the same type</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">keyword</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">stop</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">isblank</span> <span class="o">=</span> <span class="ow">not</span> <span class="p">(</span><span class="n">keyword</span> <span class="ow">or</span> <span class="n">value</span> <span class="ow">or</span> <span class="n">comment</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="n">cards</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">useblanks</span><span class="o">=</span><span class="p">(</span><span class="ow">not</span> <span class="n">isblank</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">cards</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">bottom</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># A new keyword! self.append() will handle updating _modified</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">card</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_cardindex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns an index into the ._cards list given a valid lookup key.&quot;&quot;&quot;</span>

        <span class="c1"># This used to just set key = (key, 0) and then go on to act as if the</span>
        <span class="c1"># user passed in a tuple, but it&#39;s much more common to just be given a</span>
        <span class="c1"># string as the key, so optimize more for that case</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">keyword</span> <span class="o">=</span> <span class="n">key</span>
            <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">numbers</span><span class="o">.</span><span class="n">Integral</span><span class="p">):</span>
            <span class="c1"># If &lt; 0, determine the actual index</span>
            <span class="k">if</span> <span class="n">key</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">key</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cards</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">key</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">key</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cards</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s1">&#39;Header index out of range.&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">key</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">key</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">or</span>
                    <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">numbers</span><span class="o">.</span><span class="n">Integral</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s1">&#39;Tuple indices must be 2-tuples consisting of a &#39;</span>
                    <span class="s1">&#39;keyword string and an integer index.&#39;</span><span class="p">)</span>
            <span class="n">keyword</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="n">key</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s1">&#39;Header indices must be either a string, a 2-tuple, or &#39;</span>
                <span class="s1">&#39;an integer.&#39;</span><span class="p">)</span>

        <span class="n">keyword</span> <span class="o">=</span> <span class="n">Card</span><span class="o">.</span><span class="n">normalize_keyword</span><span class="p">(</span><span class="n">keyword</span><span class="p">)</span>
        <span class="c1"># Returns the index into _cards for the n-th card with the given</span>
        <span class="c1"># keyword (where n is 0-based)</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_keyword_indices</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">keyword</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">keyword</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">indices</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">keyword</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">KEYWORD_LENGTH</span> <span class="ow">or</span> <span class="s1">&#39;.&#39;</span> <span class="ow">in</span> <span class="n">keyword</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Keyword </span><span class="si">{</span><span class="n">keyword</span><span class="si">!r}</span><span class="s2"> not found.&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Maybe it&#39;s a RVKC?</span>
                <span class="n">indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rvkc_indices</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">keyword</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">indices</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Keyword </span><span class="si">{</span><span class="n">keyword</span><span class="si">!r}</span><span class="s2"> not found.&quot;</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">indices</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s1">&#39;There are only </span><span class="si">{}</span><span class="s1"> </span><span class="si">{!r}</span><span class="s1"> cards in the &#39;</span>
                             <span class="s1">&#39;header.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">),</span> <span class="n">keyword</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_keyword_from_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given an integer index, return the (keyword, repeat) tuple that index</span>
<span class="sd">        refers to.  For most keywords the repeat will always be zero, but it</span>
<span class="sd">        may be greater than zero for keywords that are duplicated (especially</span>
<span class="sd">        commentary keywords).</span>

<span class="sd">        In a sense this is the inverse of self.index, except that it also</span>
<span class="sd">        supports duplicates.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">idx</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cards</span><span class="p">)</span>

        <span class="n">keyword</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cards</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">keyword</span>
        <span class="n">keyword</span> <span class="o">=</span> <span class="n">Card</span><span class="o">.</span><span class="n">normalize_keyword</span><span class="p">(</span><span class="n">keyword</span><span class="p">)</span>
        <span class="n">repeat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_keyword_indices</span><span class="p">[</span><span class="n">keyword</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">keyword</span><span class="p">,</span> <span class="n">repeat</span>

    <span class="k">def</span> <span class="nf">_relativeinsert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">card</span><span class="p">,</span> <span class="n">before</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">after</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Inserts a new card before or after an existing card; used to</span>
<span class="sd">        implement support for the legacy before/after keyword arguments to</span>
<span class="sd">        Header.update().</span>

<span class="sd">        If replace=True, move an existing card with the same keyword.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">before</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">insertionkey</span> <span class="o">=</span> <span class="n">after</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">insertionkey</span> <span class="o">=</span> <span class="n">before</span>

        <span class="k">def</span> <span class="nf">get_insertion_idx</span><span class="p">():</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">insertionkey</span><span class="p">,</span> <span class="n">numbers</span><span class="o">.</span><span class="n">Integral</span><span class="p">)</span> <span class="ow">and</span>
                    <span class="n">insertionkey</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cards</span><span class="p">)):</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cardindex</span><span class="p">(</span><span class="n">insertionkey</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="n">insertionkey</span>

            <span class="k">if</span> <span class="n">before</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">idx</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="k">return</span> <span class="n">idx</span>

        <span class="k">if</span> <span class="n">replace</span><span class="p">:</span>
            <span class="c1"># The card presumably already exists somewhere in the header.</span>
            <span class="c1"># Check whether or not we actually have to move it; if it does need</span>
            <span class="c1"># to be moved we just delete it and then it will be reinserted</span>
            <span class="c1"># below</span>
            <span class="n">old_idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cardindex</span><span class="p">(</span><span class="n">card</span><span class="o">.</span><span class="n">keyword</span><span class="p">)</span>
            <span class="n">insertion_idx</span> <span class="o">=</span> <span class="n">get_insertion_idx</span><span class="p">()</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">insertion_idx</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cards</span><span class="p">)</span> <span class="ow">and</span>
                    <span class="n">old_idx</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cards</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
                <span class="c1"># The card would be appended to the end, but it&#39;s already at</span>
                <span class="c1"># the end</span>
                <span class="k">return</span>

            <span class="k">if</span> <span class="n">before</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">old_idx</span> <span class="o">==</span> <span class="n">insertion_idx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">return</span>
            <span class="k">elif</span> <span class="n">after</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">old_idx</span> <span class="o">==</span> <span class="n">insertion_idx</span><span class="p">:</span>
                <span class="k">return</span>

            <span class="k">del</span> <span class="bp">self</span><span class="p">[</span><span class="n">old_idx</span><span class="p">]</span>

        <span class="c1"># Even if replace=True, the insertion idx may have changed since the</span>
        <span class="c1"># old card was deleted</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">get_insertion_idx</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">card</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="n">Card</span><span class="o">.</span><span class="n">_commentary_keywords</span><span class="p">:</span>
            <span class="n">cards</span> <span class="o">=</span> <span class="nb">reversed</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_splitcommentary</span><span class="p">(</span><span class="n">card</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">card</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">cards</span> <span class="o">=</span> <span class="p">[</span><span class="n">card</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">cards</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_updateindices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">increment</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        For all cards with index above idx, increment or decrement its index</span>
<span class="sd">        value in the keyword_indices dict.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">idx</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cards</span><span class="p">):</span>
            <span class="c1"># Save us some effort</span>
            <span class="k">return</span>

        <span class="n">increment</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">increment</span> <span class="k">else</span> <span class="o">-</span><span class="mi">1</span>

        <span class="k">for</span> <span class="n">index_sets</span> <span class="ow">in</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_keyword_indices</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rvkc_indices</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">indices</span> <span class="ow">in</span> <span class="n">index_sets</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                <span class="k">for</span> <span class="n">jdx</span><span class="p">,</span> <span class="n">keyword_index</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">indices</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">keyword_index</span> <span class="o">&gt;=</span> <span class="n">idx</span><span class="p">:</span>
                        <span class="n">indices</span><span class="p">[</span><span class="n">jdx</span><span class="p">]</span> <span class="o">+=</span> <span class="n">increment</span>

    <span class="k">def</span> <span class="nf">_countblanks</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the number of blank cards at the end of the Header.&quot;&quot;&quot;</span>

        <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cards</span><span class="p">)):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cards</span><span class="p">[</span><span class="o">-</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">is_blank</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">idx</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">_useblanks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">count</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">count</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cards</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">is_blank</span><span class="p">:</span>
                <span class="k">del</span> <span class="bp">self</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">break</span>

    <span class="k">def</span> <span class="nf">_haswildcard</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">keyword</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return `True` if the input keyword contains a wildcard pattern.&quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">keyword</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">and</span>
                <span class="p">(</span><span class="n">keyword</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;...&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="s1">&#39;*&#39;</span> <span class="ow">in</span> <span class="n">keyword</span> <span class="ow">or</span> <span class="s1">&#39;?&#39;</span> <span class="ow">in</span> <span class="n">keyword</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_wildcardmatch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pattern</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a list of indices of the cards matching the given wildcard</span>
<span class="sd">        pattern.</span>

<span class="sd">         * &#39;*&#39; matches 0 or more characters</span>
<span class="sd">         * &#39;?&#39; matches a single character</span>
<span class="sd">         * &#39;...&#39; matches 0 or more of any non-whitespace character</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">pattern</span> <span class="o">=</span> <span class="n">pattern</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;*&#39;</span><span class="p">,</span> <span class="sa">r</span><span class="s1">&#39;.*&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;?&#39;</span><span class="p">,</span> <span class="sa">r</span><span class="s1">&#39;.&#39;</span><span class="p">)</span>
        <span class="n">pattern</span> <span class="o">=</span> <span class="n">pattern</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;...&#39;</span><span class="p">,</span> <span class="sa">r</span><span class="s1">&#39;\S*&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;$&#39;</span>
        <span class="n">pattern_re</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">pattern</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">I</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">[</span><span class="n">idx</span> <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">card</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cards</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">pattern_re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">card</span><span class="o">.</span><span class="n">keyword</span><span class="p">)]</span>

    <span class="k">def</span> <span class="nf">_set_slice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Used to implement Header.__setitem__ and CardAccessor.__setitem__.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">slice</span><span class="p">)</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_haswildcard</span><span class="p">(</span><span class="n">key</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
                <span class="n">indices</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="o">*</span><span class="n">key</span><span class="o">.</span><span class="n">indices</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">target</span><span class="p">)))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wildcardmatch</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">isiterable</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">itertools</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">))</span>

            <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
                <span class="n">target</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>

            <span class="k">return</span> <span class="kc">True</span>

        <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">_splitcommentary</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">keyword</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given a commentary keyword and value, returns a list of the one or more</span>
<span class="sd">        cards needed to represent the full value.  This is primarily used to</span>
<span class="sd">        create the multiple commentary cards needed to represent a long value</span>
<span class="sd">        that won&#39;t fit into a single commentary card.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># The maximum value in each card can be the maximum card length minus</span>
        <span class="c1"># the maximum key length (which can include spaces if they key length</span>
        <span class="c1"># less than 8</span>
        <span class="n">maxlen</span> <span class="o">=</span> <span class="n">Card</span><span class="o">.</span><span class="n">length</span> <span class="o">-</span> <span class="n">KEYWORD_LENGTH</span>
        <span class="n">valuestr</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">valuestr</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">maxlen</span><span class="p">:</span>
            <span class="c1"># The value can fit in a single card</span>
            <span class="n">cards</span> <span class="o">=</span> <span class="p">[</span><span class="n">Card</span><span class="p">(</span><span class="n">keyword</span><span class="p">,</span> <span class="n">value</span><span class="p">)]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># The value must be split across multiple consecutive commentary</span>
            <span class="c1"># cards</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">cards</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">while</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">valuestr</span><span class="p">):</span>
                <span class="n">cards</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Card</span><span class="p">(</span><span class="n">keyword</span><span class="p">,</span> <span class="n">valuestr</span><span class="p">[</span><span class="n">idx</span><span class="p">:</span><span class="n">idx</span> <span class="o">+</span> <span class="n">maxlen</span><span class="p">]))</span>
                <span class="n">idx</span> <span class="o">+=</span> <span class="n">maxlen</span>
        <span class="k">return</span> <span class="n">cards</span>

    <span class="k">def</span> <span class="nf">_add_commentary</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">before</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">after</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add a commentary card.</span>

<span class="sd">        If ``before`` and ``after`` are `None`, add to the last occurrence</span>
<span class="sd">        of cards of the same name (except blank card).  If there is no</span>
<span class="sd">        card (or blank card), append at the end.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">before</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">after</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_relativeinsert</span><span class="p">((</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">),</span> <span class="n">before</span><span class="o">=</span><span class="n">before</span><span class="p">,</span>
                                 <span class="n">after</span><span class="o">=</span><span class="n">after</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>


<span class="n">collections</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">MutableSequence</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">Header</span><span class="p">)</span>
<span class="n">collections</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">MutableMapping</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">Header</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">_DelayedHeader</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Descriptor used to create the Header object from the header string that</span>
<span class="sd">    was stored in HDU._header_str when parsing the file.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__get__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">owner</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">obj</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="s1">&#39;_header&#39;</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">obj</span><span class="o">.</span><span class="n">_header_str</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">hdr</span> <span class="o">=</span> <span class="n">Header</span><span class="o">.</span><span class="n">fromstring</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">_header_str</span><span class="p">)</span>
                <span class="n">obj</span><span class="o">.</span><span class="n">_header_str</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;&#39;</span><span class="si">{}</span><span class="s2">&#39; object has no attribute &#39;_header&#39;&quot;</span>
                                     <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">))</span>

            <span class="n">obj</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="s1">&#39;_header&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">hdr</span>
            <span class="k">return</span> <span class="n">hdr</span>

    <span class="k">def</span> <span class="fm">__set__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="n">obj</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="s1">&#39;_header&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>

    <span class="k">def</span> <span class="fm">__delete__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
        <span class="k">del</span> <span class="n">obj</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="s1">&#39;_header&#39;</span><span class="p">]</span>


<span class="k">class</span> <span class="nc">_BasicHeaderCards</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This class allows to access cards with the _BasicHeader.cards attribute.</span>

<span class="sd">    This is needed because during the HDU class detection, some HDUs uses</span>
<span class="sd">    the .cards interface.  Cards cannot be modified here as the _BasicHeader</span>
<span class="sd">    object will be deleted once the HDU object is created.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">header</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">header</span> <span class="o">=</span> <span class="n">header</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="c1"># .cards is a list of cards, so key here is an integer.</span>
        <span class="c1"># get the keyword name from its index.</span>
        <span class="n">key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">header</span><span class="o">.</span><span class="n">_keys</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="c1"># then we get the card from the _BasicHeader._cards list, or parse it</span>
        <span class="c1"># if needed.</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">header</span><span class="o">.</span><span class="n">_cards</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="n">cardstr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">header</span><span class="o">.</span><span class="n">_raw_cards</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
            <span class="n">card</span> <span class="o">=</span> <span class="n">Card</span><span class="o">.</span><span class="n">fromstring</span><span class="p">(</span><span class="n">cardstr</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">header</span><span class="o">.</span><span class="n">_cards</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">card</span>
            <span class="k">return</span> <span class="n">card</span>


<span class="k">class</span> <span class="nc">_BasicHeader</span><span class="p">(</span><span class="n">collections</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">Mapping</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;This class provides a fast header parsing, without all the additional</span>
<span class="sd">    features of the Header class. Here only standard keywords are parsed, no</span>
<span class="sd">    support for CONTINUE, HIERARCH, COMMENT, HISTORY, or rvkc.</span>

<span class="sd">    The raw card images are stored and parsed only if needed. The idea is that</span>
<span class="sd">    to create the HDU objects, only a small subset of standard cards is needed.</span>
<span class="sd">    Once a card is parsed, which is deferred to the Card class, the Card object</span>
<span class="sd">    is kept in a cache. This is useful because a small subset of cards is used</span>
<span class="sd">    a lot in the HDU creation process (NAXIS, XTENSION, ...).</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cards</span><span class="p">):</span>
        <span class="c1"># dict of (keywords, card images)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_raw_cards</span> <span class="o">=</span> <span class="n">cards</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_keys</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">cards</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="c1"># dict of (keyword, Card object) storing the parsed cards</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cards</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="c1"># the _BasicHeaderCards object allows to access Card objects from</span>
        <span class="c1"># keyword indices</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cards</span> <span class="o">=</span> <span class="n">_BasicHeaderCards</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_modified</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">numbers</span><span class="o">.</span><span class="n">Integral</span><span class="p">):</span>
            <span class="n">key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_keys</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cards</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">value</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="c1"># parse the Card and store it</span>
            <span class="n">cardstr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_raw_cards</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cards</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">card</span> <span class="o">=</span> <span class="n">Card</span><span class="o">.</span><span class="n">fromstring</span><span class="p">(</span><span class="n">cardstr</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">card</span><span class="o">.</span><span class="n">value</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_raw_cards</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_raw_cards</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">keyword</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_keys</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">keyword</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">data_size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the size (in bytes) of the data portion following the `Header`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_hdr_data_size</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">data_size_padded</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the size (in bytes) of the data portion following the `Header`</span>
<span class="sd">        including padding.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_size</span>
        <span class="k">return</span> <span class="n">size</span> <span class="o">+</span> <span class="n">_pad_length</span><span class="p">(</span><span class="n">size</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">fromfile</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">fileobj</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The main method to parse a FITS header from a file. The parsing is</span>
<span class="sd">        done with the parse_header function implemented in Cython.&quot;&quot;&quot;</span>

        <span class="n">close_file</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fileobj</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">fileobj</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">fileobj</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span>
            <span class="n">close_file</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">header_str</span><span class="p">,</span> <span class="n">cards</span> <span class="o">=</span> <span class="n">parse_header</span><span class="p">(</span><span class="n">fileobj</span><span class="p">)</span>
            <span class="n">_check_padding</span><span class="p">(</span><span class="n">header_str</span><span class="p">,</span> <span class="n">BLOCK_SIZE</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">header_str</span><span class="p">,</span> <span class="bp">cls</span><span class="p">(</span><span class="n">cards</span><span class="p">)</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">close_file</span><span class="p">:</span>
                <span class="n">fileobj</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>


<span class="k">class</span> <span class="nc">_CardAccessor</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This is a generic class for wrapping a Header in such a way that you can</span>
<span class="sd">    use the header&#39;s slice/filtering capabilities to return a subset of cards</span>
<span class="sd">    and do something with them.</span>

<span class="sd">    This is sort of the opposite notion of the old CardList class--whereas</span>
<span class="sd">    Header used to use CardList to get lists of cards, this uses Header to get</span>
<span class="sd">    lists of cards.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># TODO: Consider giving this dict/list methods like Header itself</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">header</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_header</span> <span class="o">=</span> <span class="n">header</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="o">.</span><span class="n">_cards</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="o">.</span><span class="n">_cards</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="o">.</span><span class="n">_cards</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="c1"># If the `other` item is a scalar we will still treat it as equal if</span>
        <span class="c1"># this _CardAccessor only contains one item</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">isiterable</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">other</span> <span class="o">=</span> <span class="p">[</span><span class="n">other</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>

        <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">zip_longest</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">a</span> <span class="o">!=</span> <span class="n">b</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="fm">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="p">(</span><span class="bp">self</span> <span class="o">==</span> <span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="nb">slice</span><span class="p">)</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="o">.</span><span class="n">_haswildcard</span><span class="p">(</span><span class="n">item</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">[</span><span class="n">item</span><span class="p">])</span>

        <span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="o">.</span><span class="n">_cardindex</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="o">.</span><span class="n">_cards</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_setslice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Helper for implementing __setitem__ on _CardAccessor subclasses; slices</span>
<span class="sd">        should always be handled in this same way.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="nb">slice</span><span class="p">)</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="o">.</span><span class="n">_haswildcard</span><span class="p">(</span><span class="n">item</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
                <span class="n">indices</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="o">*</span><span class="n">item</span><span class="o">.</span><span class="n">indices</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="o">.</span><span class="n">_wildcardmatch</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">isiterable</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">itertools</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
                <span class="bp">self</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="kc">False</span>


<span class="k">class</span> <span class="nc">_HeaderComments</span><span class="p">(</span><span class="n">_CardAccessor</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A class used internally by the Header class for the Header.comments</span>
<span class="sd">    attribute access.</span>

<span class="sd">    This object can be used to display all the keyword comments in the Header,</span>
<span class="sd">    or look up the comments on specific keywords.  It allows all the same forms</span>
<span class="sd">    of keyword lookup as the Header class itself, but returns comments instead</span>
<span class="sd">    of values.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">card</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="o">.</span><span class="n">_cards</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">card</span><span class="o">.</span><span class="n">comment</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a simple list of all keywords and their comments.&quot;&quot;&quot;</span>

        <span class="n">keyword_length</span> <span class="o">=</span> <span class="n">KEYWORD_LENGTH</span>
        <span class="k">for</span> <span class="n">card</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="o">.</span><span class="n">_cards</span><span class="p">:</span>
            <span class="n">keyword_length</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">keyword_length</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">card</span><span class="o">.</span><span class="n">keyword</span><span class="p">))</span>
        <span class="k">return</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s1">&#39;{:&gt;</span><span class="si">{len}</span><span class="s1">}  </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">keyword</span><span class="p">,</span> <span class="n">c</span><span class="o">.</span><span class="n">comment</span><span class="p">,</span>
                                                <span class="nb">len</span><span class="o">=</span><span class="n">keyword_length</span><span class="p">)</span>
                         <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="o">.</span><span class="n">_cards</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Slices and filter strings return a new _HeaderComments containing the</span>
<span class="sd">        returned cards.  Otherwise the comment of a single card is returned.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">item</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">_HeaderComments</span><span class="p">):</span>
            <span class="c1"># The item key was a slice</span>
            <span class="k">return</span> <span class="n">item</span>
        <span class="k">return</span> <span class="n">item</span><span class="o">.</span><span class="n">comment</span>

    <span class="k">def</span> <span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">,</span> <span class="n">comment</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set/update the comment on specified card or cards.</span>

<span class="sd">        Slice/filter updates work similarly to how Header.__setitem__ works.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="o">.</span><span class="n">_set_slice</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">comment</span><span class="p">,</span> <span class="bp">self</span><span class="p">):</span>
            <span class="k">return</span>

        <span class="c1"># In this case, key/index errors should be raised; don&#39;t update</span>
        <span class="c1"># comments of nonexistent cards</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="o">.</span><span class="n">_cardindex</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
        <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">comment</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">_HeaderCommentaryCards</span><span class="p">(</span><span class="n">_CardAccessor</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This is used to return a list-like sequence over all the values in the</span>
<span class="sd">    header for a given commentary keyword, such as HISTORY.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">header</span><span class="p">,</span> <span class="n">keyword</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">header</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_keyword</span> <span class="o">=</span> <span class="n">keyword</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_count</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_keyword</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_indices</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_count</span><span class="p">)</span><span class="o">.</span><span class="n">indices</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_count</span><span class="p">)</span>

    <span class="c1"># __len__ and __iter__ need to be overridden from the base class due to the</span>
    <span class="c1"># different approach this class has to take for slicing</span>
    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_indices</span><span class="p">))</span>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_indices</span><span class="p">):</span>
            <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">_keyword</span><span class="p">,</span> <span class="n">idx</span><span class="p">)]</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
            <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_keyword</span><span class="p">)</span>
            <span class="n">n</span><span class="o">.</span><span class="n">_indices</span> <span class="o">=</span> <span class="n">idx</span><span class="o">.</span><span class="n">indices</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_count</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">n</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">numbers</span><span class="o">.</span><span class="n">Integral</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_keyword</span><span class="si">}</span><span class="s1"> index must be an integer&#39;</span><span class="p">)</span>

        <span class="n">idx</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_indices</span><span class="p">))[</span><span class="n">idx</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">_keyword</span><span class="p">,</span> <span class="n">idx</span><span class="p">)]</span>

    <span class="k">def</span> <span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the value of a specified commentary card or cards.</span>

<span class="sd">        Slice/filter updates work similarly to how Header.__setitem__ works.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="o">.</span><span class="n">_set_slice</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="bp">self</span><span class="p">):</span>
            <span class="k">return</span>

        <span class="c1"># In this case, key/index errors should be raised; don&#39;t update</span>
        <span class="c1"># comments of nonexistent cards</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">_keyword</span><span class="p">,</span> <span class="n">item</span><span class="p">)]</span> <span class="o">=</span> <span class="n">value</span>


<span class="k">def</span> <span class="nf">_block_size</span><span class="p">(</span><span class="n">sep</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Determine the size of a FITS header block if a non-blank separator is used</span>
<span class="sd">    between cards.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="n">BLOCK_SIZE</span> <span class="o">+</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sep</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">BLOCK_SIZE</span> <span class="o">//</span> <span class="n">Card</span><span class="o">.</span><span class="n">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">_pad_length</span><span class="p">(</span><span class="n">stringlen</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Bytes needed to pad the input stringlen to the next FITS block.&quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="p">(</span><span class="n">BLOCK_SIZE</span> <span class="o">-</span> <span class="p">(</span><span class="n">stringlen</span> <span class="o">%</span> <span class="n">BLOCK_SIZE</span><span class="p">))</span> <span class="o">%</span> <span class="n">BLOCK_SIZE</span>


<span class="k">def</span> <span class="nf">_check_padding</span><span class="p">(</span><span class="n">header_str</span><span class="p">,</span> <span class="n">block_size</span><span class="p">,</span> <span class="n">is_eof</span><span class="p">,</span> <span class="n">check_block_size</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="c1"># Strip any zero-padding (see ticket #106)</span>
    <span class="k">if</span> <span class="n">header_str</span> <span class="ow">and</span> <span class="n">header_str</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;</span><span class="se">\0</span><span class="s1">&#39;</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">is_eof</span> <span class="ow">and</span> <span class="n">header_str</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\0</span><span class="s1">&#39;</span><span class="p">)</span> <span class="o">==</span> <span class="s1">&#39;&#39;</span><span class="p">:</span>
            <span class="c1"># TODO: Pass this warning to validation framework</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s1">&#39;Unexpected extra padding at the end of the file.  This &#39;</span>
                <span class="s1">&#39;padding may not be preserved when saving changes.&#39;</span><span class="p">,</span>
                <span class="n">AstropyUserWarning</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">EOFError</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Replace the illegal null bytes with spaces as required by</span>
            <span class="c1"># the FITS standard, and issue a nasty warning</span>
            <span class="c1"># TODO: Pass this warning to validation framework</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s1">&#39;Header block contains null bytes instead of spaces for &#39;</span>
                <span class="s1">&#39;padding, and is not FITS-compliant. Nulls may be &#39;</span>
                <span class="s1">&#39;replaced with spaces upon writing.&#39;</span><span class="p">,</span> <span class="n">AstropyUserWarning</span><span class="p">)</span>
            <span class="n">header_str</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\0</span><span class="s1">&#39;</span><span class="p">,</span> <span class="s1">&#39; &#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">check_block_size</span> <span class="ow">and</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">header_str</span><span class="p">)</span> <span class="o">%</span> <span class="n">block_size</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># This error message ignores the length of the separator for</span>
        <span class="c1"># now, but maybe it shouldn&#39;t?</span>
        <span class="n">actual_len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">header_str</span><span class="p">)</span> <span class="o">-</span> <span class="n">block_size</span> <span class="o">+</span> <span class="n">BLOCK_SIZE</span>
        <span class="c1"># TODO: Pass this error to validation framework</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Header size is not multiple of </span><span class="si">{</span><span class="n">BLOCK_SIZE</span><span class="si">}</span><span class="s1">: </span><span class="si">{</span><span class="n">actual_len</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_hdr_data_size</span><span class="p">(</span><span class="n">header</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Calculate the data size (in bytes) following the given `Header`&quot;&quot;&quot;</span>
    <span class="n">size</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">naxis</span> <span class="o">=</span> <span class="n">header</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;NAXIS&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">naxis</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">size</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">naxis</span><span class="p">):</span>
            <span class="n">size</span> <span class="o">=</span> <span class="n">size</span> <span class="o">*</span> <span class="n">header</span><span class="p">[</span><span class="s1">&#39;NAXIS&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>
        <span class="n">bitpix</span> <span class="o">=</span> <span class="n">header</span><span class="p">[</span><span class="s1">&#39;BITPIX&#39;</span><span class="p">]</span>
        <span class="n">gcount</span> <span class="o">=</span> <span class="n">header</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;GCOUNT&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">pcount</span> <span class="o">=</span> <span class="n">header</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;PCOUNT&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">size</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">bitpix</span><span class="p">)</span> <span class="o">*</span> <span class="n">gcount</span> <span class="o">*</span> <span class="p">(</span><span class="n">pcount</span> <span class="o">+</span> <span class="n">size</span><span class="p">)</span> <span class="o">//</span> <span class="mi">8</span>
    <span class="k">return</span> <span class="n">size</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2024, R. Laugier.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>