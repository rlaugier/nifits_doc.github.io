<!doctype html>
<html class="no-js" lang="en" data-content_root="../../../">
  <head><meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <meta name="color-scheme" content="light dark"><link rel="index" title="Index" href="../../../genindex.html" /><link rel="search" title="Search" href="../../../search.html" />

    <!-- Generated with Sphinx 7.3.7 and Furo 2024.08.06 -->
        <title>astropy.table.table - NIFITS 0.0.3 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=362ab14a" />
    <link rel="stylesheet" type="text/css" href="../../../_static/styles/furo.css?v=354aac6f" />
    <link rel="stylesheet" type="text/css" href="../../../_static/graphviz.css?v=fd3f3429" />
    <link rel="stylesheet" type="text/css" href="../../../_static/design-style.1e8bd061cd6da7fc9cf755528e8ffc24.min.css?v=0a3b3ea7" />
    <link rel="stylesheet" type="text/css" href="../../../_static/styles/furo-extensions.css?v=302659d7" />
    
    


<style>
  body {
    --color-code-background: #f8f8f8;
  --color-code-foreground: black;
  
  }
  @media not print {
    body[data-theme="dark"] {
      --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
    }
    @media (prefers-color-scheme: dark) {
      body:not([data-theme="light"]) {
        --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
      }
    }
  }
</style></head>
  <body>
    
    <script>
      document.body.dataset.theme = localStorage.getItem("theme") || "auto";
    </script>
    

<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-toc" viewBox="0 0 24 24">
    <title>Contents</title>
    <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 1024 1024">
      <path d="M408 442h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8zm-8 204c0 4.4 3.6 8 8 8h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56zm504-486H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 632H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM115.4 518.9L271.7 642c5.8 4.6 14.4.5 14.4-6.9V388.9c0-7.4-8.5-11.5-14.4-6.9L115.4 505.1a8.74 8.74 0 0 0 0 13.8z"/>
    </svg>
  </symbol>
  <symbol id="svg-menu" viewBox="0 0 24 24">
    <title>Menu</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-menu">
      <line x1="3" y1="12" x2="21" y2="12"></line>
      <line x1="3" y1="6" x2="21" y2="6"></line>
      <line x1="3" y1="18" x2="21" y2="18"></line>
    </svg>
  </symbol>
  <symbol id="svg-arrow-right" viewBox="0 0 24 24">
    <title>Expand</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-chevron-right">
      <polyline points="9 18 15 12 9 6"></polyline>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24">
    <title>Light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="feather-sun">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24">
    <title>Dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-moon">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z" />
    </svg>
  </symbol>
  <symbol id="svg-sun-with-moon" viewBox="0 0 24 24">
    <title>Auto light/dark, in light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round"
      class="icon-custom-derived-from-feather-sun-and-tabler-moon">
      <path style="opacity: 50%" d="M 5.411 14.504 C 5.471 14.504 5.532 14.504 5.591 14.504 C 3.639 16.319 4.383 19.569 6.931 20.352 C 7.693 20.586 8.512 20.551 9.25 20.252 C 8.023 23.207 4.056 23.725 2.11 21.184 C 0.166 18.642 1.702 14.949 4.874 14.536 C 5.051 14.512 5.231 14.5 5.411 14.5 L 5.411 14.504 Z"/>
      <line x1="14.5" y1="3.25" x2="14.5" y2="1.25"/>
      <line x1="14.5" y1="15.85" x2="14.5" y2="17.85"/>
      <line x1="10.044" y1="5.094" x2="8.63" y2="3.68"/>
      <line x1="19" y1="14.05" x2="20.414" y2="15.464"/>
      <line x1="8.2" y1="9.55" x2="6.2" y2="9.55"/>
      <line x1="20.8" y1="9.55" x2="22.8" y2="9.55"/>
      <line x1="10.044" y1="14.006" x2="8.63" y2="15.42"/>
      <line x1="19" y1="5.05" x2="20.414" y2="3.636"/>
      <circle cx="14.5" cy="9.55" r="3.6"/>
    </svg>
  </symbol>
  <symbol id="svg-moon-with-sun" viewBox="0 0 24 24">
    <title>Auto light/dark, in dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round"
      class="icon-custom-derived-from-feather-sun-and-tabler-moon">
      <path d="M 8.282 7.007 C 8.385 7.007 8.494 7.007 8.595 7.007 C 5.18 10.184 6.481 15.869 10.942 17.24 C 12.275 17.648 13.706 17.589 15 17.066 C 12.851 22.236 5.91 23.143 2.505 18.696 C -0.897 14.249 1.791 7.786 7.342 7.063 C 7.652 7.021 7.965 7 8.282 7 L 8.282 7.007 Z"/>
      <line style="opacity: 50%" x1="18" y1="3.705" x2="18" y2="2.5"/>
      <line style="opacity: 50%" x1="18" y1="11.295" x2="18" y2="12.5"/>
      <line style="opacity: 50%" x1="15.316" y1="4.816" x2="14.464" y2="3.964"/>
      <line style="opacity: 50%" x1="20.711" y1="10.212" x2="21.563" y2="11.063"/>
      <line style="opacity: 50%" x1="14.205" y1="7.5" x2="13.001" y2="7.5"/>
      <line style="opacity: 50%" x1="21.795" y1="7.5" x2="23" y2="7.5"/>
      <line style="opacity: 50%" x1="15.316" y1="10.184" x2="14.464" y2="11.036"/>
      <line style="opacity: 50%" x1="20.711" y1="4.789" x2="21.563" y2="3.937"/>
      <circle style="opacity: 50%" cx="18" cy="7.5" r="2.169"/>
    </svg>
  </symbol>
  <symbol id="svg-pencil" viewBox="0 0 24 24">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-pencil-code">
      <path d="M4 20h4l10.5 -10.5a2.828 2.828 0 1 0 -4 -4l-10.5 10.5v4" />
      <path d="M13.5 6.5l4 4" />
      <path d="M20 21l2 -2l-2 -2" />
      <path d="M17 17l-2 2l2 2" />
    </svg>
  </symbol>
  <symbol id="svg-eye" viewBox="0 0 24 24">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-eye-code">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M10 12a2 2 0 1 0 4 0a2 2 0 0 0 -4 0" />
      <path
        d="M11.11 17.958c-3.209 -.307 -5.91 -2.293 -8.11 -5.958c2.4 -4 5.4 -6 9 -6c3.6 0 6.6 2 9 6c-.21 .352 -.427 .688 -.647 1.008" />
      <path d="M20 21l2 -2l-2 -2" />
      <path d="M17 17l-2 2l2 2" />
    </svg>
  </symbol>
</svg>

<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation">
<input type="checkbox" class="sidebar-toggle" name="__toc" id="__toc">
<label class="overlay sidebar-overlay" for="__navigation">
  <div class="visually-hidden">Hide navigation sidebar</div>
</label>
<label class="overlay toc-overlay" for="__toc">
  <div class="visually-hidden">Hide table of contents sidebar</div>
</label>

<a class="skip-to-content muted-link" href="#furo-main-content">Skip to content</a>



<div class="page">
  <header class="mobile-header">
    <div class="header-left">
      <label class="nav-overlay-icon" for="__navigation">
        <div class="visually-hidden">Toggle site navigation sidebar</div>
        <i class="icon"><svg><use href="#svg-menu"></use></svg></i>
      </label>
    </div>
    <div class="header-center">
      <a href="../../../index.html"><div class="brand">NIFITS 0.0.3 documentation</div></a>
    </div>
    <div class="header-right">
      <div class="theme-toggle-container theme-toggle-header">
        <button class="theme-toggle">
          <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
          <svg class="theme-icon-when-auto-light"><use href="#svg-sun-with-moon"></use></svg>
          <svg class="theme-icon-when-auto-dark"><use href="#svg-moon-with-sun"></use></svg>
          <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
          <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
        </button>
      </div>
      <label class="toc-overlay-icon toc-header-icon no-toc" for="__toc">
        <div class="visually-hidden">Toggle table of contents sidebar</div>
        <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
      </label>
    </div>
  </header>
  <aside class="sidebar-drawer">
    <div class="sidebar-container">
      
      <div class="sidebar-sticky"><a class="sidebar-brand" href="../../../index.html">
  
  
  <span class="sidebar-brand-text">NIFITS 0.0.3 documentation</span>
  
</a><form class="sidebar-search-container" method="get" action="../../../search.html" role="search">
  <input class="sidebar-search" placeholder="Search" name="q" aria-label="Search">
  <input type="hidden" name="check_keywords" value="yes">
  <input type="hidden" name="area" value="default">
</form>
<div id="searchbox"></div><div class="sidebar-scroll"><div class="sidebar-tree">
  <ul>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../../autoapi/index.html">API Reference</a><input class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" role="switch" type="checkbox"/><label for="toctree-checkbox-1"><div class="visually-hidden">Toggle navigation of API Reference</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2 has-children"><a class="reference internal" href="../../../autoapi/nifits/index.html">nifits</a><input class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" role="switch" type="checkbox"/><label for="toctree-checkbox-2"><div class="visually-hidden">Toggle navigation of nifits</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l3 has-children"><a class="reference internal" href="../../../autoapi/nifits/backend/index.html">nifits.backend</a><input class="toctree-checkbox" id="toctree-checkbox-3" name="toctree-checkbox-3" role="switch" type="checkbox"/><label for="toctree-checkbox-3"><div class="visually-hidden">Toggle navigation of nifits.backend</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../autoapi/nifits/backend/backend/index.html">nifits.backend.backend</a></li>
</ul>
</li>
<li class="toctree-l3 has-children"><a class="reference internal" href="../../../autoapi/nifits/io/index.html">nifits.io</a><input class="toctree-checkbox" id="toctree-checkbox-4" name="toctree-checkbox-4" role="switch" type="checkbox"/><label for="toctree-checkbox-4"><div class="visually-hidden">Toggle navigation of nifits.io</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../autoapi/nifits/io/oifits/index.html">nifits.io.oifits</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

</div>
</div>

      </div>
      
    </div>
  </aside>
  <div class="main">
    <div class="content">
      <div class="article-container">
        <a href="#" class="back-to-top muted-link">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12z"></path>
          </svg>
          <span>Back to top</span>
        </a>
        <div class="content-icon-container">
          <div class="theme-toggle-container theme-toggle-content">
            <button class="theme-toggle">
              <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
              <svg class="theme-icon-when-auto-light"><use href="#svg-sun-with-moon"></use></svg>
              <svg class="theme-icon-when-auto-dark"><use href="#svg-moon-with-sun"></use></svg>
              <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
              <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
            </button>
          </div>
          <label class="toc-overlay-icon toc-content-icon no-toc" for="__toc">
            <div class="visually-hidden">Toggle table of contents sidebar</div>
            <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
          </label>
        </div>
        <article role="main" id="furo-main-content">
          <h1>Source code for astropy.table.table</h1><div class="highlight"><pre>
<span></span><span class="c1"># Licensed under a 3-clause BSD style license - see LICENSE.rst</span>
<span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">types</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">import</span> <span class="nn">weakref</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">OrderedDict</span><span class="p">,</span> <span class="n">defaultdict</span>
<span class="kn">from</span> <span class="nn">collections.abc</span> <span class="kn">import</span> <span class="n">Mapping</span>
<span class="kn">from</span> <span class="nn">copy</span> <span class="kn">import</span> <span class="n">deepcopy</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">ma</span>

<span class="kn">from</span> <span class="nn">astropy</span> <span class="kn">import</span> <span class="n">log</span>
<span class="kn">from</span> <span class="nn">astropy.io.registry</span> <span class="kn">import</span> <span class="n">UnifiedReadWriteMethod</span>
<span class="kn">from</span> <span class="nn">astropy.units</span> <span class="kn">import</span> <span class="n">Quantity</span><span class="p">,</span> <span class="n">QuantityInfo</span>
<span class="kn">from</span> <span class="nn">astropy.utils</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">ShapedLikeNDArray</span><span class="p">,</span>
    <span class="n">deprecated</span><span class="p">,</span>
    <span class="n">isiterable</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">astropy.utils.compat</span> <span class="kn">import</span> <span class="n">COPY_IF_NEEDED</span><span class="p">,</span> <span class="n">NUMPY_LT_1_25</span>
<span class="kn">from</span> <span class="nn">astropy.utils.console</span> <span class="kn">import</span> <span class="n">color_print</span>
<span class="kn">from</span> <span class="nn">astropy.utils.data_info</span> <span class="kn">import</span> <span class="n">BaseColumnInfo</span><span class="p">,</span> <span class="n">DataInfo</span><span class="p">,</span> <span class="n">MixinInfo</span>
<span class="kn">from</span> <span class="nn">astropy.utils.decorators</span> <span class="kn">import</span> <span class="n">format_doc</span>
<span class="kn">from</span> <span class="nn">astropy.utils.exceptions</span> <span class="kn">import</span> <span class="n">AstropyUserWarning</span>
<span class="kn">from</span> <span class="nn">astropy.utils.masked</span> <span class="kn">import</span> <span class="n">Masked</span>
<span class="kn">from</span> <span class="nn">astropy.utils.metadata</span> <span class="kn">import</span> <span class="n">MetaAttribute</span><span class="p">,</span> <span class="n">MetaData</span>

<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">conf</span><span class="p">,</span> <span class="n">groups</span>
<span class="kn">from</span> <span class="nn">.column</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">BaseColumn</span><span class="p">,</span>
    <span class="n">Column</span><span class="p">,</span>
    <span class="n">FalseArray</span><span class="p">,</span>
    <span class="n">MaskedColumn</span><span class="p">,</span>
    <span class="n">_auto_names</span><span class="p">,</span>
    <span class="n">_convert_sequence_data_to_array</span><span class="p">,</span>
    <span class="n">col_copy</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">.connect</span> <span class="kn">import</span> <span class="n">TableRead</span><span class="p">,</span> <span class="n">TableWrite</span>
<span class="kn">from</span> <span class="nn">.index</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">Index</span><span class="p">,</span>
    <span class="n">SlicedIndex</span><span class="p">,</span>
    <span class="n">TableILoc</span><span class="p">,</span>
    <span class="n">TableIndices</span><span class="p">,</span>
    <span class="n">TableLoc</span><span class="p">,</span>
    <span class="n">TableLocIndices</span><span class="p">,</span>
    <span class="n">_IndexModeContext</span><span class="p">,</span>
    <span class="n">get_index</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">.info</span> <span class="kn">import</span> <span class="n">TableInfo</span>
<span class="kn">from</span> <span class="nn">.mixins.registry</span> <span class="kn">import</span> <span class="n">get_mixin_handler</span>
<span class="kn">from</span> <span class="nn">.ndarray_mixin</span> <span class="kn">import</span> <span class="n">NdarrayMixin</span>  <span class="c1"># noqa: F401</span>
<span class="kn">from</span> <span class="nn">.pprint</span> <span class="kn">import</span> <span class="n">TableFormatter</span>
<span class="kn">from</span> <span class="nn">.row</span> <span class="kn">import</span> <span class="n">Row</span>

<span class="n">_implementation_notes</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">This string has informal notes concerning Table implementation for developers.</span>

<span class="s2">Things to remember:</span>

<span class="s2">- Table has customizable attributes ColumnClass, Column, MaskedColumn.</span>
<span class="s2">  Table.Column is normally just column.Column (same w/ MaskedColumn)</span>
<span class="s2">  but in theory they can be different.  Table.ColumnClass is the default</span>
<span class="s2">  class used to create new non-mixin columns, and this is a function of</span>
<span class="s2">  the Table.masked attribute.  Column creation / manipulation in a Table</span>
<span class="s2">  needs to respect these.</span>

<span class="s2">- Column objects that get inserted into the Table.columns attribute must</span>
<span class="s2">  have the info.parent_table attribute set correctly.  Beware just dropping</span>
<span class="s2">  an object into the columns dict since an existing column may</span>
<span class="s2">  be part of another Table and have parent_table set to point at that</span>
<span class="s2">  table.  Dropping that column into `columns` of this Table will cause</span>
<span class="s2">  a problem for the old one so the column object needs to be copied (but</span>
<span class="s2">  not necessarily the data).</span>

<span class="s2">  Currently replace_column is always making a copy of both object and</span>
<span class="s2">  data if parent_table is set.  This could be improved but requires a</span>
<span class="s2">  generic way to copy a mixin object but not the data.</span>

<span class="s2">- Be aware of column objects that have indices set.</span>

<span class="s2">- `cls.ColumnClass` is a property that effectively uses the `masked` attribute</span>
<span class="s2">  to choose either `cls.Column` or `cls.MaskedColumn`.</span>
<span class="s2">&quot;&quot;&quot;</span>

<span class="n">__doctest_skip__</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s2">&quot;Table.read&quot;</span><span class="p">,</span>
    <span class="s2">&quot;Table.write&quot;</span><span class="p">,</span>
    <span class="s2">&quot;Table._read&quot;</span><span class="p">,</span>
    <span class="s2">&quot;Table.convert_bytestring_to_unicode&quot;</span><span class="p">,</span>
    <span class="s2">&quot;Table.convert_unicode_to_bytestring&quot;</span><span class="p">,</span>
<span class="p">]</span>

<span class="n">__doctest_requires__</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;*pandas&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;pandas&gt;=1.1&quot;</span><span class="p">]}</span>

<span class="n">_pprint_docs</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">    </span><span class="si">{__doc__}</span>

<span class="s2">    Parameters</span>
<span class="s2">    ----------</span>
<span class="s2">    max_lines : int or None</span>
<span class="s2">        Maximum number of lines in table output.</span>

<span class="s2">    max_width : int or None</span>
<span class="s2">        Maximum character width of output.</span>

<span class="s2">    show_name : bool</span>
<span class="s2">        Include a header row for column names. Default is True.</span>

<span class="s2">    show_unit : bool</span>
<span class="s2">        Include a header row for unit.  Default is to show a row</span>
<span class="s2">        for units only if one or more columns has a defined value</span>
<span class="s2">        for the unit.</span>

<span class="s2">    show_dtype : bool</span>
<span class="s2">        Include a header row for column dtypes. Default is False.</span>

<span class="s2">    align : str or list or tuple or None</span>
<span class="s2">        Left/right alignment of columns. Default is right (None) for all</span>
<span class="s2">        columns. Other allowed values are &#39;&gt;&#39;, &#39;&lt;&#39;, &#39;^&#39;, and &#39;0=&#39; for</span>
<span class="s2">        right, left, centered, and 0-padded, respectively. A list of</span>
<span class="s2">        strings can be provided for alignment of tables with multiple</span>
<span class="s2">        columns.</span>
<span class="s2">    &quot;&quot;&quot;</span>

<span class="n">_pformat_docs</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">    </span><span class="si">{__doc__}</span>

<span class="s2">    Parameters</span>
<span class="s2">    ----------</span>
<span class="s2">    max_lines : int or None</span>
<span class="s2">        Maximum number of rows to output</span>

<span class="s2">    max_width : int or None</span>
<span class="s2">        Maximum character width of output</span>

<span class="s2">    show_name : bool</span>
<span class="s2">        Include a header row for column names. Default is True.</span>

<span class="s2">    show_unit : bool</span>
<span class="s2">        Include a header row for unit.  Default is to show a row</span>
<span class="s2">        for units only if one or more columns has a defined value</span>
<span class="s2">        for the unit.</span>

<span class="s2">    show_dtype : bool</span>
<span class="s2">        Include a header row for column dtypes. Default is True.</span>

<span class="s2">    html : bool</span>
<span class="s2">        Format the output as an HTML table. Default is False.</span>

<span class="s2">    tableid : str or None</span>
<span class="s2">        An ID tag for the table; only used if html is set.  Default is</span>
<span class="s2">        &quot;table</span><span class="si">{id}</span><span class="s2">&quot;, where id is the unique integer id of the table object,</span>
<span class="s2">        id(self)</span>

<span class="s2">    align : str or list or tuple or None</span>
<span class="s2">        Left/right alignment of columns. Default is right (None) for all</span>
<span class="s2">        columns. Other allowed values are &#39;&gt;&#39;, &#39;&lt;&#39;, &#39;^&#39;, and &#39;0=&#39; for</span>
<span class="s2">        right, left, centered, and 0-padded, respectively. A list of</span>
<span class="s2">        strings can be provided for alignment of tables with multiple</span>
<span class="s2">        columns.</span>

<span class="s2">    tableclass : str or list of str or None</span>
<span class="s2">        CSS classes for the table; only used if html is set.  Default is</span>
<span class="s2">        None.</span>

<span class="s2">    Returns</span>
<span class="s2">    -------</span>
<span class="s2">    lines : list</span>
<span class="s2">        Formatted table as a list of strings.</span>
<span class="s2">    &quot;&quot;&quot;</span>


<span class="k">class</span> <span class="nc">TableReplaceWarning</span><span class="p">(</span><span class="ne">UserWarning</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Warning class for cases when a table column is replaced via the</span>
<span class="sd">    Table.__setitem__ syntax e.g. t[&#39;a&#39;] = val.</span>

<span class="sd">    This does not inherit from AstropyWarning because we want to use</span>
<span class="sd">    stacklevel=3 to show the user where the issue occurred in their code.</span>
<span class="sd">    &quot;&quot;&quot;</span>


<span class="k">def</span> <span class="nf">descr</span><span class="p">(</span><span class="n">col</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Array-interface compliant full description of a column.</span>

<span class="sd">    This returns a 3-tuple (name, type, shape) that can always be</span>
<span class="sd">    used in a structured array dtype definition.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">col_dtype</span> <span class="o">=</span> <span class="s2">&quot;O&quot;</span> <span class="k">if</span> <span class="p">(</span><span class="n">col</span><span class="o">.</span><span class="n">info</span><span class="o">.</span><span class="n">dtype</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="k">else</span> <span class="n">col</span><span class="o">.</span><span class="n">info</span><span class="o">.</span><span class="n">dtype</span>
    <span class="n">col_shape</span> <span class="o">=</span> <span class="n">col</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="s2">&quot;shape&quot;</span><span class="p">)</span> <span class="k">else</span> <span class="p">()</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">col</span><span class="o">.</span><span class="n">info</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">col_dtype</span><span class="p">,</span> <span class="n">col_shape</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">has_info_class</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="bp">cls</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Check if the object&#39;s info is an instance of cls.&quot;&quot;&quot;</span>
    <span class="c1"># We check info on the class of the instance, since on the instance</span>
    <span class="c1"># itself accessing &#39;info&#39; has side effects in that it sets</span>
    <span class="c1"># obj.__dict__[&#39;info&#39;] if it does not exist already.</span>
    <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span> <span class="s2">&quot;info&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span> <span class="bp">cls</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_get_names_from_list_of_dict</span><span class="p">(</span><span class="n">rows</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return list of column names if ``rows`` is a list of dict that</span>
<span class="sd">    defines table data.</span>

<span class="sd">    If rows is not a list of dict then return None.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">rows</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="n">names</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">rows</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">Mapping</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="n">names</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">row</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">names</span><span class="p">)</span>


<span class="c1"># Note to future maintainers: when transitioning this to dict</span>
<span class="c1"># be sure to change the OrderedDict ref(s) in Row and in __len__().</span>


<span class="k">class</span> <span class="nc">TableColumns</span><span class="p">(</span><span class="n">OrderedDict</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;OrderedDict subclass for a set of columns.</span>

<span class="sd">    This class enhances item access to provide convenient access to columns</span>
<span class="sd">    by name or index, including slice access.  It also handles renaming</span>
<span class="sd">    of columns.</span>

<span class="sd">    The initialization argument ``cols`` can be a list of ``Column`` objects</span>
<span class="sd">    or any structure that is valid for initializing a Python dict.  This</span>
<span class="sd">    includes a dict, list of (key, val) tuples or [key, val] lists, etc.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    cols : dict, list, tuple; optional</span>
<span class="sd">        Column objects as data structure that can init dict (see above)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cols</span><span class="o">=</span><span class="p">{}):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cols</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
            <span class="c1"># `cols` should be a list of two-tuples, but it is allowed to have</span>
            <span class="c1"># columns (BaseColumn or mixins) in the list.</span>
            <span class="n">newcols</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">cols</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">has_info_class</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">BaseColumnInfo</span><span class="p">):</span>
                    <span class="n">newcols</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">col</span><span class="o">.</span><span class="n">info</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">col</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">newcols</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">col</span><span class="p">)</span>
            <span class="n">cols</span> <span class="o">=</span> <span class="n">newcols</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">cols</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get items from a TableColumns object.</span>

<span class="sd">        ::</span>

<span class="sd">          tc = TableColumns(cols=[Column(name=&#39;a&#39;), Column(name=&#39;b&#39;), Column(name=&#39;c&#39;)])</span>
<span class="sd">          tc[&#39;a&#39;]  # Column(&#39;a&#39;)</span>
<span class="sd">          tc[1] # Column(&#39;b&#39;)</span>
<span class="sd">          tc[&#39;a&#39;, &#39;b&#39;] # &lt;TableColumns names=(&#39;a&#39;, &#39;b&#39;)&gt;</span>
<span class="sd">          tc[1:3] # &lt;TableColumns names=(&#39;b&#39;, &#39;c&#39;)&gt;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">OrderedDict</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">)):</span>
            <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">())[</span><span class="n">item</span><span class="p">]</span>
        <span class="k">elif</span> <span class="p">(</span>
            <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">and</span> <span class="n">item</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">()</span> <span class="ow">and</span> <span class="n">item</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s2">&quot;i&quot;</span>
        <span class="p">):</span>
            <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">())[</span><span class="n">item</span><span class="o">.</span><span class="n">item</span><span class="p">()]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">([</span><span class="bp">self</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">item</span><span class="p">])</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">([</span><span class="bp">self</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="p">)[</span><span class="n">item</span><span class="p">]])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Illegal key or index value for </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> object&quot;</span>
            <span class="p">)</span>

    <span class="k">def</span> <span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">validated</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set item in this dict instance, but do not allow directly replacing an</span>
<span class="sd">        existing column unless it is already validated (and thus is certain to</span>
<span class="sd">        not corrupt the table).</span>

<span class="sd">        NOTE: it is easily possible to corrupt a table by directly *adding* a new</span>
<span class="sd">        key to the TableColumns attribute of a Table, e.g.</span>
<span class="sd">        ``t.columns[&#39;jane&#39;] = &#39;doe&#39;``.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">item</span> <span class="ow">in</span> <span class="bp">self</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">validated</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Cannot replace column &#39;</span><span class="si">{</span><span class="n">item</span><span class="si">}</span><span class="s2">&#39;.  Use Table.replace_column() instead.&quot;</span>
            <span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__setitem__</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">names</span> <span class="o">=</span> <span class="p">(</span><span class="sa">f</span><span class="s2">&quot;&#39;</span><span class="si">{</span><span class="n">x</span><span class="si">}</span><span class="s2">&#39;&quot;</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;&lt;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> names=(</span><span class="si">{</span><span class="s1">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">names</span><span class="p">)</span><span class="si">}</span><span class="s2">)&gt;&quot;</span>

    <span class="k">def</span> <span class="nf">_rename_column</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">new_name</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="n">new_name</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="k">if</span> <span class="n">new_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Column </span><span class="si">{</span><span class="n">new_name</span><span class="si">}</span><span class="s2"> already exists&quot;</span><span class="p">)</span>

        <span class="c1"># Rename column names in pprint include/exclude attributes as needed</span>
        <span class="n">parent_table</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">info</span><span class="o">.</span><span class="n">parent_table</span>
        <span class="k">if</span> <span class="n">parent_table</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">parent_table</span><span class="o">.</span><span class="n">pprint_exclude_names</span><span class="o">.</span><span class="n">_rename</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">new_name</span><span class="p">)</span>
            <span class="n">parent_table</span><span class="o">.</span><span class="n">pprint_include_names</span><span class="o">.</span><span class="n">_rename</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">new_name</span><span class="p">)</span>

        <span class="n">mapper</span> <span class="o">=</span> <span class="p">{</span><span class="n">name</span><span class="p">:</span> <span class="n">new_name</span><span class="p">}</span>
        <span class="n">new_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">mapper</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">]</span>
        <span class="n">cols</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">new_names</span><span class="p">,</span> <span class="n">cols</span><span class="p">))</span>

    <span class="k">def</span> <span class="fm">__delitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="c1"># Remove column names from pprint include/exclude attributes as needed.</span>
        <span class="c1"># __delitem__ also gets called for pop() and popitem().</span>
        <span class="n">parent_table</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">info</span><span class="o">.</span><span class="n">parent_table</span>
        <span class="k">if</span> <span class="n">parent_table</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># _remove() method does not require that `name` is in the attribute</span>
            <span class="n">parent_table</span><span class="o">.</span><span class="n">pprint_exclude_names</span><span class="o">.</span><span class="n">_remove</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
            <span class="n">parent_table</span><span class="o">.</span><span class="n">pprint_include_names</span><span class="o">.</span><span class="n">_remove</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__delitem__</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">cls</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a list of columns which are instances of the specified classes.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        cls : class or tuple thereof</span>
<span class="sd">            Column class (including mixin) or tuple of Column classes.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        col_list : list of `Column`</span>
<span class="sd">            List of Column objects which are instances of given classes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cols</span> <span class="o">=</span> <span class="p">[</span><span class="n">col</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">()</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="bp">cls</span><span class="p">)]</span>
        <span class="k">return</span> <span class="n">cols</span>

    <span class="k">def</span> <span class="nf">not_isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">cls</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a list of columns which are not instances of the specified classes.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        cls : class or tuple thereof</span>
<span class="sd">            Column class (including mixin) or tuple of Column classes.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        col_list : list of `Column`</span>
<span class="sd">            List of Column objects which are not instances of given classes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cols</span> <span class="o">=</span> <span class="p">[</span><span class="n">col</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">()</span> <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="bp">cls</span><span class="p">)]</span>
        <span class="k">return</span> <span class="n">cols</span>

    <span class="c1"># When the deprecation period of setdefault() and update() is over then they</span>
    <span class="c1"># need to be rewritten to raise an error, not removed.</span>

    <span class="nd">@deprecated</span><span class="p">(</span>
        <span class="n">since</span><span class="o">=</span><span class="s2">&quot;6.1&quot;</span><span class="p">,</span> <span class="n">alternative</span><span class="o">=</span><span class="s2">&quot;t.setdefault()&quot;</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;t.columns.setdefault()&quot;</span>
    <span class="p">)</span>
    <span class="k">def</span> <span class="nf">setdefault</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">default</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">default</span><span class="p">)</span>

    <span class="nd">@deprecated</span><span class="p">(</span><span class="n">since</span><span class="o">=</span><span class="s2">&quot;6.1&quot;</span><span class="p">,</span> <span class="n">alternative</span><span class="o">=</span><span class="s2">&quot;t.update()&quot;</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;t.columns.update()&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">TableAttribute</span><span class="p">(</span><span class="n">MetaAttribute</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Descriptor to define a custom attribute for a Table subclass.</span>

<span class="sd">    The value of the ``TableAttribute`` will be stored in a dict named</span>
<span class="sd">    ``__attributes__`` that is stored in the table ``meta``.  The attribute</span>
<span class="sd">    can be accessed and set in the usual way, and it can be provided when</span>
<span class="sd">    creating the object.</span>

<span class="sd">    Defining an attribute by this mechanism ensures that it will persist if</span>
<span class="sd">    the table is sliced or serialized, for example as a pickle or ECSV file.</span>

<span class="sd">    See the `~astropy.utils.metadata.MetaAttribute` documentation for additional</span>
<span class="sd">    details.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    default : object</span>
<span class="sd">        Default value for attribute</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">      &gt;&gt;&gt; from astropy.table import Table, TableAttribute</span>
<span class="sd">      &gt;&gt;&gt; class MyTable(Table):</span>
<span class="sd">      ...     identifier = TableAttribute(default=1)</span>
<span class="sd">      &gt;&gt;&gt; t = MyTable(identifier=10)</span>
<span class="sd">      &gt;&gt;&gt; t.identifier</span>
<span class="sd">      10</span>
<span class="sd">      &gt;&gt;&gt; t.meta</span>
<span class="sd">      OrderedDict([(&#39;__attributes__&#39;, {&#39;identifier&#39;: 10})])</span>
<span class="sd">    &quot;&quot;&quot;</span>


<span class="k">class</span> <span class="nc">PprintIncludeExclude</span><span class="p">(</span><span class="n">TableAttribute</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Maintain tuple that controls table column visibility for print output.</span>

<span class="sd">    This is a descriptor that inherits from MetaAttribute so that the attribute</span>
<span class="sd">    value is stored in the table meta[&#39;__attributes__&#39;].</span>

<span class="sd">    This gets used for the ``pprint_include_names`` and ``pprint_exclude_names`` Table</span>
<span class="sd">    attributes.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__get__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instance</span><span class="p">,</span> <span class="n">owner_cls</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get the attribute.</span>

<span class="sd">        This normally returns an instance of this class which is stored on the</span>
<span class="sd">        owner object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># For getting from class not an instance</span>
        <span class="k">if</span> <span class="n">instance</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>

        <span class="c1"># If not already stored on `instance`, make a copy of the class</span>
        <span class="c1"># descriptor object and put it onto the instance.</span>
        <span class="n">value</span> <span class="o">=</span> <span class="n">instance</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="n">instance</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

        <span class="c1"># We set _instance_ref on every call, since if one makes copies of</span>
        <span class="c1"># instances, this attribute will be copied as well, which will lose the</span>
        <span class="c1"># reference.</span>
        <span class="n">value</span><span class="o">.</span><span class="n">_instance_ref</span> <span class="o">=</span> <span class="n">weakref</span><span class="o">.</span><span class="n">ref</span><span class="p">(</span><span class="n">instance</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">value</span>

    <span class="k">def</span> <span class="fm">__set__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instance</span><span class="p">,</span> <span class="n">names</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set value of ``instance`` attribute to ``names``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        instance : object</span>
<span class="sd">            Instance that owns the attribute</span>
<span class="sd">        names : None, str, list, tuple</span>
<span class="sd">            Column name(s) to store, or None to clear</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="n">names</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">names</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Remove attribute value from the meta[&#39;__attributes__&#39;] dict.</span>
            <span class="c1"># Subsequent access will just return None.</span>
            <span class="nb">delattr</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># This stores names into instance.meta[&#39;__attributes__&#39;] as tuple</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__set__</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">names</span><span class="p">))</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get the value of the attribute.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        names : None, tuple</span>
<span class="sd">            Include/exclude names</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Get the value from instance.meta[&#39;__attributes__&#39;]</span>
        <span class="n">instance</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_instance_ref</span><span class="p">()</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__get__</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="n">instance</span><span class="o">.</span><span class="vm">__class__</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_instance_ref&quot;</span><span class="p">):</span>
            <span class="n">out</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;&lt;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> name=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2"> value=</span><span class="si">{</span><span class="bp">self</span><span class="p">()</span><span class="si">}</span><span class="s2">&gt;&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__repr__</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">out</span>

    <span class="k">def</span> <span class="nf">_add_remove_setup</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">names</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Common setup for add and remove.</span>

<span class="sd">        - Coerce attribute value to a list</span>
<span class="sd">        - Coerce names into a list</span>
<span class="sd">        - Get the parent table instance</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="n">names</span><span class="p">]</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">else</span> <span class="nb">list</span><span class="p">(</span><span class="n">names</span><span class="p">)</span>
        <span class="c1"># Get the value. This is the same as self() but we need `instance` here.</span>
        <span class="n">instance</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_instance_ref</span><span class="p">()</span>
        <span class="n">value</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__get__</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="n">instance</span><span class="o">.</span><span class="vm">__class__</span><span class="p">)</span>
        <span class="n">value</span> <span class="o">=</span> <span class="p">[]</span> <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="nb">list</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">instance</span><span class="p">,</span> <span class="n">names</span><span class="p">,</span> <span class="n">value</span>

    <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">names</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Add ``names`` to the include/exclude attribute.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        names : str, list, tuple</span>
<span class="sd">            Column name(s) to add</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">instance</span><span class="p">,</span> <span class="n">names</span><span class="p">,</span> <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_add_remove_setup</span><span class="p">(</span><span class="n">names</span><span class="p">)</span>
        <span class="n">value</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">name</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">names</span> <span class="k">if</span> <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">value</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__set__</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">remove</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">names</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Remove ``names`` from the include/exclude attribute.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        names : str, list, tuple</span>
<span class="sd">            Column name(s) to remove</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_remove</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="n">raise_exc</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_remove</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">names</span><span class="p">,</span> <span class="n">raise_exc</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Remove ``names`` with optional checking if they exist.&quot;&quot;&quot;</span>
        <span class="n">instance</span><span class="p">,</span> <span class="n">names</span><span class="p">,</span> <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_add_remove_setup</span><span class="p">(</span><span class="n">names</span><span class="p">)</span>

        <span class="c1"># Return now if there are no attributes and thus no action to be taken.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">raise_exc</span> <span class="ow">and</span> <span class="s2">&quot;__attributes__&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">instance</span><span class="o">.</span><span class="n">meta</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="c1"># Remove one by one, optionally raising an exception if name is missing.</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">names</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">value</span><span class="p">:</span>
                <span class="n">value</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>  <span class="c1"># Using the list.remove method</span>
            <span class="k">elif</span> <span class="n">raise_exc</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2"> not in </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># Change to either None or a tuple for storing back to attribute</span>
        <span class="n">value</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">value</span> <span class="o">==</span> <span class="p">[]</span> <span class="k">else</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="fm">__set__</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_rename</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">new_name</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Rename ``name`` to ``new_name`` if ``name`` is in the list.&quot;&quot;&quot;</span>
        <span class="n">names</span> <span class="o">=</span> <span class="bp">self</span><span class="p">()</span> <span class="ow">or</span> <span class="p">()</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">names</span><span class="p">:</span>
            <span class="n">new_names</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">names</span><span class="p">)</span>
            <span class="n">new_names</span><span class="p">[</span><span class="n">new_names</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">name</span><span class="p">)]</span> <span class="o">=</span> <span class="n">new_name</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">new_names</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">set</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">names</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set value of include/exclude attribute to ``names``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        names : None, str, list, tuple</span>
<span class="sd">            Column name(s) to store, or None to clear</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">class</span> <span class="nc">_Context</span><span class="p">:</span>
            <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">descriptor_self</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">descriptor_self</span> <span class="o">=</span> <span class="n">descriptor_self</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">names_orig</span> <span class="o">=</span> <span class="n">descriptor_self</span><span class="p">()</span>

            <span class="k">def</span> <span class="fm">__enter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
                <span class="k">pass</span>

            <span class="k">def</span> <span class="fm">__exit__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">type</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">tb</span><span class="p">):</span>
                <span class="n">descriptor_self</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">descriptor_self</span>
                <span class="n">instance</span> <span class="o">=</span> <span class="n">descriptor_self</span><span class="o">.</span><span class="n">_instance_ref</span><span class="p">()</span>
                <span class="n">descriptor_self</span><span class="o">.</span><span class="fm">__set__</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">names_orig</span><span class="p">)</span>

            <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
                <span class="k">return</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">descriptor_self</span><span class="p">)</span>

        <span class="n">ctx</span> <span class="o">=</span> <span class="n">_Context</span><span class="p">(</span><span class="n">descriptor_self</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>

        <span class="n">instance</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_instance_ref</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="fm">__set__</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="n">names</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">ctx</span>


<div class="viewcode-block" id="Table">
<a class="viewcode-back" href="../../../autoapi/nifits/io/oifits/index.html#nifits.io.oifits.Table">[docs]</a>
<span class="k">class</span> <span class="nc">Table</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A class to represent tables of heterogeneous data.</span>

<span class="sd">    `~astropy.table.Table` provides a class for heterogeneous tabular data.</span>
<span class="sd">    A key enhancement provided by the `~astropy.table.Table` class over</span>
<span class="sd">    e.g. a `numpy` structured array is the ability to easily modify the</span>
<span class="sd">    structure of the table by adding or removing columns, or adding new</span>
<span class="sd">    rows of data.  In addition table and column metadata are fully supported.</span>

<span class="sd">    `~astropy.table.Table` differs from `~astropy.nddata.NDData` by the</span>
<span class="sd">    assumption that the input data consists of columns of homogeneous data,</span>
<span class="sd">    where each column has a unique identifier and may contain additional</span>
<span class="sd">    metadata such as the data unit, format, and description.</span>

<span class="sd">    See also: https://docs.astropy.org/en/stable/table/</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : numpy ndarray, dict, list, table-like object, optional</span>
<span class="sd">        Data to initialize table.</span>
<span class="sd">    masked : bool, optional</span>
<span class="sd">        Specify whether the table is masked.</span>
<span class="sd">    names : list, optional</span>
<span class="sd">        Specify column names.</span>
<span class="sd">    dtype : list, optional</span>
<span class="sd">        Specify column data types.</span>
<span class="sd">    meta : dict, optional</span>
<span class="sd">        Metadata associated with the table.</span>
<span class="sd">    copy : bool, optional</span>
<span class="sd">        Copy the input column data and make a deep copy of the input meta.</span>
<span class="sd">        Default is True.</span>
<span class="sd">    rows : numpy ndarray, list of list, optional</span>
<span class="sd">        Row-oriented data for table instead of ``data`` argument.</span>
<span class="sd">    copy_indices : bool, optional</span>
<span class="sd">        Copy any indices in the input data. Default is True.</span>
<span class="sd">    units : list, dict, optional</span>
<span class="sd">        List or dict of units to apply to columns.</span>
<span class="sd">    descriptions : list, dict, optional</span>
<span class="sd">        List or dict of descriptions to apply to columns.</span>
<span class="sd">    **kwargs : dict, optional</span>
<span class="sd">        Additional keyword args when converting table-like object.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">meta</span> <span class="o">=</span> <span class="n">MetaData</span><span class="p">(</span><span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="c1"># Define class attributes for core container objects to allow for subclass</span>
    <span class="c1"># customization.</span>
    <span class="n">Row</span> <span class="o">=</span> <span class="n">Row</span>
    <span class="n">Column</span> <span class="o">=</span> <span class="n">Column</span>
    <span class="n">MaskedColumn</span> <span class="o">=</span> <span class="n">MaskedColumn</span>
    <span class="n">TableColumns</span> <span class="o">=</span> <span class="n">TableColumns</span>
    <span class="n">TableFormatter</span> <span class="o">=</span> <span class="n">TableFormatter</span>

    <span class="c1"># Unified I/O read and write methods from .connect</span>
    <span class="n">read</span> <span class="o">=</span> <span class="n">UnifiedReadWriteMethod</span><span class="p">(</span><span class="n">TableRead</span><span class="p">)</span>
    <span class="n">write</span> <span class="o">=</span> <span class="n">UnifiedReadWriteMethod</span><span class="p">(</span><span class="n">TableWrite</span><span class="p">)</span>

    <span class="n">pprint_exclude_names</span> <span class="o">=</span> <span class="n">PprintIncludeExclude</span><span class="p">()</span>
    <span class="n">pprint_include_names</span> <span class="o">=</span> <span class="n">PprintIncludeExclude</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">as_array</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">keep_byteorder</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a new copy of the table in the form of a structured np.ndarray or</span>
<span class="sd">        np.ma.MaskedArray object (as appropriate).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        keep_byteorder : bool, optional</span>
<span class="sd">            By default the returned array has all columns in native byte</span>
<span class="sd">            order.  However, if this option is `True` this preserves the</span>
<span class="sd">            byte order of all columns (if any are non-native).</span>

<span class="sd">        names : list, optional:</span>
<span class="sd">            List of column names to include for returned structured array.</span>
<span class="sd">            Default is to include all table columns.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        table_array : array or `~numpy.ma.MaskedArray`</span>
<span class="sd">            Copy of table as a numpy structured array.</span>
<span class="sd">            ndarray for unmasked or `~numpy.ma.MaskedArray` for masked.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">masked</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">masked</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_masked_columns</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_masked_values</span>
        <span class="n">empty_init</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">empty</span> <span class="k">if</span> <span class="n">masked</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">empty_init</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>

        <span class="n">dtype</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">cols</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">names</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">cols</span> <span class="o">=</span> <span class="p">[</span><span class="n">col</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">cols</span> <span class="k">if</span> <span class="n">col</span><span class="o">.</span><span class="n">info</span><span class="o">.</span><span class="n">name</span> <span class="ow">in</span> <span class="n">names</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">cols</span><span class="p">:</span>
            <span class="n">col_descr</span> <span class="o">=</span> <span class="n">descr</span><span class="p">(</span><span class="n">col</span><span class="p">)</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">col</span><span class="o">.</span><span class="n">info</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">isnative</span> <span class="ow">or</span> <span class="n">keep_byteorder</span><span class="p">):</span>
                <span class="n">new_dt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">col_descr</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">newbyteorder</span><span class="p">(</span><span class="s2">&quot;=&quot;</span><span class="p">)</span>
                <span class="n">col_descr</span> <span class="o">=</span> <span class="p">(</span><span class="n">col_descr</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">new_dt</span><span class="p">,</span> <span class="n">col_descr</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>

            <span class="n">dtype</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">col_descr</span><span class="p">)</span>

        <span class="n">data</span> <span class="o">=</span> <span class="n">empty_init</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">cols</span><span class="p">:</span>
            <span class="c1"># When assigning from one array into a field of a structured array,</span>
            <span class="c1"># Numpy will automatically swap those columns to their destination</span>
            <span class="c1"># byte order where applicable</span>
            <span class="n">data</span><span class="p">[</span><span class="n">col</span><span class="o">.</span><span class="n">info</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">col</span>

            <span class="c1"># For masked out, masked mixin columns need to set output mask attribute.</span>
            <span class="k">if</span> <span class="n">masked</span> <span class="ow">and</span> <span class="n">has_info_class</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">MixinInfo</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="s2">&quot;mask&quot;</span><span class="p">):</span>
                <span class="n">data</span><span class="p">[</span><span class="n">col</span><span class="o">.</span><span class="n">info</span><span class="o">.</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">mask</span> <span class="o">=</span> <span class="n">col</span><span class="o">.</span><span class="n">mask</span>

            <span class="c1"># Propagate the fill_value from the table column to the output array.</span>
            <span class="c1"># If this is not done, then the output array will use numpy.ma&#39;s default</span>
            <span class="c1"># fill values (999999 for ints, 1E20 for floats, &quot;N/A&quot; for strings)</span>
            <span class="k">if</span> <span class="n">masked</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="s2">&quot;fill_value&quot;</span><span class="p">):</span>
                <span class="n">data</span><span class="p">[</span><span class="n">col</span><span class="o">.</span><span class="n">info</span><span class="o">.</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">fill_value</span> <span class="o">=</span> <span class="n">col</span><span class="o">.</span><span class="n">fill_value</span>

        <span class="k">return</span> <span class="n">data</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">masked</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">names</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">meta</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">rows</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">copy_indices</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">units</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">descriptions</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="c1"># Set up a placeholder empty table</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_masked</span><span class="p">(</span><span class="n">masked</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">TableColumns</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">formatter</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">TableFormatter</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_copy_indices</span> <span class="o">=</span> <span class="kc">True</span>  <span class="c1"># copy indices from this Table by default</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_init_indices</span> <span class="o">=</span> <span class="n">copy_indices</span>  <span class="c1"># whether to copy indices in init</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">primary_key</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Must copy if dtype are changing</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">copy</span> <span class="ow">and</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot specify dtype when copy=False&quot;</span><span class="p">)</span>

        <span class="c1"># Specifies list of names found for the case of initializing table with</span>
        <span class="c1"># a list of dict. If data are not list of dict then this is None.</span>
        <span class="n">names_from_list_of_dict</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Row-oriented input, e.g. list of lists or list of tuples, list of</span>
        <span class="c1"># dict, Row instance.  Set data to something that the subsequent code</span>
        <span class="c1"># will parse correctly.</span>
        <span class="k">if</span> <span class="n">rows</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">data</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot supply both `data` and `rows` values&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">rows</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">GeneratorType</span><span class="p">):</span>
                <span class="c1"># Without this then the all(..) test below uses up the generator</span>
                <span class="n">rows</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">rows</span><span class="p">)</span>

            <span class="c1"># Get column names if `rows` is a list of dict, otherwise this is None</span>
            <span class="n">names_from_list_of_dict</span> <span class="o">=</span> <span class="n">_get_names_from_list_of_dict</span><span class="p">(</span><span class="n">rows</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">names_from_list_of_dict</span><span class="p">:</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">rows</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">rows</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Row</span><span class="p">):</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">rows</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">data</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">rows</span><span class="p">))</span>

        <span class="c1"># Infer the type of the input data and set up the initialization</span>
        <span class="c1"># function, number of columns, and potentially the default col names</span>

        <span class="n">default_names</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Handle custom (subclass) table attributes that are stored in meta.</span>
        <span class="c1"># These are defined as class attributes using the TableAttribute</span>
        <span class="c1"># descriptor.  Any such attributes get removed from kwargs here and</span>
        <span class="c1"># stored for use after the table is otherwise initialized. Any values</span>
        <span class="c1"># provided via kwargs will have precedence over existing values from</span>
        <span class="c1"># meta (e.g. from data as a Table or meta via kwargs).</span>
        <span class="n">meta_table_attrs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">kwargs</span><span class="p">):</span>
                <span class="n">descr</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">descr</span><span class="p">,</span> <span class="n">TableAttribute</span><span class="p">):</span>
                    <span class="n">meta_table_attrs</span><span class="p">[</span><span class="n">attr</span><span class="p">]</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">attr</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="s2">&quot;__astropy_table__&quot;</span><span class="p">):</span>
            <span class="c1"># Data object implements the __astropy_table__ interface method.</span>
            <span class="c1"># Calling that method returns an appropriate instance of</span>
            <span class="c1"># self.__class__ and respects the `copy` arg.  The returned</span>
            <span class="c1"># Table object should NOT then be copied.</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">__astropy_table__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span> <span class="n">copy</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="n">copy</span> <span class="o">=</span> <span class="n">COPY_IF_NEEDED</span>
        <span class="k">elif</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;__init__() got unexpected keyword argument </span><span class="si">{</span><span class="nb">next</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span><span class="si">!r}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">and</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">0</span><span class="p">,)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Row</span><span class="p">):</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">_table</span><span class="p">[</span><span class="n">data</span><span class="o">.</span><span class="n">_index</span> <span class="p">:</span> <span class="n">data</span><span class="o">.</span><span class="n">_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
            <span class="c1"># Get column names from `data` if it is a list of dict, otherwise this is None.</span>
            <span class="c1"># This might be previously defined if `rows` was supplied as an init arg.</span>
            <span class="n">names_from_list_of_dict</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">names_from_list_of_dict</span> <span class="ow">or</span> <span class="n">_get_names_from_list_of_dict</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">names_from_list_of_dict</span><span class="p">:</span>
                <span class="n">init_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_init_from_list_of_dicts</span>
                <span class="n">n_cols</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">names_from_list_of_dict</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">init_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_init_from_list</span>
                <span class="n">n_cols</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span><span class="p">:</span>
                <span class="n">init_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_init_from_ndarray</span>  <span class="c1"># _struct</span>
                <span class="n">n_cols</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span><span class="p">)</span>
                <span class="n">default_names</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">init_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_init_from_ndarray</span>  <span class="c1"># _homog</span>
                <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">():</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Can not initialize a Table with a scalar&quot;</span><span class="p">)</span>
                <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:]</span>
                <span class="n">n_cols</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">Mapping</span><span class="p">):</span>
            <span class="n">init_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_init_from_dict</span>
            <span class="n">default_names</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
            <span class="n">n_cols</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">default_names</span><span class="p">)</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">Table</span><span class="p">):</span>
            <span class="c1"># If user-input meta is None then use data.meta (if non-trivial)</span>
            <span class="k">if</span> <span class="n">meta</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">data</span><span class="o">.</span><span class="n">meta</span><span class="p">:</span>
                <span class="c1"># At this point do NOT deepcopy data.meta as this will happen after</span>
                <span class="c1"># table init_func() is called.  But for table input the table meta</span>
                <span class="c1"># gets a key copy here if copy=False because later a direct object ref</span>
                <span class="c1"># is used.</span>
                <span class="n">meta</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">meta</span> <span class="k">if</span> <span class="n">copy</span> <span class="k">else</span> <span class="n">data</span><span class="o">.</span><span class="n">meta</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

            <span class="c1"># Handle indices on input table. Copy primary key and don&#39;t copy indices</span>
            <span class="c1"># if the input Table is in non-copy mode.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">primary_key</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">primary_key</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_init_indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_init_indices</span> <span class="ow">and</span> <span class="n">data</span><span class="o">.</span><span class="n">_copy_indices</span>

            <span class="c1"># Extract default names, n_cols, and then overwrite ``data`` to be the</span>
            <span class="c1"># table columns so we can use _init_from_list.</span>
            <span class="n">default_names</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">colnames</span>
            <span class="n">n_cols</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">default_names</span><span class="p">)</span>
            <span class="n">data</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>

            <span class="n">init_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_init_from_list</span>

        <span class="k">elif</span> <span class="n">data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">names</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="c1"># Table was initialized as `t = Table()`. Set up for empty</span>
                    <span class="c1"># table with names=[], data=[], and n_cols=0.</span>
                    <span class="c1"># self._init_from_list() will simply return, giving the</span>
                    <span class="c1"># expected empty table.</span>
                    <span class="n">names</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="c1"># No data nor names but dtype is available.  This must be</span>
                        <span class="c1"># valid to initialize a structured array.</span>
                        <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
                        <span class="n">names</span> <span class="o">=</span> <span class="n">dtype</span><span class="o">.</span><span class="n">names</span>
                        <span class="n">dtype</span> <span class="o">=</span> <span class="p">[</span><span class="n">dtype</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">names</span><span class="p">]</span>
                    <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                            <span class="s2">&quot;dtype was specified but could not be &quot;</span>
                            <span class="s2">&quot;parsed for column names&quot;</span>
                        <span class="p">)</span>
            <span class="c1"># names is guaranteed to be set at this point</span>
            <span class="n">init_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_init_from_list</span>
            <span class="n">n_cols</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">names</span><span class="p">)</span>
            <span class="n">data</span> <span class="o">=</span> <span class="p">[[]]</span> <span class="o">*</span> <span class="n">n_cols</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Data type </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="si">}</span><span class="s2"> not allowed to init Table&quot;</span><span class="p">)</span>

        <span class="c1"># Set up defaults if names and/or dtype are not specified.</span>
        <span class="c1"># A value of None means the actual value will be inferred</span>
        <span class="c1"># within the appropriate initialization routine, either from</span>
        <span class="c1"># existing specification or auto-generated.</span>

        <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dtype</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">n_cols</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">default_names</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">default_names</span> <span class="o">=</span> <span class="n">dtype</span><span class="o">.</span><span class="n">names</span>
            <span class="c1"># Convert a numpy dtype input to a list of dtypes for later use.</span>
            <span class="n">dtype</span> <span class="o">=</span> <span class="p">[</span><span class="n">dtype</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">dtype</span><span class="o">.</span><span class="n">names</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">names</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">names</span> <span class="o">=</span> <span class="n">default_names</span> <span class="ow">or</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">n_cols</span>

        <span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span> <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="nb">str</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">names</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_check_names_dtype</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">n_cols</span><span class="p">)</span>

        <span class="c1"># Finally do the real initialization</span>
        <span class="n">init_func</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">names</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">n_cols</span><span class="p">,</span> <span class="n">copy</span><span class="p">)</span>

        <span class="c1"># Set table meta.  If copy=True then deepcopy meta otherwise use the</span>
        <span class="c1"># user-supplied meta directly.</span>
        <span class="k">if</span> <span class="n">meta</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">meta</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">meta</span><span class="p">)</span> <span class="k">if</span> <span class="n">copy</span> <span class="k">else</span> <span class="n">meta</span>

        <span class="c1"># Update meta with TableAttributes supplied as kwargs in Table init.</span>
        <span class="c1"># This takes precedence over previously-defined meta.</span>
        <span class="k">if</span> <span class="n">meta_table_attrs</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">attr</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">meta_table_attrs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

        <span class="c1"># Whatever happens above, the masked property should be set to a boolean</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">masked</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;masked property must be None, True or False&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_set_column_attribute</span><span class="p">(</span><span class="s2">&quot;unit&quot;</span><span class="p">,</span> <span class="n">units</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_column_attribute</span><span class="p">(</span><span class="s2">&quot;description&quot;</span><span class="p">,</span> <span class="n">descriptions</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_set_column_attribute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set ``attr`` for columns to ``values``, which can be either a dict (keyed by column</span>
<span class="sd">        name) or a dict of name: value pairs.  This is used for handling the ``units`` and</span>
<span class="sd">        ``descriptions`` kwargs to ``__init__``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">values</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">Row</span><span class="p">):</span>
            <span class="c1"># For a Row object transform to an equivalent dict.</span>
            <span class="n">values</span> <span class="o">=</span> <span class="p">{</span><span class="n">name</span><span class="p">:</span> <span class="n">values</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">values</span><span class="o">.</span><span class="n">colnames</span><span class="p">}</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">Mapping</span><span class="p">):</span>
            <span class="c1"># If not a dict map, assume iterable and map to dict if the right length</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;sequence of </span><span class="si">{</span><span class="n">attr</span><span class="si">}</span><span class="s2"> values must match number of columns&quot;</span>
                <span class="p">)</span>
            <span class="n">values</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">colnames</span><span class="p">,</span> <span class="n">values</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">values</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;invalid column name </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2"> for setting </span><span class="si">{</span><span class="n">attr</span><span class="si">}</span><span class="s2"> attribute&quot;</span>
                <span class="p">)</span>

            <span class="c1"># Special case: ignore unit if it is an empty or blank string</span>
            <span class="k">if</span> <span class="n">attr</span> <span class="o">==</span> <span class="s2">&quot;unit&quot;</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">value</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;&quot;</span><span class="p">:</span>
                    <span class="n">value</span> <span class="o">=</span> <span class="kc">None</span>

            <span class="k">if</span> <span class="n">value</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked</span><span class="p">,</span> <span class="kc">None</span><span class="p">):</span>
                <span class="n">col</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">attr</span> <span class="o">==</span> <span class="s2">&quot;unit&quot;</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">Quantity</span><span class="p">):</span>
                    <span class="c1"># Update the Quantity unit in-place</span>
                    <span class="n">col</span> <span class="o">&lt;&lt;=</span> <span class="n">value</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="nb">setattr</span><span class="p">(</span><span class="n">col</span><span class="o">.</span><span class="n">info</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">columns</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">(</span>
            <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">col</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">BaseColumn</span><span class="p">)</span> <span class="k">else</span> <span class="n">col_copy</span><span class="p">(</span><span class="n">col</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">col</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">columns</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">meta</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__setstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="n">columns</span><span class="p">,</span> <span class="n">meta</span> <span class="o">=</span> <span class="n">state</span>
        <span class="bp">self</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">columns</span><span class="p">,</span> <span class="n">meta</span><span class="o">=</span><span class="n">meta</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">mask</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Dynamic view of available masks</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">masked</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_masked_columns</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_masked_values</span><span class="p">:</span>
            <span class="n">mask_table</span> <span class="o">=</span> <span class="n">Table</span><span class="p">(</span>
                <span class="p">[</span>
                    <span class="nb">getattr</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="s2">&quot;mask&quot;</span><span class="p">,</span> <span class="n">FalseArray</span><span class="p">(</span><span class="n">col</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
                    <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">itercols</span><span class="p">()</span>
                <span class="p">],</span>
                <span class="n">names</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">colnames</span><span class="p">,</span>
                <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="c1"># Set hidden attribute to force inplace setitem so that code like</span>
            <span class="c1"># t.mask[&#39;a&#39;] = [1, 0, 1] will correctly set the underlying mask.</span>
            <span class="c1"># See #5556 for discussion.</span>
            <span class="n">mask_table</span><span class="o">.</span><span class="n">_setitem_inplace</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">mask_table</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">return</span> <span class="n">mask_table</span>

    <span class="nd">@mask</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">mask</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">val</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This is needed so that comparison of a masked Table and a</span>
<span class="sd">        MaskedArray works.  The requirement comes from numpy.ma.core</span>
<span class="sd">        so don&#39;t remove this property.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_array</span><span class="p">()</span><span class="o">.</span><span class="n">mask</span>

    <span class="k">def</span> <span class="nf">filled</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return copy of self, with masked values filled.</span>

<span class="sd">        If input ``fill_value`` supplied then that value is used for all</span>
<span class="sd">        masked entries in the table.  Otherwise the individual</span>
<span class="sd">        ``fill_value`` defined for each table column is used.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        fill_value : str</span>
<span class="sd">            If supplied, this ``fill_value`` is used for all masked entries</span>
<span class="sd">            in the entire table.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        filled_table : `~astropy.table.Table`</span>
<span class="sd">            New table with masked values filled</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">masked</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_masked_columns</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_masked_values</span><span class="p">:</span>
            <span class="c1"># Get new columns with masked values filled, then create Table with those</span>
            <span class="c1"># new cols (copy=False) but deepcopy the meta.</span>
            <span class="n">data</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">col</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="n">fill_value</span><span class="p">)</span> <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="s2">&quot;filled&quot;</span><span class="p">)</span> <span class="k">else</span> <span class="n">col</span>
                <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">itercols</span><span class="p">()</span>
            <span class="p">]</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">meta</span><span class="o">=</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">meta</span><span class="p">),</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Return copy of the original object.</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">indices</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the indices associated with columns of the table</span>
<span class="sd">        as a TableIndices object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">lst</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">column</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">column</span><span class="o">.</span><span class="n">info</span><span class="o">.</span><span class="n">indices</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">sum</span><span class="p">(</span><span class="n">index</span> <span class="ow">is</span> <span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">lst</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># ensure uniqueness</span>
                    <span class="n">lst</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">TableIndices</span><span class="p">(</span><span class="n">lst</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">loc</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a TableLoc object that can be used for retrieving</span>
<span class="sd">        rows by index in a given data range. Note that both loc</span>
<span class="sd">        and iloc work only with single-column indices.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">TableLoc</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">loc_indices</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a TableLocIndices object that can be used for retrieving</span>
<span class="sd">        the row indices corresponding to given table index key value or values.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">TableLocIndices</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">iloc</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a TableILoc object that can be used for retrieving</span>
<span class="sd">        indexed rows in the order they appear in the index.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">TableILoc</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">add_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">colnames</span><span class="p">,</span> <span class="n">engine</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">unique</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Insert a new index among one or more columns.</span>
<span class="sd">        If there are no indices, make this index the</span>
<span class="sd">        primary table index.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        colnames : str or list</span>
<span class="sd">            List of column names (or a single column name) to index</span>
<span class="sd">        engine : type or None</span>
<span class="sd">            Indexing engine class to use, either `~astropy.table.SortedArray`,</span>
<span class="sd">            `~astropy.table.BST`, or `~astropy.table.SCEngine`. If the supplied</span>
<span class="sd">            argument is None (by default), use `~astropy.table.SortedArray`.</span>
<span class="sd">        unique : bool</span>
<span class="sd">            Whether the values of the index must be unique. Default is False.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">colnames</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">colnames</span> <span class="o">=</span> <span class="p">(</span><span class="n">colnames</span><span class="p">,)</span>
        <span class="n">columns</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">colnames</span><span class="p">)]</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>

        <span class="c1"># make sure all columns support indexing</span>
        <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">columns</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">col</span><span class="o">.</span><span class="n">info</span><span class="p">,</span> <span class="s2">&quot;_supports_indexing&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s1">&#39;Cannot create an index on column &quot;</span><span class="si">{</span><span class="n">col</span><span class="o">.</span><span class="n">info</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s1">&quot;, &#39;</span>
                    <span class="sa">f</span><span class="s1">&#39;of type &quot;</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">col</span><span class="p">)</span><span class="si">}</span><span class="s1">&quot;&#39;</span>
                <span class="p">)</span>

        <span class="n">is_primary</span> <span class="o">=</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">indices</span>
        <span class="n">index</span> <span class="o">=</span> <span class="n">Index</span><span class="p">(</span><span class="n">columns</span><span class="p">,</span> <span class="n">engine</span><span class="o">=</span><span class="n">engine</span><span class="p">,</span> <span class="n">unique</span><span class="o">=</span><span class="n">unique</span><span class="p">)</span>
        <span class="n">sliced_index</span> <span class="o">=</span> <span class="n">SlicedIndex</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span> <span class="n">original</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">is_primary</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">primary_key</span> <span class="o">=</span> <span class="n">colnames</span>
        <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">columns</span><span class="p">:</span>
            <span class="n">col</span><span class="o">.</span><span class="n">info</span><span class="o">.</span><span class="n">indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sliced_index</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">remove_indices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">colname</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Remove all indices involving the given column.</span>
<span class="sd">        If the primary index is removed, the new primary</span>
<span class="sd">        index will be the most recently added remaining</span>
<span class="sd">        index.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        colname : str</span>
<span class="sd">            Name of column</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">col</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="n">colname</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">indices</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">index</span><span class="o">.</span><span class="n">col_position</span><span class="p">(</span><span class="n">col</span><span class="o">.</span><span class="n">info</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="k">pass</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">index</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
                    <span class="n">c</span><span class="o">.</span><span class="n">info</span><span class="o">.</span><span class="n">indices</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">index_mode</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mode</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a context manager for an indexing mode.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        mode : str</span>
<span class="sd">            Either &#39;freeze&#39;, &#39;copy_on_getitem&#39;, or &#39;discard_on_copy&#39;.</span>
<span class="sd">            In &#39;discard_on_copy&#39; mode,</span>
<span class="sd">            indices are not copied whenever columns or tables are copied.</span>
<span class="sd">            In &#39;freeze&#39; mode, indices are not modified whenever columns are</span>
<span class="sd">            modified; at the exit of the context, indices refresh themselves</span>
<span class="sd">            based on column values. This mode is intended for scenarios in</span>
<span class="sd">            which one intends to make many additions or modifications in an</span>
<span class="sd">            indexed column.</span>
<span class="sd">            In &#39;copy_on_getitem&#39; mode, indices are copied when taking column</span>
<span class="sd">            slices as well as table slices, so col[i0:i1] will preserve</span>
<span class="sd">            indices.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_IndexModeContext</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mode</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__array__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">COPY_IF_NEEDED</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Support converting Table to np.array via np.array(table).</span>

<span class="sd">        Coercion to a different dtype via np.array(table, dtype) is not</span>
<span class="sd">        supported and will raise a ValueError.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">object</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Datatype coercion is not allowed&quot;</span><span class="p">)</span>

            <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">)</span>
            <span class="n">out</span><span class="p">[()]</span> <span class="o">=</span> <span class="bp">self</span>
            <span class="k">return</span> <span class="n">out</span>

        <span class="c1"># This limitation is because of the following unexpected result that</span>
        <span class="c1"># should have made a table copy while changing the column names.</span>
        <span class="c1">#</span>
        <span class="c1"># &gt;&gt;&gt; d = astropy.table.Table([[1,2],[3,4]])</span>
        <span class="c1"># &gt;&gt;&gt; np.array(d, dtype=[(&#39;a&#39;, &#39;i8&#39;), (&#39;b&#39;, &#39;i8&#39;)])</span>
        <span class="c1"># array([(0, 0), (0, 0)],</span>
        <span class="c1">#       dtype=[(&#39;a&#39;, &#39;&lt;i8&#39;), (&#39;b&#39;, &#39;&lt;i8&#39;)])</span>

        <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_array</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">out</span><span class="o">.</span><span class="n">data</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">)</span> <span class="k">else</span> <span class="n">out</span>

    <span class="k">def</span> <span class="nf">_check_names_dtype</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">names</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">n_cols</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Make sure that names and dtype are both iterable and have</span>
<span class="sd">        the same length as data.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">inp_list</span><span class="p">,</span> <span class="n">inp_str</span> <span class="ow">in</span> <span class="p">((</span><span class="n">dtype</span><span class="p">,</span> <span class="s2">&quot;dtype&quot;</span><span class="p">),</span> <span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="s2">&quot;names&quot;</span><span class="p">)):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">isiterable</span><span class="p">(</span><span class="n">inp_list</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">inp_str</span><span class="si">}</span><span class="s2"> must be a list or None&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">names</span><span class="p">)</span> <span class="o">!=</span> <span class="n">n_cols</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span> <span class="o">!=</span> <span class="n">n_cols</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s1">&#39;Arguments &quot;names&quot; and &quot;dtype&quot; must match number of columns&#39;</span>
            <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_init_from_list_of_dicts</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">names</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">n_cols</span><span class="p">,</span> <span class="n">copy</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize table from a list of dictionaries representing rows.&quot;&quot;&quot;</span>
        <span class="c1"># Define placeholder for missing values as a unique object that cannot</span>
        <span class="c1"># every occur in user data.</span>
        <span class="n">MISSING</span> <span class="o">=</span> <span class="nb">object</span><span class="p">()</span>

        <span class="c1"># Gather column names that exist in the input `data`.</span>
        <span class="n">names_from_data</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
            <span class="n">names_from_data</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">row</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">set</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">==</span> <span class="n">names_from_data</span><span class="p">:</span>
            <span class="n">names_from_data</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">names_from_data</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">names_from_data</span><span class="p">)</span>

        <span class="c1"># Note: if set(data[0].keys()) != names_from_data, this will give an</span>
        <span class="c1"># exception later, so NO need to catch here.</span>

        <span class="c1"># Convert list of dict into dict of list (cols), keep track of missing</span>
        <span class="c1"># indexes and put in MISSING placeholders in the `cols` lists.</span>
        <span class="n">cols</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">missing_indexes</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">names_from_data</span><span class="p">:</span>
            <span class="n">cols</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">val</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
                <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                    <span class="n">missing_indexes</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ii</span><span class="p">)</span>
                    <span class="n">val</span> <span class="o">=</span> <span class="n">MISSING</span>
                <span class="n">cols</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>

        <span class="c1"># Fill the missing entries with first values</span>
        <span class="k">if</span> <span class="n">missing_indexes</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">indexes</span> <span class="ow">in</span> <span class="n">missing_indexes</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">col</span> <span class="o">=</span> <span class="n">cols</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
                <span class="n">first_val</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">val</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">col</span> <span class="k">if</span> <span class="n">val</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">MISSING</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">indexes</span><span class="p">:</span>
                    <span class="n">col</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">first_val</span>

        <span class="c1"># prepare initialization</span>
        <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">names</span><span class="p">):</span>
            <span class="n">names</span> <span class="o">=</span> <span class="n">names_from_data</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_init_from_dict</span><span class="p">(</span><span class="n">cols</span><span class="p">,</span> <span class="n">names</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">n_cols</span><span class="p">,</span> <span class="n">copy</span><span class="p">)</span>

        <span class="c1"># Mask the missing values if necessary, converting columns to MaskedColumn</span>
        <span class="c1"># as needed.</span>
        <span class="k">if</span> <span class="n">missing_indexes</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">indexes</span> <span class="ow">in</span> <span class="n">missing_indexes</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">col</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
                <span class="c1"># Ensure that any Column subclasses with MISSING values can support</span>
                <span class="c1"># setting masked values. As of astropy 4.0 the test condition below is</span>
                <span class="c1"># always True since _init_from_dict cannot result in mixin columns.</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">Column</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">MaskedColumn</span><span class="p">):</span>
                    <span class="bp">self</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">MaskedColumn</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

                <span class="c1"># Finally do the masking in a mixin-safe way.</span>
                <span class="bp">self</span><span class="p">[</span><span class="n">name</span><span class="p">][</span><span class="n">indexes</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked</span>

    <span class="k">def</span> <span class="nf">_init_from_list</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">names</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">n_cols</span><span class="p">,</span> <span class="n">copy</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize table from a list of column data.  A column can be a</span>
<span class="sd">        Column object, np.ndarray, mixin, or any other iterable object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Special case of initializing an empty table like `t = Table()`. No</span>
        <span class="c1"># action required at this point.</span>
        <span class="k">if</span> <span class="n">n_cols</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="n">cols</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">default_names</span> <span class="o">=</span> <span class="n">_auto_names</span><span class="p">(</span><span class="n">n_cols</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">col</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">default_name</span><span class="p">,</span> <span class="n">dt</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">names</span><span class="p">,</span> <span class="n">default_names</span><span class="p">,</span> <span class="n">dtype</span><span class="p">):</span>
            <span class="n">col</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_convert_data_to_col</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">copy</span><span class="p">,</span> <span class="n">default_name</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>

            <span class="n">cols</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">col</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_init_from_cols</span><span class="p">(</span><span class="n">cols</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_convert_data_to_col</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">default_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert any allowed sequence data ``col`` to a column object that can be used</span>
<span class="sd">        directly in the self.columns dict.  This could be a Column, MaskedColumn,</span>
<span class="sd">        or mixin column.</span>

<span class="sd">        The final column name is determined by::</span>

<span class="sd">            name or data.info.name or def_name</span>

<span class="sd">        If ``data`` has no ``info`` then ``name = name or def_name``.</span>

<span class="sd">        The behavior of ``copy`` for Column objects is:</span>
<span class="sd">        - copy=True: new class instance with a copy of data and deep copy of meta</span>
<span class="sd">        - copy=False: new class instance with same data and a key-only copy of meta</span>

<span class="sd">        For mixin columns:</span>
<span class="sd">        - copy=True: new class instance with copy of data and deep copy of meta</span>
<span class="sd">        - copy=False: original instance (no copy at all)</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data : object (column-like sequence)</span>
<span class="sd">            Input column data</span>
<span class="sd">        copy : bool</span>
<span class="sd">            Make a copy</span>
<span class="sd">        default_name : str</span>
<span class="sd">            Default name</span>
<span class="sd">        dtype : np.dtype or None</span>
<span class="sd">            Data dtype</span>
<span class="sd">        name : str or None</span>
<span class="sd">            Column name</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        col : Column, MaskedColumn, mixin-column type</span>
<span class="sd">            Object that can be used as a column in self</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">data_is_mixin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_mixin_for_table</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="n">masked_col_cls</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ColumnClass</span>
            <span class="k">if</span> <span class="nb">issubclass</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ColumnClass</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">MaskedColumn</span><span class="p">)</span>
            <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">MaskedColumn</span>
        <span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">data0_is_mixin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_mixin_for_table</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="c1"># Need broad exception, cannot predict what data[0] raises for arbitrary data</span>
            <span class="n">data0_is_mixin</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># If the data is not an instance of Column or a mixin class, we can</span>
        <span class="c1"># check the registry of mixin &#39;handlers&#39; to see if the column can be</span>
        <span class="c1"># converted to a mixin class</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">handler</span> <span class="o">:=</span> <span class="n">get_mixin_handler</span><span class="p">(</span><span class="n">data</span><span class="p">))</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">original_data</span> <span class="o">=</span> <span class="n">data</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">handler</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">data_is_mixin</span> <span class="o">:=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_mixin_for_table</span><span class="p">(</span><span class="n">data</span><span class="p">)):</span>
                <span class="n">fully_qualified_name</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">original_data</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__module__</span>
                    <span class="o">+</span> <span class="s2">&quot;.&quot;</span>
                    <span class="o">+</span> <span class="n">original_data</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span>
                <span class="p">)</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="s2">&quot;Mixin handler for object of type &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">fully_qualified_name</span><span class="si">}</span><span class="s2"> &quot;</span>
                    <span class="s2">&quot;did not return a valid mixin column&quot;</span>
                <span class="p">)</span>

        <span class="c1"># Get the final column name using precedence.  Some objects may not</span>
        <span class="c1"># have an info attribute. Also avoid creating info as a side effect.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">name</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">Column</span><span class="p">):</span>
                <span class="n">name</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">name</span> <span class="ow">or</span> <span class="n">default_name</span>
            <span class="k">elif</span> <span class="s2">&quot;info&quot;</span> <span class="ow">in</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="s2">&quot;__dict__&quot;</span><span class="p">,</span> <span class="p">()):</span>
                <span class="n">name</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">info</span><span class="o">.</span><span class="n">name</span> <span class="ow">or</span> <span class="n">default_name</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">name</span> <span class="o">=</span> <span class="n">default_name</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">Column</span><span class="p">):</span>
            <span class="c1"># If self.ColumnClass is a subclass of col, then &quot;upgrade&quot; to ColumnClass,</span>
            <span class="c1"># otherwise just use the original class.  The most common case is a</span>
            <span class="c1"># table with masked=True and ColumnClass=MaskedColumn.  Then a Column</span>
            <span class="c1"># gets upgraded to MaskedColumn, but the converse (pre-4.0) behavior</span>
            <span class="c1"># of downgrading from MaskedColumn to Column (for non-masked table)</span>
            <span class="c1"># does not happen.</span>
            <span class="n">col_cls</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_col_cls_for_table</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">data_is_mixin</span><span class="p">:</span>
            <span class="c1"># Copy the mixin column attributes if they exist since the copy below</span>
            <span class="c1"># may not get this attribute. If not copying, take a slice</span>
            <span class="c1"># to ensure we get a new instance and we do not share metadata</span>
            <span class="c1"># like info.</span>
            <span class="n">col</span> <span class="o">=</span> <span class="n">col_copy</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">copy_indices</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_init_indices</span><span class="p">)</span> <span class="k">if</span> <span class="n">copy</span> <span class="k">else</span> <span class="n">data</span><span class="p">[:]</span>
            <span class="n">col</span><span class="o">.</span><span class="n">info</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
            <span class="k">return</span> <span class="n">col</span>

        <span class="k">elif</span> <span class="n">data0_is_mixin</span><span class="p">:</span>
            <span class="c1"># Handle case of a sequence of a mixin, e.g. [1*u.m, 2*u.m].</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">col</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
                <span class="n">col</span><span class="o">.</span><span class="n">info</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
                <span class="k">return</span> <span class="n">col</span>
            <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                <span class="c1"># If that didn&#39;t work for some reason, just turn it into np.array of object</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
                <span class="n">col_cls</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ColumnClass</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">,</span> <span class="n">Masked</span><span class="p">)):</span>
            <span class="c1"># Require that col_cls be a subclass of MaskedColumn, remembering</span>
            <span class="c1"># that ColumnClass could be a user-defined subclass (though more-likely</span>
            <span class="c1"># could be MaskedColumn).</span>
            <span class="n">col_cls</span> <span class="o">=</span> <span class="n">masked_col_cls</span>

        <span class="k">elif</span> <span class="n">data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Special case for data passed as the None object (for broadcasting</span>
            <span class="c1"># to an object column). Need to turn data into numpy `None` scalar</span>
            <span class="c1"># object, otherwise `Column` interprets data=None as no data instead</span>
            <span class="c1"># of a object column of `None`.</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
            <span class="n">col_cls</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ColumnClass</span>

        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="s2">&quot;dtype&quot;</span><span class="p">):</span>
            <span class="c1"># `data` is none of the above, convert to numpy array or MaskedArray</span>
            <span class="c1"># assuming only that it is a scalar or sequence or N-d nested</span>
            <span class="c1"># sequence. This function is relatively intricate and tries to</span>
            <span class="c1"># maintain performance for common cases while handling things like</span>
            <span class="c1"># list input with embedded np.ma.masked entries. If `data` is a</span>
            <span class="c1"># scalar then it gets returned unchanged so the original object gets</span>
            <span class="c1"># passed to `Column` later.</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">_convert_sequence_data_to_array</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">dtype</span><span class="p">)</span>
            <span class="n">copy</span> <span class="o">=</span> <span class="n">COPY_IF_NEEDED</span>  <span class="c1"># Already made a copy above</span>
            <span class="n">col_cls</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">masked_col_cls</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">)</span>
                <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">ColumnClass</span>
            <span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">col_cls</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ColumnClass</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">col</span> <span class="o">=</span> <span class="n">col_cls</span><span class="p">(</span>
                <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span>
                <span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span>
                <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span>
                <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span>
                <span class="n">copy_indices</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_init_indices</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="c1"># Broad exception class since we don&#39;t know what might go wrong</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;unable to convert data to Column for Table&quot;</span><span class="p">)</span>

        <span class="n">col</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_convert_col_for_table</span><span class="p">(</span><span class="n">col</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">col</span>

    <span class="k">def</span> <span class="nf">_init_from_ndarray</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">names</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">n_cols</span><span class="p">,</span> <span class="n">copy</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize table from an ndarray structured array.&quot;&quot;&quot;</span>
        <span class="n">data_names</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span> <span class="ow">or</span> <span class="n">_auto_names</span><span class="p">(</span><span class="n">n_cols</span><span class="p">)</span>
        <span class="n">struct</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="n">name</span> <span class="ow">or</span> <span class="n">data_names</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">name</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">names</span><span class="p">)]</span>

        <span class="n">cols</span> <span class="o">=</span> <span class="p">(</span>
            <span class="p">[</span><span class="n">data</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">data_names</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">struct</span>
            <span class="k">else</span> <span class="p">[</span><span class="n">data</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_cols</span><span class="p">)]</span>
        <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_init_from_list</span><span class="p">(</span><span class="n">cols</span><span class="p">,</span> <span class="n">names</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">n_cols</span><span class="p">,</span> <span class="n">copy</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_init_from_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">names</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">n_cols</span><span class="p">,</span> <span class="n">copy</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize table from a dictionary of columns.&quot;&quot;&quot;</span>
        <span class="n">data_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">data</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">names</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_init_from_list</span><span class="p">(</span><span class="n">data_list</span><span class="p">,</span> <span class="n">names</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">n_cols</span><span class="p">,</span> <span class="n">copy</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_col_cls_for_table</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">col</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get the correct column class to use for upgrading any Column-like object.</span>

<span class="sd">        For a masked table, ensure any Column-like object is a subclass</span>
<span class="sd">        of the table MaskedColumn.</span>

<span class="sd">        For unmasked table, ensure any MaskedColumn-like object is a subclass</span>
<span class="sd">        of the table MaskedColumn.  If not a MaskedColumn, then ensure that any</span>
<span class="sd">        Column-like object is a subclass of the table Column.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">col_cls</span> <span class="o">=</span> <span class="n">col</span><span class="o">.</span><span class="vm">__class__</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">masked</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">Column</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">MaskedColumn</span><span class="p">):</span>
                <span class="n">col_cls</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">MaskedColumn</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">MaskedColumn</span><span class="p">):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">MaskedColumn</span><span class="p">):</span>
                    <span class="n">col_cls</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">MaskedColumn</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">Column</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Column</span><span class="p">):</span>
                <span class="n">col_cls</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Column</span>

        <span class="k">return</span> <span class="n">col_cls</span>

    <span class="k">def</span> <span class="nf">_convert_col_for_table</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">col</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Make sure that all Column objects have correct base class for this type of</span>
<span class="sd">        Table.  For a base Table this most commonly means setting to</span>
<span class="sd">        MaskedColumn if the table is masked.  Table subclasses like QTable</span>
<span class="sd">        override this method.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">Column</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ColumnClass</span><span class="p">):</span>
            <span class="n">col_cls</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_col_cls_for_table</span><span class="p">(</span><span class="n">col</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">col_cls</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">col</span><span class="o">.</span><span class="vm">__class__</span><span class="p">:</span>
                <span class="n">col</span> <span class="o">=</span> <span class="n">col_cls</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">COPY_IF_NEEDED</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">col</span>

    <span class="k">def</span> <span class="nf">_init_from_cols</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cols</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize table from a list of Column or mixin objects.&quot;&quot;&quot;</span>
        <span class="n">lengths</span> <span class="o">=</span> <span class="p">{</span><span class="nb">len</span><span class="p">(</span><span class="n">col</span><span class="p">)</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">cols</span><span class="p">}</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">lengths</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Inconsistent data column lengths: </span><span class="si">{</span><span class="n">lengths</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># Make sure that all Column-based objects have correct class.  For</span>
        <span class="c1"># plain Table this is self.ColumnClass, but for instance QTable will</span>
        <span class="c1"># convert columns with units to a Quantity mixin.</span>
        <span class="n">newcols</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_convert_col_for_table</span><span class="p">(</span><span class="n">col</span><span class="p">)</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">cols</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_make_table_from_cols</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">newcols</span><span class="p">)</span>

        <span class="c1"># Deduplicate indices.  It may happen that after pickling or when</span>
        <span class="c1"># initing from an existing table that column indices which had been</span>
        <span class="c1"># references to a single index object got *copied* into an independent</span>
        <span class="c1"># object.  This results in duplicates which will cause downstream problems.</span>
        <span class="n">index_dict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">itercols</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">index</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">col</span><span class="o">.</span><span class="n">info</span><span class="o">.</span><span class="n">indices</span> <span class="ow">or</span> <span class="p">[]):</span>
                <span class="n">names</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">ind_col</span><span class="o">.</span><span class="n">info</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">ind_col</span> <span class="ow">in</span> <span class="n">index</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">names</span> <span class="ow">in</span> <span class="n">index_dict</span><span class="p">:</span>
                    <span class="n">col</span><span class="o">.</span><span class="n">info</span><span class="o">.</span><span class="n">indices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">index_dict</span><span class="p">[</span><span class="n">names</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">index_dict</span><span class="p">[</span><span class="n">names</span><span class="p">]</span> <span class="o">=</span> <span class="n">index</span>

    <span class="k">def</span> <span class="nf">_new_from_slice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">slice_</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create a new table as a referenced slice from self.&quot;&quot;&quot;</span>
        <span class="n">table</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">masked</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">masked</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">meta</span><span class="p">:</span>
            <span class="n">table</span><span class="o">.</span><span class="n">meta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">meta</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>  <span class="c1"># Shallow copy for slice</span>
        <span class="n">table</span><span class="o">.</span><span class="n">primary_key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">primary_key</span>

        <span class="n">newcols</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="n">newcol</span> <span class="o">=</span> <span class="n">col</span><span class="p">[</span><span class="n">slice_</span><span class="p">]</span>

            <span class="c1"># Note in line below, use direct attribute access to col.indices for Column</span>
            <span class="c1"># instances instead of the generic col.info.indices.  This saves about 4 usec</span>
            <span class="c1"># per column.</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">col</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">Column</span><span class="p">)</span> <span class="k">else</span> <span class="n">col</span><span class="o">.</span><span class="n">info</span><span class="p">)</span><span class="o">.</span><span class="n">indices</span><span class="p">:</span>
                <span class="c1"># TODO : as far as I can tell the only purpose of setting _copy_indices</span>
                <span class="c1"># here is to communicate that to the initial test in `slice_indices`.</span>
                <span class="c1"># Why isn&#39;t that just sent as an arg to the function?</span>
                <span class="n">col</span><span class="o">.</span><span class="n">info</span><span class="o">.</span><span class="n">_copy_indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_copy_indices</span>
                <span class="n">newcol</span> <span class="o">=</span> <span class="n">col</span><span class="o">.</span><span class="n">info</span><span class="o">.</span><span class="n">slice_indices</span><span class="p">(</span><span class="n">newcol</span><span class="p">,</span> <span class="n">slice_</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">col</span><span class="p">))</span>

                <span class="c1"># Don&#39;t understand why this is forcing a value on the original column.</span>
                <span class="c1"># Normally col.info does not even have a _copy_indices attribute.  Tests</span>
                <span class="c1"># still pass if this line is deleted.  (Each col.info attribute access</span>
                <span class="c1"># is expensive).</span>
                <span class="n">col</span><span class="o">.</span><span class="n">info</span><span class="o">.</span><span class="n">_copy_indices</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="n">newcols</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">newcol</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_make_table_from_cols</span><span class="p">(</span>
            <span class="n">table</span><span class="p">,</span> <span class="n">newcols</span><span class="p">,</span> <span class="n">verify</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">table</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_make_table_from_cols</span><span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="n">cols</span><span class="p">,</span> <span class="n">verify</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Make ``table`` in-place so that it represents the given list of ``cols``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">names</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="n">col</span><span class="o">.</span><span class="n">info</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">cols</span><span class="p">]</span>

        <span class="c1"># Note: we do not test for len(names) == len(cols) if names is not None.  In that</span>
        <span class="c1"># case the function is being called by from &quot;trusted&quot; source (e.g. right above here)</span>
        <span class="c1"># that is assumed to provide valid inputs.  In that case verify=False.</span>

        <span class="k">if</span> <span class="n">verify</span><span class="p">:</span>
            <span class="k">if</span> <span class="kc">None</span> <span class="ow">in</span> <span class="n">names</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Cannot have None for column name&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">names</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">names</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Duplicate column names&quot;</span><span class="p">)</span>

        <span class="n">table</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="n">table</span><span class="o">.</span><span class="n">TableColumns</span><span class="p">(</span>
            <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">col</span><span class="p">)</span> <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">col</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="n">cols</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">cols</span><span class="p">:</span>
            <span class="n">table</span><span class="o">.</span><span class="n">_set_col_parent_table_and_mask</span><span class="p">(</span><span class="n">col</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_set_col_parent_table_and_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">col</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set ``col.parent_table = self`` and force ``col`` to have ``mask``</span>
<span class="sd">        attribute if the table is masked and ``col.mask`` does not exist.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># For Column instances it is much faster to do direct attribute access</span>
        <span class="c1"># instead of going through .info</span>
        <span class="n">col_info</span> <span class="o">=</span> <span class="n">col</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">Column</span><span class="p">)</span> <span class="k">else</span> <span class="n">col</span><span class="o">.</span><span class="n">info</span>
        <span class="n">col_info</span><span class="o">.</span><span class="n">parent_table</span> <span class="o">=</span> <span class="bp">self</span>

        <span class="c1"># Legacy behavior for masked table</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">masked</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="s2">&quot;mask&quot;</span><span class="p">):</span>
            <span class="n">col</span><span class="o">.</span><span class="n">mask</span> <span class="o">=</span> <span class="n">FalseArray</span><span class="p">(</span><span class="n">col</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">itercols</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Iterate over the columns of this table.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        To iterate over the columns of a table::</span>

<span class="sd">            &gt;&gt;&gt; t = Table([[1], [2]])</span>
<span class="sd">            &gt;&gt;&gt; for col in t.itercols():</span>
<span class="sd">            ...     print(col)</span>
<span class="sd">            col0</span>
<span class="sd">            ----</span>
<span class="sd">               1</span>
<span class="sd">            col1</span>
<span class="sd">            ----</span>
<span class="sd">               2</span>

<span class="sd">        Using ``itercols()`` is similar to  ``for col in t.columns.values()``</span>
<span class="sd">        but is syntactically preferred.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">colname</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="k">yield</span> <span class="bp">self</span><span class="p">[</span><span class="n">colname</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_base_repr_</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">html</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">descr_vals</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">max_width</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">tableid</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">show_dtype</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">max_lines</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">tableclass</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="k">if</span> <span class="n">descr_vals</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">descr_vals</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">]</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">masked</span><span class="p">:</span>
                <span class="n">descr_vals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;masked=True&quot;</span><span class="p">)</span>
            <span class="n">descr_vals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;length=</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">descr</span> <span class="o">=</span> <span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">descr_vals</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">html</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">astropy.utils.xml.writer</span> <span class="kn">import</span> <span class="n">xml_escape</span>

            <span class="n">descr</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;&lt;i&gt;</span><span class="si">{</span><span class="n">xml_escape</span><span class="p">(</span><span class="n">descr</span><span class="p">)</span><span class="si">}</span><span class="s2">&lt;/i&gt;</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">descr</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;&lt;</span><span class="si">{</span><span class="n">descr</span><span class="si">}</span><span class="s2">&gt;</span><span class="se">\n</span><span class="s2">&quot;</span>

        <span class="k">if</span> <span class="n">tableid</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">tableid</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;table</span><span class="si">{</span><span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>

        <span class="n">data_lines</span><span class="p">,</span> <span class="n">outs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">formatter</span><span class="o">.</span><span class="n">_pformat_table</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">tableid</span><span class="o">=</span><span class="n">tableid</span><span class="p">,</span>
            <span class="n">html</span><span class="o">=</span><span class="n">html</span><span class="p">,</span>
            <span class="n">max_width</span><span class="o">=</span><span class="n">max_width</span><span class="p">,</span>
            <span class="n">show_name</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">show_unit</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">show_dtype</span><span class="o">=</span><span class="n">show_dtype</span><span class="p">,</span>
            <span class="n">max_lines</span><span class="o">=</span><span class="n">max_lines</span><span class="p">,</span>
            <span class="n">tableclass</span><span class="o">=</span><span class="n">tableclass</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">out</span> <span class="o">=</span> <span class="n">descr</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">data_lines</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">out</span>

    <span class="k">def</span> <span class="nf">_repr_html_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_base_repr_</span><span class="p">(</span>
            <span class="n">html</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">max_width</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">tableclass</span><span class="o">=</span><span class="n">conf</span><span class="o">.</span><span class="n">default_notebook_table_class</span>
        <span class="p">)</span>
        <span class="c1"># Wrap &lt;table&gt; in &lt;div&gt;. This follows the pattern in pandas and allows</span>
        <span class="c1"># table to be scrollable horizontally in VS Code notebook display.</span>
        <span class="n">out</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;&lt;div&gt;</span><span class="si">{</span><span class="n">out</span><span class="si">}</span><span class="s2">&lt;/div&gt;&quot;</span>
        <span class="k">return</span> <span class="n">out</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_base_repr_</span><span class="p">(</span><span class="n">html</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">max_width</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pformat</span><span class="p">())</span>

    <span class="k">def</span> <span class="fm">__bytes__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s2">&quot;utf-8&quot;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">has_mixin_columns</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        True if table has any mixin columns (defined as columns that are not Column</span>
<span class="sd">        subclasses).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">any</span><span class="p">(</span><span class="n">has_info_class</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">MixinInfo</span><span class="p">)</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">has_masked_columns</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;True if table has any ``MaskedColumn`` columns.</span>

<span class="sd">        This does not check for mixin columns that may have masked values, use the</span>
<span class="sd">        ``has_masked_values`` property in that case.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">any</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">MaskedColumn</span><span class="p">)</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">itercols</span><span class="p">())</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">has_masked_values</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;True if column in the table has values which are masked.</span>

<span class="sd">        This may be relatively slow for large tables as it requires checking the mask</span>
<span class="sd">        values of each column.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">any</span><span class="p">(</span><span class="nb">hasattr</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="s2">&quot;mask&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">col</span><span class="o">.</span><span class="n">mask</span><span class="p">)</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">itercols</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">_is_mixin_for_table</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">col</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determine if ``col`` should be added to the table directly as</span>
<span class="sd">        a mixin column.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">BaseColumn</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="c1"># Is it a mixin but not [Masked]Quantity (which gets converted to</span>
        <span class="c1"># [Masked]Column with unit set).</span>
        <span class="k">return</span> <span class="n">has_info_class</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">MixinInfo</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">has_info_class</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">QuantityInfo</span><span class="p">)</span>

    <span class="nd">@format_doc</span><span class="p">(</span><span class="n">_pprint_docs</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">pprint</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">max_lines</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">max_width</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">show_name</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">show_unit</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">show_dtype</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">align</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Print a formatted string representation of the table.</span>

<span class="sd">        If no value of ``max_lines`` is supplied then the height of the</span>
<span class="sd">        screen terminal is used to set ``max_lines``.  If the terminal</span>
<span class="sd">        height cannot be determined then the default is taken from the</span>
<span class="sd">        configuration item ``astropy.conf.max_lines``.  If a negative</span>
<span class="sd">        value of ``max_lines`` is supplied then there is no line limit</span>
<span class="sd">        applied.</span>

<span class="sd">        The same applies for max_width except the configuration item is</span>
<span class="sd">        ``astropy.conf.max_width``.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">lines</span><span class="p">,</span> <span class="n">outs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">formatter</span><span class="o">.</span><span class="n">_pformat_table</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">max_lines</span><span class="p">,</span>
            <span class="n">max_width</span><span class="p">,</span>
            <span class="n">show_name</span><span class="o">=</span><span class="n">show_name</span><span class="p">,</span>
            <span class="n">show_unit</span><span class="o">=</span><span class="n">show_unit</span><span class="p">,</span>
            <span class="n">show_dtype</span><span class="o">=</span><span class="n">show_dtype</span><span class="p">,</span>
            <span class="n">align</span><span class="o">=</span><span class="n">align</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">outs</span><span class="p">[</span><span class="s2">&quot;show_length&quot;</span><span class="p">]:</span>
            <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Length = </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="si">}</span><span class="s2"> rows&quot;</span><span class="p">)</span>

        <span class="n">n_header</span> <span class="o">=</span> <span class="n">outs</span><span class="p">[</span><span class="s2">&quot;n_header&quot;</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">line</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">lines</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n_header</span><span class="p">:</span>
                <span class="n">color_print</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="s2">&quot;red&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>

    <span class="nd">@format_doc</span><span class="p">(</span><span class="n">_pprint_docs</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">pprint_all</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">max_lines</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">max_width</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">show_name</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">show_unit</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">show_dtype</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">align</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Print a formatted string representation of the entire table.</span>

<span class="sd">        This method is the same as `astropy.table.Table.pprint` except that</span>
<span class="sd">        the default ``max_lines`` and ``max_width`` are both -1 so that by</span>
<span class="sd">        default the entire table is printed instead of restricting to the size</span>
<span class="sd">        of the screen terminal.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">pprint</span><span class="p">(</span>
            <span class="n">max_lines</span><span class="p">,</span> <span class="n">max_width</span><span class="p">,</span> <span class="n">show_name</span><span class="p">,</span> <span class="n">show_unit</span><span class="p">,</span> <span class="n">show_dtype</span><span class="p">,</span> <span class="n">align</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_make_index_row_display_table</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index_row_name</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">index_row_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="n">idx_col</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ColumnClass</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">index_row_name</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)))</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">([</span><span class="n">idx_col</span><span class="p">]</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">values</span><span class="p">()),</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>

    <span class="nd">@deprecated</span><span class="p">(</span>
        <span class="s2">&quot;6.1&quot;</span><span class="p">,</span>
        <span class="n">message</span><span class="o">=</span><span class="s2">&quot;&quot;&quot;show_in_notebook() is deprecated as of 6.1 and to create</span>
<span class="s2">         interactive tables it is recommended to use dedicated tools like:</span>
<span class="s2">         - https://github.com/bloomberg/ipydatagrid</span>
<span class="s2">         - https://docs.bokeh.org/en/latest/docs/user_guide/interaction/widgets.html#datatable</span>
<span class="s2">         - https://dash.plotly.com/datatable&quot;&quot;&quot;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="k">def</span> <span class="nf">show_in_notebook</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">tableid</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">css</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">display_length</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span>
        <span class="n">table_class</span><span class="o">=</span><span class="s2">&quot;astropy-default&quot;</span><span class="p">,</span>
        <span class="n">show_row_index</span><span class="o">=</span><span class="s2">&quot;idx&quot;</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Render the table in HTML and show it in the IPython notebook.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        tableid : str or None</span>
<span class="sd">            An html ID tag for the table.  Default is ``table{id}-XXX``, where</span>
<span class="sd">            id is the unique integer id of the table object, id(self), and XXX</span>
<span class="sd">            is a random number to avoid conflicts when printing the same table</span>
<span class="sd">            multiple times.</span>
<span class="sd">        table_class : str or None</span>
<span class="sd">            A string with a list of HTML classes used to style the table.</span>
<span class="sd">            The special default string (&#39;astropy-default&#39;) means that the string</span>
<span class="sd">            will be retrieved from the configuration item</span>
<span class="sd">            ``astropy.table.default_notebook_table_class``. Note that these</span>
<span class="sd">            table classes may make use of bootstrap, as this is loaded with the</span>
<span class="sd">            notebook.  See `this page &lt;https://getbootstrap.com/css/#tables&gt;`_</span>
<span class="sd">            for the list of classes.</span>
<span class="sd">        css : str</span>
<span class="sd">            A valid CSS string declaring the formatting for the table. Defaults</span>
<span class="sd">            to ``astropy.table.jsviewer.DEFAULT_CSS_NB``.</span>
<span class="sd">        display_length : int, optional</span>
<span class="sd">            Number or rows to show. Defaults to 50.</span>
<span class="sd">        show_row_index : str or False</span>
<span class="sd">            If this does not evaluate to False, a column with the given name</span>
<span class="sd">            will be added to the version of the table that gets displayed.</span>
<span class="sd">            This new column shows the index of the row in the table itself,</span>
<span class="sd">            even when the displayed table is re-sorted by another column. Note</span>
<span class="sd">            that if a column with this name already exists, this option will be</span>
<span class="sd">            ignored. Defaults to &quot;idx&quot;.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Currently, unlike `show_in_browser` (with ``jsviewer=True``), this</span>
<span class="sd">        method needs to access online javascript code repositories.  This is due</span>
<span class="sd">        to modern browsers&#39; limitations on accessing local files.  Hence, if you</span>
<span class="sd">        call this method while offline (and don&#39;t have a cached version of</span>
<span class="sd">        jquery and jquery.dataTables), you will not get the jsviewer features.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">IPython.display</span> <span class="kn">import</span> <span class="n">HTML</span>

        <span class="kn">from</span> <span class="nn">.jsviewer</span> <span class="kn">import</span> <span class="n">JSViewer</span>

        <span class="k">if</span> <span class="n">tableid</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">tableid</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;table</span><span class="si">{</span><span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mf">1e6</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>

        <span class="n">jsv</span> <span class="o">=</span> <span class="n">JSViewer</span><span class="p">(</span><span class="n">display_length</span><span class="o">=</span><span class="n">display_length</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">show_row_index</span><span class="p">:</span>
            <span class="n">display_table</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_make_index_row_display_table</span><span class="p">(</span><span class="n">show_row_index</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">display_table</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">if</span> <span class="n">table_class</span> <span class="o">==</span> <span class="s2">&quot;astropy-default&quot;</span><span class="p">:</span>
            <span class="n">table_class</span> <span class="o">=</span> <span class="n">conf</span><span class="o">.</span><span class="n">default_notebook_table_class</span>
        <span class="n">html</span> <span class="o">=</span> <span class="n">display_table</span><span class="o">.</span><span class="n">_base_repr_</span><span class="p">(</span>
            <span class="n">html</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">max_width</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span>
            <span class="n">tableid</span><span class="o">=</span><span class="n">tableid</span><span class="p">,</span>
            <span class="n">max_lines</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span>
            <span class="n">show_dtype</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">tableclass</span><span class="o">=</span><span class="n">table_class</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">columns</span> <span class="o">=</span> <span class="n">display_table</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>
        <span class="n">sortable_columns</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">col</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">columns</span><span class="p">)</span> <span class="k">if</span> <span class="n">col</span><span class="o">.</span><span class="n">info</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="ow">in</span> <span class="s2">&quot;iufc&quot;</span>
        <span class="p">]</span>
        <span class="n">html</span> <span class="o">+=</span> <span class="n">jsv</span><span class="o">.</span><span class="n">ipynb</span><span class="p">(</span><span class="n">tableid</span><span class="p">,</span> <span class="n">css</span><span class="o">=</span><span class="n">css</span><span class="p">,</span> <span class="n">sort_columns</span><span class="o">=</span><span class="n">sortable_columns</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">HTML</span><span class="p">(</span><span class="n">html</span><span class="p">)</span>

    <span class="nd">@deprecated</span><span class="p">(</span>
        <span class="s2">&quot;6.1&quot;</span><span class="p">,</span>
        <span class="n">pending</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">message</span><span class="o">=</span><span class="s2">&quot;&quot;&quot;We are planning on deprecating show_in_browser in the future.</span>
<span class="s2">                If you are actively using this method, please let us know</span>
<span class="s2">                at https://github.com/astropy/astropy/issues/16067&quot;&quot;&quot;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="k">def</span> <span class="nf">show_in_browser</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">max_lines</span><span class="o">=</span><span class="mi">5000</span><span class="p">,</span>
        <span class="n">jsviewer</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">browser</span><span class="o">=</span><span class="s2">&quot;default&quot;</span><span class="p">,</span>
        <span class="n">jskwargs</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;use_local_files&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">},</span>
        <span class="n">tableid</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">table_class</span><span class="o">=</span><span class="s2">&quot;display compact&quot;</span><span class="p">,</span>
        <span class="n">css</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">show_row_index</span><span class="o">=</span><span class="s2">&quot;idx&quot;</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Render the table in HTML and show it in a web browser.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        max_lines : int</span>
<span class="sd">            Maximum number of rows to export to the table (set low by default</span>
<span class="sd">            to avoid memory issues, since the browser view requires duplicating</span>
<span class="sd">            the table in memory).  A negative value of ``max_lines`` indicates</span>
<span class="sd">            no row limit.</span>
<span class="sd">        jsviewer : bool</span>
<span class="sd">            If `True`, prepends some javascript headers so that the table is</span>
<span class="sd">            rendered as a `DataTables &lt;https://datatables.net&gt;`_ data table.</span>
<span class="sd">            This allows in-browser searching &amp; sorting.</span>
<span class="sd">        browser : str</span>
<span class="sd">            Any legal browser name, e.g. ``&#39;firefox&#39;``, ``&#39;chrome&#39;``,</span>
<span class="sd">            ``&#39;safari&#39;`` (for mac, you may need to use ``&#39;open -a</span>
<span class="sd">            &quot;/Applications/Google Chrome.app&quot; {}&#39;`` for Chrome).  If</span>
<span class="sd">            ``&#39;default&#39;``, will use the system default browser.</span>
<span class="sd">        jskwargs : dict</span>
<span class="sd">            Passed to the `astropy.table.JSViewer` init. Defaults to</span>
<span class="sd">            ``{&#39;use_local_files&#39;: True}`` which means that the JavaScript</span>
<span class="sd">            libraries will be served from local copies.</span>
<span class="sd">        tableid : str or None</span>
<span class="sd">            An html ID tag for the table.  Default is ``table{id}``, where id</span>
<span class="sd">            is the unique integer id of the table object, id(self).</span>
<span class="sd">        table_class : str or None</span>
<span class="sd">            A string with a list of HTML classes used to style the table.</span>
<span class="sd">            Default is &quot;display compact&quot;, and other possible values can be</span>
<span class="sd">            found in https://www.datatables.net/manual/styling/classes</span>
<span class="sd">        css : str</span>
<span class="sd">            A valid CSS string declaring the formatting for the table. Defaults</span>
<span class="sd">            to ``astropy.table.jsviewer.DEFAULT_CSS``.</span>
<span class="sd">        show_row_index : str or False</span>
<span class="sd">            If this does not evaluate to False, a column with the given name</span>
<span class="sd">            will be added to the version of the table that gets displayed.</span>
<span class="sd">            This new column shows the index of the row in the table itself,</span>
<span class="sd">            even when the displayed table is re-sorted by another column. Note</span>
<span class="sd">            that if a column with this name already exists, this option will be</span>
<span class="sd">            ignored. Defaults to &quot;idx&quot;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">os</span>
        <span class="kn">import</span> <span class="nn">tempfile</span>
        <span class="kn">import</span> <span class="nn">webbrowser</span>
        <span class="kn">from</span> <span class="nn">urllib.parse</span> <span class="kn">import</span> <span class="n">urljoin</span>
        <span class="kn">from</span> <span class="nn">urllib.request</span> <span class="kn">import</span> <span class="n">pathname2url</span>

        <span class="kn">from</span> <span class="nn">.jsviewer</span> <span class="kn">import</span> <span class="n">DEFAULT_CSS</span>

        <span class="k">if</span> <span class="n">css</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">css</span> <span class="o">=</span> <span class="n">DEFAULT_CSS</span>

        <span class="c1"># We can&#39;t use NamedTemporaryFile here because it gets deleted as</span>
        <span class="c1"># soon as it gets garbage collected.</span>
        <span class="n">tmpdir</span> <span class="o">=</span> <span class="n">tempfile</span><span class="o">.</span><span class="n">mkdtemp</span><span class="p">()</span>
        <span class="n">path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">tmpdir</span><span class="p">,</span> <span class="s2">&quot;table.html&quot;</span><span class="p">)</span>

        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">tmp</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">jsviewer</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">show_row_index</span><span class="p">:</span>
                    <span class="n">display_table</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_make_index_row_display_table</span><span class="p">(</span><span class="n">show_row_index</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">display_table</span> <span class="o">=</span> <span class="bp">self</span>
                <span class="n">display_table</span><span class="o">.</span><span class="n">write</span><span class="p">(</span>
                    <span class="n">tmp</span><span class="p">,</span>
                    <span class="nb">format</span><span class="o">=</span><span class="s2">&quot;jsviewer&quot;</span><span class="p">,</span>
                    <span class="n">css</span><span class="o">=</span><span class="n">css</span><span class="p">,</span>
                    <span class="n">max_lines</span><span class="o">=</span><span class="n">max_lines</span><span class="p">,</span>
                    <span class="n">jskwargs</span><span class="o">=</span><span class="n">jskwargs</span><span class="p">,</span>
                    <span class="n">table_id</span><span class="o">=</span><span class="n">tableid</span><span class="p">,</span>
                    <span class="n">table_class</span><span class="o">=</span><span class="n">table_class</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s2">&quot;html&quot;</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">br</span> <span class="o">=</span> <span class="n">webbrowser</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="kc">None</span> <span class="k">if</span> <span class="n">browser</span> <span class="o">==</span> <span class="s2">&quot;default&quot;</span> <span class="k">else</span> <span class="n">browser</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">webbrowser</span><span class="o">.</span><span class="n">Error</span><span class="p">:</span>
            <span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Browser &#39;</span><span class="si">{</span><span class="n">browser</span><span class="si">}</span><span class="s2">&#39; not found.&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">br</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">urljoin</span><span class="p">(</span><span class="s2">&quot;file:&quot;</span><span class="p">,</span> <span class="n">pathname2url</span><span class="p">(</span><span class="n">path</span><span class="p">)))</span>

    <span class="nd">@format_doc</span><span class="p">(</span><span class="n">_pformat_docs</span><span class="p">,</span> <span class="nb">id</span><span class="o">=</span><span class="s2">&quot;</span><span class="si">{id}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">pformat</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">max_lines</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">max_width</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">show_name</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">show_unit</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">show_dtype</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">html</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">tableid</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">align</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">tableclass</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a list of lines for the formatted string representation of</span>
<span class="sd">        the table.</span>

<span class="sd">        If no value of ``max_lines`` is supplied then the height of the</span>
<span class="sd">        screen terminal is used to set ``max_lines``.  If the terminal</span>
<span class="sd">        height cannot be determined then the default is taken from the</span>
<span class="sd">        configuration item ``astropy.conf.max_lines``.  If a negative</span>
<span class="sd">        value of ``max_lines`` is supplied then there is no line limit</span>
<span class="sd">        applied.</span>

<span class="sd">        The same applies for ``max_width`` except the configuration item  is</span>
<span class="sd">        ``astropy.conf.max_width``.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">lines</span><span class="p">,</span> <span class="n">outs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">formatter</span><span class="o">.</span><span class="n">_pformat_table</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">max_lines</span><span class="p">,</span>
            <span class="n">max_width</span><span class="p">,</span>
            <span class="n">show_name</span><span class="o">=</span><span class="n">show_name</span><span class="p">,</span>
            <span class="n">show_unit</span><span class="o">=</span><span class="n">show_unit</span><span class="p">,</span>
            <span class="n">show_dtype</span><span class="o">=</span><span class="n">show_dtype</span><span class="p">,</span>
            <span class="n">html</span><span class="o">=</span><span class="n">html</span><span class="p">,</span>
            <span class="n">tableid</span><span class="o">=</span><span class="n">tableid</span><span class="p">,</span>
            <span class="n">tableclass</span><span class="o">=</span><span class="n">tableclass</span><span class="p">,</span>
            <span class="n">align</span><span class="o">=</span><span class="n">align</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">outs</span><span class="p">[</span><span class="s2">&quot;show_length&quot;</span><span class="p">]:</span>
            <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Length = </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="si">}</span><span class="s2"> rows&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">lines</span>

    <span class="nd">@format_doc</span><span class="p">(</span><span class="n">_pformat_docs</span><span class="p">,</span> <span class="nb">id</span><span class="o">=</span><span class="s2">&quot;</span><span class="si">{id}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">pformat_all</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">max_lines</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">max_width</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">show_name</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">show_unit</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">show_dtype</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">html</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">tableid</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">align</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">tableclass</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a list of lines for the formatted string representation of</span>
<span class="sd">        the entire table.</span>

<span class="sd">        If no value of ``max_lines`` is supplied then the height of the</span>
<span class="sd">        screen terminal is used to set ``max_lines``.  If the terminal</span>
<span class="sd">        height cannot be determined then the default is taken from the</span>
<span class="sd">        configuration item ``astropy.conf.max_lines``.  If a negative</span>
<span class="sd">        value of ``max_lines`` is supplied then there is no line limit</span>
<span class="sd">        applied.</span>

<span class="sd">        The same applies for ``max_width`` except the configuration item  is</span>
<span class="sd">        ``astropy.conf.max_width``.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">pformat</span><span class="p">(</span>
            <span class="n">max_lines</span><span class="p">,</span>
            <span class="n">max_width</span><span class="p">,</span>
            <span class="n">show_name</span><span class="p">,</span>
            <span class="n">show_unit</span><span class="p">,</span>
            <span class="n">show_dtype</span><span class="p">,</span>
            <span class="n">html</span><span class="p">,</span>
            <span class="n">tableid</span><span class="p">,</span>
            <span class="n">align</span><span class="p">,</span>
            <span class="n">tableclass</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">more</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">max_lines</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">max_width</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">show_name</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">show_unit</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">show_dtype</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Interactively browse table with a paging interface.</span>

<span class="sd">        Supported keys::</span>

<span class="sd">          f, &lt;space&gt; : forward one page</span>
<span class="sd">          b : back one page</span>
<span class="sd">          r : refresh same page</span>
<span class="sd">          n : next row</span>
<span class="sd">          p : previous row</span>
<span class="sd">          &lt; : go to beginning</span>
<span class="sd">          &gt; : go to end</span>
<span class="sd">          q : quit browsing</span>
<span class="sd">          h : print this help</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        max_lines : int</span>
<span class="sd">            Maximum number of lines in table output</span>

<span class="sd">        max_width : int or None</span>
<span class="sd">            Maximum character width of output</span>

<span class="sd">        show_name : bool</span>
<span class="sd">            Include a header row for column names. Default is True.</span>

<span class="sd">        show_unit : bool</span>
<span class="sd">            Include a header row for unit.  Default is to show a row</span>
<span class="sd">            for units only if one or more columns has a defined value</span>
<span class="sd">            for the unit.</span>

<span class="sd">        show_dtype : bool</span>
<span class="sd">            Include a header row for column dtypes. Default is False.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">formatter</span><span class="o">.</span><span class="n">_more_tabcol</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">max_lines</span><span class="p">,</span>
            <span class="n">max_width</span><span class="p">,</span>
            <span class="n">show_name</span><span class="o">=</span><span class="n">show_name</span><span class="p">,</span>
            <span class="n">show_unit</span><span class="o">=</span><span class="n">show_unit</span><span class="p">,</span>
            <span class="n">show_dtype</span><span class="o">=</span><span class="n">show_dtype</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="n">item</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">)):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Row</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">)</span>
        <span class="k">elif</span> <span class="p">(</span>
            <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">and</span> <span class="n">item</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">()</span> <span class="ow">and</span> <span class="n">item</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s2">&quot;i&quot;</span>
        <span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Row</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="o">.</span><span class="n">item</span><span class="p">())</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_list_or_tuple_of_str</span><span class="p">(</span><span class="n">item</span><span class="p">):</span>
            <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span>
                <span class="p">[</span><span class="bp">self</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">item</span><span class="p">],</span> <span class="n">copy_indices</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_copy_indices</span>
            <span class="p">)</span>
            <span class="n">out</span><span class="o">.</span><span class="n">_groups</span> <span class="o">=</span> <span class="n">groups</span><span class="o">.</span><span class="n">TableGroups</span><span class="p">(</span>
                <span class="n">out</span><span class="p">,</span> <span class="n">indices</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">groups</span><span class="o">.</span><span class="n">_indices</span><span class="p">,</span> <span class="n">keys</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">groups</span><span class="o">.</span><span class="n">_keys</span>
            <span class="p">)</span>
            <span class="n">out</span><span class="o">.</span><span class="n">meta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">meta</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>  <span class="c1"># Shallow copy for meta</span>
            <span class="k">return</span> <span class="n">out</span>
        <span class="k">elif</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">and</span> <span class="n">item</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span>
            <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="nb">list</span><span class="p">))</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">item</span>
        <span class="p">):</span>
            <span class="c1"># If item is an empty array/list/tuple then return the table with no rows</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_new_from_slice</span><span class="p">([])</span>
        <span class="k">elif</span> <span class="p">(</span>
            <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="p">(</span><span class="nb">slice</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">list</span><span class="p">))</span>
            <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span>
            <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">item</span><span class="p">)</span>
        <span class="p">):</span>
            <span class="c1"># here for the many ways to give a slice; a tuple of ndarray</span>
            <span class="c1"># is produced by np.where, as in t[np.where(t[&#39;a&#39;] &gt; 2)]</span>
            <span class="c1"># For all, a new table is constructed with slice of all columns</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_new_from_slice</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Illegal type </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">item</span><span class="p">)</span><span class="si">}</span><span class="s2"> for table item access&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="c1"># If the item is a string then it must be the name of a column.</span>
        <span class="c1"># If that column doesn&#39;t already exist then create it now.</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">and</span> <span class="n">item</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">colnames</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_column</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">item</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">n_cols</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="c1"># Set an existing column by first trying to replace, and if</span>
                <span class="c1"># this fails do an in-place update.  See definition of mask</span>
                <span class="c1"># property for discussion of the _setitem_inplace attribute.</span>
                <span class="k">if</span> <span class="p">(</span>
                    <span class="ow">not</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_setitem_inplace&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
                    <span class="ow">and</span> <span class="ow">not</span> <span class="n">conf</span><span class="o">.</span><span class="n">replace_inplace</span>
                <span class="p">):</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_replace_column_warnings</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
                        <span class="k">return</span>
                    <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                        <span class="k">pass</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="n">item</span><span class="p">][:]</span> <span class="o">=</span> <span class="n">value</span>

            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">)):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_set_row</span><span class="p">(</span><span class="n">idx</span><span class="o">=</span><span class="n">item</span><span class="p">,</span> <span class="n">colnames</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">colnames</span><span class="p">,</span> <span class="n">vals</span><span class="o">=</span><span class="n">value</span><span class="p">)</span>

            <span class="k">elif</span> <span class="p">(</span>
                <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="p">(</span><span class="nb">slice</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">list</span><span class="p">))</span>
                <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span>
                <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">item</span><span class="p">)</span>
            <span class="p">):</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">Table</span><span class="p">):</span>
                    <span class="n">vals</span> <span class="o">=</span> <span class="p">(</span><span class="n">col</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">value</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>

                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">and</span> <span class="n">value</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span><span class="p">:</span>
                    <span class="n">vals</span> <span class="o">=</span> <span class="p">(</span><span class="n">value</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">value</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span><span class="p">)</span>

                <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
                    <span class="n">vals</span> <span class="o">=</span> <span class="n">itertools</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">n_cols</span><span class="p">)</span>

                <span class="k">else</span><span class="p">:</span>  <span class="c1"># Assume this is an iterable that will work</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">!=</span> <span class="n">n_cols</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                            <span class="sa">f</span><span class="s2">&quot;Right side value needs </span><span class="si">{</span><span class="n">n_cols</span><span class="si">}</span><span class="s2"> elements (one for each column)&quot;</span>
                        <span class="p">)</span>
                    <span class="n">vals</span> <span class="o">=</span> <span class="n">value</span>

                <span class="k">for</span> <span class="n">col</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">values</span><span class="p">(),</span> <span class="n">vals</span><span class="p">):</span>
                    <span class="n">col</span><span class="p">[</span><span class="n">item</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Illegal type </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">item</span><span class="p">)</span><span class="si">}</span><span class="s2"> for table item access&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__delitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">remove_column</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">remove_row</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">))</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span>
            <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">item</span>
        <span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">remove_columns</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
        <span class="k">elif</span> <span class="p">(</span>
            <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">))</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">item</span><span class="p">)</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s2">&quot;i&quot;</span>
        <span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">remove_rows</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">remove_rows</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s2">&quot;illegal key or index value&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_ipython_key_completions_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">colnames</span>

    <span class="k">def</span> <span class="nf">field</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return column[item] for recarray compatibility.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="n">item</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">masked</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_masked</span>

    <span class="nd">@masked</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">masked</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">masked</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
            <span class="s2">&quot;Masked attribute is read-only (use t = Table(t, masked=True)&quot;</span>
            <span class="s2">&quot; to convert to a masked table)&quot;</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_set_masked</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">masked</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the table masked property.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        masked : bool</span>
<span class="sd">            State of table masking (`True` or `False`)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">masked</span> <span class="ow">in</span> <span class="p">[</span><span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">None</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_masked</span> <span class="o">=</span> <span class="n">masked</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;masked should be one of True, False, None&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_column_class</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">MaskedColumn</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_masked</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">Column</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">ColumnClass</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_column_class</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Column</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_column_class</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dtype</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">([</span><span class="n">descr</span><span class="p">(</span><span class="n">col</span><span class="p">)</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">values</span><span class="p">()])</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">colnames</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_is_list_or_tuple_of_str</span><span class="p">(</span><span class="n">names</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Check that ``names`` is a tuple or list of strings.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="nb">isinstance</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="nb">list</span><span class="p">))</span>
            <span class="ow">and</span> <span class="n">names</span>
            <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">names</span><span class="p">)</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">keys</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">values</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">items</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># For performance reasons (esp. in Row) cache the first column name</span>
        <span class="c1"># and use that subsequently for the table length.  If might not be</span>
        <span class="c1"># available yet or the column might be gone now, in which case</span>
        <span class="c1"># try again in the except block.</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">OrderedDict</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_first_colname</span><span class="p">))</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">AttributeError</span><span class="p">,</span> <span class="ne">KeyError</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="mi">0</span>

            <span class="c1"># Get the first column name</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_first_colname</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">))</span>
            <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_first_colname</span><span class="p">])</span>

    <span class="k">def</span> <span class="fm">__or__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Table</span><span class="p">):</span>
            <span class="n">updated_table</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">updated_table</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">updated_table</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">NotImplemented</span>

    <span class="k">def</span> <span class="fm">__ior__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">NotImplemented</span>

    <span class="k">def</span> <span class="nf">index_column</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the positional index of column ``name``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        name : str</span>
<span class="sd">            column name</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        index : int</span>
<span class="sd">            Positional index of column ``name``.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Create a table with three columns &#39;a&#39;, &#39;b&#39; and &#39;c&#39;::</span>

<span class="sd">            &gt;&gt;&gt; t = Table([[1, 2, 3], [0.1, 0.2, 0.3], [&#39;x&#39;, &#39;y&#39;, &#39;z&#39;]],</span>
<span class="sd">            ...           names=(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;))</span>
<span class="sd">            &gt;&gt;&gt; print(t)</span>
<span class="sd">             a   b   c</span>
<span class="sd">            --- --- ---</span>
<span class="sd">              1 0.1   x</span>
<span class="sd">              2 0.2   y</span>
<span class="sd">              3 0.3   z</span>

<span class="sd">        Get index of column &#39;b&#39; of the table::</span>

<span class="sd">            &gt;&gt;&gt; t.index_column(&#39;b&#39;)</span>
<span class="sd">            1</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">colnames</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Column </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2"> does not exist&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">add_column</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">col</span><span class="p">,</span>
        <span class="n">index</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">rename_duplicate</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">default_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add a new column to the table using ``col`` as input.  If ``index``</span>
<span class="sd">        is supplied then insert column before ``index`` position</span>
<span class="sd">        in the list of columns, otherwise append column to the end</span>
<span class="sd">        of the list.</span>

<span class="sd">        The ``col`` input can be any data object which is acceptable as a</span>
<span class="sd">        `~astropy.table.Table` column object or can be converted.  This includes</span>
<span class="sd">        mixin columns and scalar or length=1 objects which get broadcast to match</span>
<span class="sd">        the table length.</span>

<span class="sd">        To add several columns at once use ``add_columns()`` or simply call</span>
<span class="sd">        ``add_column()`` for each one.  There is very little performance difference</span>
<span class="sd">        in the two approaches.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        col : object</span>
<span class="sd">            Data object for the new column</span>
<span class="sd">        index : int or None</span>
<span class="sd">            Insert column before this position or at end (default).</span>
<span class="sd">        name : str</span>
<span class="sd">            Column name</span>
<span class="sd">        rename_duplicate : bool</span>
<span class="sd">            Uniquify column name if it already exist. Default is False.</span>
<span class="sd">        copy : bool</span>
<span class="sd">            Make a copy of the new column. Default is True.</span>
<span class="sd">        default_name : str or None</span>
<span class="sd">            Name to use if both ``name`` and ``col.info.name`` are not available.</span>
<span class="sd">            Defaults to ``col{number_of_columns}``.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Create a table with two columns &#39;a&#39; and &#39;b&#39;, then create a third column &#39;c&#39;</span>
<span class="sd">        and append it to the end of the table::</span>

<span class="sd">            &gt;&gt;&gt; t = Table([[1, 2], [0.1, 0.2]], names=(&#39;a&#39;, &#39;b&#39;))</span>
<span class="sd">            &gt;&gt;&gt; col_c = Column(name=&#39;c&#39;, data=[&#39;x&#39;, &#39;y&#39;])</span>
<span class="sd">            &gt;&gt;&gt; t.add_column(col_c)</span>
<span class="sd">            &gt;&gt;&gt; print(t)</span>
<span class="sd">             a   b   c</span>
<span class="sd">            --- --- ---</span>
<span class="sd">              1 0.1   x</span>
<span class="sd">              2 0.2   y</span>

<span class="sd">        Add column &#39;d&#39; at position 1. Note that the column is inserted</span>
<span class="sd">        before the given index::</span>

<span class="sd">            &gt;&gt;&gt; t.add_column([&#39;a&#39;, &#39;b&#39;], name=&#39;d&#39;, index=1)</span>
<span class="sd">            &gt;&gt;&gt; print(t)</span>
<span class="sd">             a   d   b   c</span>
<span class="sd">            --- --- --- ---</span>
<span class="sd">              1   a 0.1   x</span>
<span class="sd">              2   b 0.2   y</span>

<span class="sd">        Add second column named &#39;b&#39; with rename_duplicate::</span>

<span class="sd">            &gt;&gt;&gt; t = Table([[1, 2], [0.1, 0.2]], names=(&#39;a&#39;, &#39;b&#39;))</span>
<span class="sd">            &gt;&gt;&gt; t.add_column(1.1, name=&#39;b&#39;, rename_duplicate=True)</span>
<span class="sd">            &gt;&gt;&gt; print(t)</span>
<span class="sd">             a   b  b_1</span>
<span class="sd">            --- --- ---</span>
<span class="sd">              1 0.1 1.1</span>
<span class="sd">              2 0.2 1.1</span>

<span class="sd">        Add an unnamed column or mixin object in the table using a default name</span>
<span class="sd">        or by specifying an explicit name with ``name``. Name can also be overridden::</span>

<span class="sd">            &gt;&gt;&gt; t = Table([[1, 2], [0.1, 0.2]], names=(&#39;a&#39;, &#39;b&#39;))</span>
<span class="sd">            &gt;&gt;&gt; t.add_column([&#39;a&#39;, &#39;b&#39;])</span>
<span class="sd">            &gt;&gt;&gt; t.add_column(col_c, name=&#39;d&#39;)</span>
<span class="sd">            &gt;&gt;&gt; print(t)</span>
<span class="sd">             a   b  col2  d</span>
<span class="sd">            --- --- ---- ---</span>
<span class="sd">              1 0.1    a   x</span>
<span class="sd">              2 0.2    b   y</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">default_name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">default_name</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;col</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>

        <span class="c1"># Convert col data to acceptable object for insertion into self.columns.</span>
        <span class="c1"># Note that along with the lines above and below, this allows broadcasting</span>
        <span class="c1"># of scalars to the correct shape for adding to table.</span>
        <span class="n">col</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_convert_data_to_col</span><span class="p">(</span>
            <span class="n">col</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span> <span class="n">default_name</span><span class="o">=</span><span class="n">default_name</span>
        <span class="p">)</span>

        <span class="c1"># Assigning a scalar column to an empty table should result in an</span>
        <span class="c1"># exception (see #3811).</span>
        <span class="k">if</span> <span class="n">col</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">()</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Empty table cannot have column set to scalar value&quot;</span><span class="p">)</span>
        <span class="c1"># Make col data shape correct for scalars.  The second test is to allow</span>
        <span class="c1"># broadcasting an N-d element to a column, e.g. t[&#39;new&#39;] = [[1, 2]].</span>
        <span class="k">elif</span> <span class="p">(</span><span class="n">col</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">()</span> <span class="ow">or</span> <span class="n">col</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">new_shape</span> <span class="o">=</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">),)</span> <span class="o">+</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="s2">&quot;shape&quot;</span><span class="p">,</span> <span class="p">())[</span><span class="mi">1</span><span class="p">:]</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
                <span class="n">col</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="n">new_shape</span><span class="p">,</span> <span class="n">subok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">ShapedLikeNDArray</span><span class="p">):</span>
                <span class="n">col</span> <span class="o">=</span> <span class="n">col</span><span class="o">.</span><span class="n">_apply</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="n">new_shape</span><span class="p">,</span> <span class="n">subok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

            <span class="c1"># broadcast_to() results in a read-only array.  Apparently it only changes</span>
            <span class="c1"># the view to look like the broadcasted array.  So copy.</span>
            <span class="n">col</span> <span class="o">=</span> <span class="n">col_copy</span><span class="p">(</span><span class="n">col</span><span class="p">)</span>

        <span class="n">name</span> <span class="o">=</span> <span class="n">col</span><span class="o">.</span><span class="n">info</span><span class="o">.</span><span class="n">name</span>

        <span class="c1"># Ensure that new column is the right length</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">col</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Inconsistent data column lengths&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">rename_duplicate</span><span class="p">:</span>
            <span class="n">orig_name</span> <span class="o">=</span> <span class="n">name</span>
            <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">while</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
                <span class="c1"># Iterate until a unique name is found</span>
                <span class="n">name</span> <span class="o">=</span> <span class="n">orig_name</span> <span class="o">+</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">col</span><span class="o">.</span><span class="n">info</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>

        <span class="c1"># Set col parent_table weakref and ensure col has mask attribute if table.masked</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_col_parent_table_and_mask</span><span class="p">(</span><span class="n">col</span><span class="p">)</span>

        <span class="c1"># Add new column as last column</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">col</span>

        <span class="k">if</span> <span class="n">index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Move the other cols to the right of the new one</span>
            <span class="n">move_names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">colnames</span><span class="p">[</span><span class="n">index</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">move_name</span> <span class="ow">in</span> <span class="n">move_names</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">move_to_end</span><span class="p">(</span><span class="n">move_name</span><span class="p">,</span> <span class="n">last</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">add_columns</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">cols</span><span class="p">,</span> <span class="n">indexes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">rename_duplicate</span><span class="o">=</span><span class="kc">False</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add a list of new columns the table using ``cols`` data objects.  If a</span>
<span class="sd">        corresponding list of ``indexes`` is supplied then insert column</span>
<span class="sd">        before each ``index`` position in the *original* list of columns,</span>
<span class="sd">        otherwise append columns to the end of the list.</span>

<span class="sd">        The ``cols`` input can include any data objects which are acceptable as</span>
<span class="sd">        `~astropy.table.Table` column objects or can be converted.  This includes</span>
<span class="sd">        mixin columns and scalar or length=1 objects which get broadcast to match</span>
<span class="sd">        the table length.</span>

<span class="sd">        From a performance perspective there is little difference between calling</span>
<span class="sd">        this method once or looping over the new columns and calling ``add_column()``</span>
<span class="sd">        for each column.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        cols : list of object</span>
<span class="sd">            List of data objects for the new columns</span>
<span class="sd">        indexes : list of int or None</span>
<span class="sd">            Insert column before this position or at end (default).</span>
<span class="sd">        names : list of str</span>
<span class="sd">            Column names</span>
<span class="sd">        copy : bool</span>
<span class="sd">            Make a copy of the new columns. Default is True.</span>
<span class="sd">        rename_duplicate : bool</span>
<span class="sd">            Uniquify new column names if they duplicate the existing ones.</span>
<span class="sd">            Default is False.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        astropy.table.hstack, update, replace_column</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Create a table with two columns &#39;a&#39; and &#39;b&#39;, then create columns &#39;c&#39; and &#39;d&#39;</span>
<span class="sd">        and append them to the end of the table::</span>

<span class="sd">            &gt;&gt;&gt; t = Table([[1, 2], [0.1, 0.2]], names=(&#39;a&#39;, &#39;b&#39;))</span>
<span class="sd">            &gt;&gt;&gt; col_c = Column(name=&#39;c&#39;, data=[&#39;x&#39;, &#39;y&#39;])</span>
<span class="sd">            &gt;&gt;&gt; col_d = Column(name=&#39;d&#39;, data=[&#39;u&#39;, &#39;v&#39;])</span>
<span class="sd">            &gt;&gt;&gt; t.add_columns([col_c, col_d])</span>
<span class="sd">            &gt;&gt;&gt; print(t)</span>
<span class="sd">             a   b   c   d</span>
<span class="sd">            --- --- --- ---</span>
<span class="sd">              1 0.1   x   u</span>
<span class="sd">              2 0.2   y   v</span>

<span class="sd">        Add column &#39;c&#39; at position 0 and column &#39;d&#39; at position 1. Note that</span>
<span class="sd">        the columns are inserted before the given position::</span>

<span class="sd">            &gt;&gt;&gt; t = Table([[1, 2], [0.1, 0.2]], names=(&#39;a&#39;, &#39;b&#39;))</span>
<span class="sd">            &gt;&gt;&gt; t.add_columns([[&#39;x&#39;, &#39;y&#39;], [&#39;u&#39;, &#39;v&#39;]], names=[&#39;c&#39;, &#39;d&#39;],</span>
<span class="sd">            ...               indexes=[0, 1])</span>
<span class="sd">            &gt;&gt;&gt; print(t)</span>
<span class="sd">             c   a   d   b</span>
<span class="sd">            --- --- --- ---</span>
<span class="sd">              x   1   u 0.1</span>
<span class="sd">              y   2   v 0.2</span>

<span class="sd">        Add second column &#39;b&#39; and column &#39;c&#39; with ``rename_duplicate``::</span>

<span class="sd">            &gt;&gt;&gt; t = Table([[1, 2], [0.1, 0.2]], names=(&#39;a&#39;, &#39;b&#39;))</span>
<span class="sd">            &gt;&gt;&gt; t.add_columns([[1.1, 1.2], [&#39;x&#39;, &#39;y&#39;]], names=(&#39;b&#39;, &#39;c&#39;),</span>
<span class="sd">            ...               rename_duplicate=True)</span>
<span class="sd">            &gt;&gt;&gt; print(t)</span>
<span class="sd">             a   b  b_1  c</span>
<span class="sd">            --- --- --- ---</span>
<span class="sd">              1 0.1 1.1  x</span>
<span class="sd">              2 0.2 1.2  y</span>

<span class="sd">        Add unnamed columns or mixin objects in the table using default names</span>
<span class="sd">        or by specifying explicit names with ``names``. Names can also be overridden::</span>

<span class="sd">            &gt;&gt;&gt; t = Table()</span>
<span class="sd">            &gt;&gt;&gt; col_b = Column(name=&#39;b&#39;, data=[&#39;u&#39;, &#39;v&#39;])</span>
<span class="sd">            &gt;&gt;&gt; t.add_columns([[1, 2], col_b])</span>
<span class="sd">            &gt;&gt;&gt; t.add_columns([[3, 4], col_b], names=[&#39;c&#39;, &#39;d&#39;])</span>
<span class="sd">            &gt;&gt;&gt; print(t)</span>
<span class="sd">            col0  b   c   d</span>
<span class="sd">            ---- --- --- ---</span>
<span class="sd">               1   u   3   u</span>
<span class="sd">               2   v   4   v</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">indexes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">indexes</span> <span class="o">=</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">)]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">cols</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">indexes</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">cols</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Number of indexes must match number of cols&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">names</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">names</span> <span class="o">=</span> <span class="p">(</span><span class="kc">None</span><span class="p">,)</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">cols</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">names</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">cols</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Number of names must match number of cols&quot;</span><span class="p">)</span>

        <span class="n">default_names</span> <span class="o">=</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;col</span><span class="si">{</span><span class="n">ii</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">cols</span><span class="p">))]</span>

        <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">indexes</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s2">&quot;stable&quot;</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_column</span><span class="p">(</span>
                <span class="n">cols</span><span class="p">[</span><span class="n">ii</span><span class="p">],</span>
                <span class="n">index</span><span class="o">=</span><span class="n">indexes</span><span class="p">[</span><span class="n">ii</span><span class="p">],</span>
                <span class="n">name</span><span class="o">=</span><span class="n">names</span><span class="p">[</span><span class="n">ii</span><span class="p">],</span>
                <span class="n">default_name</span><span class="o">=</span><span class="n">default_names</span><span class="p">[</span><span class="n">ii</span><span class="p">],</span>
                <span class="n">rename_duplicate</span><span class="o">=</span><span class="n">rename_duplicate</span><span class="p">,</span>
                <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span>
            <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_replace_column_warnings</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">col</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Same as replace_column but issues warnings under various circumstances.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">warns</span> <span class="o">=</span> <span class="n">conf</span><span class="o">.</span><span class="n">replace_warnings</span>
        <span class="n">refcount</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">old_col</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># sys.getrefcount is CPython specific and not on PyPy.</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="s2">&quot;refcount&quot;</span> <span class="ow">in</span> <span class="n">warns</span>
            <span class="ow">and</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">colnames</span>
            <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">sys</span><span class="p">,</span> <span class="s2">&quot;getrefcount&quot;</span><span class="p">)</span>
        <span class="p">):</span>
            <span class="n">refcount</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">getrefcount</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">name</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">colnames</span><span class="p">:</span>
            <span class="n">old_col</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>

        <span class="c1"># This may raise an exception (e.g. t[&#39;a&#39;] = 1) in which case none of</span>
        <span class="c1"># the downstream code runs.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">replace_column</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">col</span><span class="p">)</span>

        <span class="k">if</span> <span class="s2">&quot;always&quot;</span> <span class="ow">in</span> <span class="n">warns</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;replaced column &#39;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">&#39;&quot;</span><span class="p">,</span> <span class="n">TableReplaceWarning</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">3</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="s2">&quot;slice&quot;</span> <span class="ow">in</span> <span class="n">warns</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="c1"># Check for ndarray-subclass slice.  An unsliced instance</span>
                <span class="c1"># has an ndarray for the base while sliced has the same class</span>
                <span class="c1"># as parent.</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">old_col</span><span class="o">.</span><span class="n">base</span><span class="p">,</span> <span class="n">old_col</span><span class="o">.</span><span class="vm">__class__</span><span class="p">):</span>
                    <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;replaced column &#39;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">&#39; which looks like an array slice. &quot;</span>
                        <span class="s2">&quot;The new column no longer shares memory with the &quot;</span>
                        <span class="s2">&quot;original array.&quot;</span>
                    <span class="p">)</span>
                    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">TableReplaceWarning</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                <span class="k">pass</span>

        <span class="c1"># sys.getrefcount is CPython specific and not on PyPy.</span>
        <span class="k">if</span> <span class="s2">&quot;refcount&quot;</span> <span class="ow">in</span> <span class="n">warns</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">sys</span><span class="p">,</span> <span class="s2">&quot;getrefcount&quot;</span><span class="p">):</span>
            <span class="c1"># Did reference count change?</span>
            <span class="n">new_refcount</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">getrefcount</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">name</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">refcount</span> <span class="o">!=</span> <span class="n">new_refcount</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;replaced column &#39;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">&#39; and the number of references &quot;</span>
                    <span class="s2">&quot;to the column changed.&quot;</span>
                <span class="p">)</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">TableReplaceWarning</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>

        <span class="k">if</span> <span class="s2">&quot;attributes&quot;</span> <span class="ow">in</span> <span class="n">warns</span><span class="p">:</span>
            <span class="c1"># Any of the standard column attributes changed?</span>
            <span class="n">changed_attrs</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">new_col</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
            <span class="c1"># Check base DataInfo attributes that any column will have</span>
            <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">DataInfo</span><span class="o">.</span><span class="n">attr_names</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">old_col</span><span class="o">.</span><span class="n">info</span><span class="p">,</span> <span class="n">attr</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">new_col</span><span class="o">.</span><span class="n">info</span><span class="p">,</span> <span class="n">attr</span><span class="p">):</span>
                    <span class="n">changed_attrs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">attr</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">changed_attrs</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;replaced column &#39;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">&#39; and column attributes &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">changed_attrs</span><span class="si">}</span><span class="s2"> changed.&quot;</span>
                <span class="p">)</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">TableReplaceWarning</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">replace_column</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Replace column ``name`` with the new ``col`` object.</span>

<span class="sd">        The behavior of ``copy`` for Column objects is:</span>
<span class="sd">        - copy=True: new class instance with a copy of data and deep copy of meta</span>
<span class="sd">        - copy=False: new class instance with same data and a key-only copy of meta</span>

<span class="sd">        For mixin columns:</span>
<span class="sd">        - copy=True: new class instance with copy of data and deep copy of meta</span>
<span class="sd">        - copy=False: original instance (no copy at all)</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        name : str</span>
<span class="sd">            Name of column to replace</span>
<span class="sd">        col : `~astropy.table.Column` or `~numpy.ndarray` or sequence</span>
<span class="sd">            New column object to replace the existing column.</span>
<span class="sd">        copy : bool</span>
<span class="sd">            Make copy of the input ``col``, default=True</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        add_columns, astropy.table.hstack, update</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Replace column &#39;a&#39; with a float version of itself::</span>

<span class="sd">            &gt;&gt;&gt; t = Table([[1, 2, 3], [0.1, 0.2, 0.3]], names=(&#39;a&#39;, &#39;b&#39;))</span>
<span class="sd">            &gt;&gt;&gt; float_a = t[&#39;a&#39;].astype(float)</span>
<span class="sd">            &gt;&gt;&gt; t.replace_column(&#39;a&#39;, float_a)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">colnames</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;column name </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2"> is not in the table&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">info</span><span class="o">.</span><span class="n">indices</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;cannot replace a table index column&quot;</span><span class="p">)</span>

        <span class="n">col</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_convert_data_to_col</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_col_parent_table_and_mask</span><span class="p">(</span><span class="n">col</span><span class="p">)</span>

        <span class="c1"># Ensure that new column is the right length, unless it is the only column</span>
        <span class="c1"># in which case re-sizing is allowed.</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">col</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">name</span><span class="p">]):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;length of new column must match table length&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="fm">__setitem__</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="n">validated</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">remove_row</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Remove a row from the table.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        index : int</span>
<span class="sd">            Index of row to remove</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Create a table with three columns &#39;a&#39;, &#39;b&#39; and &#39;c&#39;::</span>

<span class="sd">            &gt;&gt;&gt; t = Table([[1, 2, 3], [0.1, 0.2, 0.3], [&#39;x&#39;, &#39;y&#39;, &#39;z&#39;]],</span>
<span class="sd">            ...           names=(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;))</span>
<span class="sd">            &gt;&gt;&gt; print(t)</span>
<span class="sd">             a   b   c</span>
<span class="sd">            --- --- ---</span>
<span class="sd">              1 0.1   x</span>
<span class="sd">              2 0.2   y</span>
<span class="sd">              3 0.3   z</span>

<span class="sd">        Remove row 1 from the table::</span>

<span class="sd">            &gt;&gt;&gt; t.remove_row(1)</span>
<span class="sd">            &gt;&gt;&gt; print(t)</span>
<span class="sd">             a   b   c</span>
<span class="sd">            --- --- ---</span>
<span class="sd">              1 0.1   x</span>
<span class="sd">              3 0.3   z</span>

<span class="sd">        To remove several rows at the same time use remove_rows.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># check the index against the types that work with np.delete</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Row index must be an integer&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">remove_rows</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">remove_rows</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">row_specifier</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Remove rows from the table.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        row_specifier : slice or int or array of int</span>
<span class="sd">            Specification for rows to remove</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Create a table with three columns &#39;a&#39;, &#39;b&#39; and &#39;c&#39;::</span>

<span class="sd">            &gt;&gt;&gt; t = Table([[1, 2, 3], [0.1, 0.2, 0.3], [&#39;x&#39;, &#39;y&#39;, &#39;z&#39;]],</span>
<span class="sd">            ...           names=(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;))</span>
<span class="sd">            &gt;&gt;&gt; print(t)</span>
<span class="sd">             a   b   c</span>
<span class="sd">            --- --- ---</span>
<span class="sd">              1 0.1   x</span>
<span class="sd">              2 0.2   y</span>
<span class="sd">              3 0.3   z</span>

<span class="sd">        Remove rows 0 and 2 from the table::</span>

<span class="sd">            &gt;&gt;&gt; t.remove_rows([0, 2])</span>
<span class="sd">            &gt;&gt;&gt; print(t)</span>
<span class="sd">             a   b   c</span>
<span class="sd">            --- --- ---</span>
<span class="sd">              2 0.2   y</span>


<span class="sd">        Note that there are no warnings if the slice operator extends</span>
<span class="sd">        outside the data::</span>

<span class="sd">            &gt;&gt;&gt; t = Table([[1, 2, 3], [0.1, 0.2, 0.3], [&#39;x&#39;, &#39;y&#39;, &#39;z&#39;]],</span>
<span class="sd">            ...           names=(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;))</span>
<span class="sd">            &gt;&gt;&gt; t.remove_rows(slice(10, 20, 1))</span>
<span class="sd">            &gt;&gt;&gt; print(t)</span>
<span class="sd">             a   b   c</span>
<span class="sd">            --- --- ---</span>
<span class="sd">              1 0.1   x</span>
<span class="sd">              2 0.2   y</span>
<span class="sd">              3 0.3   z</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Update indices</span>
        <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">indices</span><span class="p">:</span>
            <span class="n">index</span><span class="o">.</span><span class="n">remove_rows</span><span class="p">(</span><span class="n">row_specifier</span><span class="p">)</span>

        <span class="n">keep_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
        <span class="n">keep_mask</span><span class="p">[</span><span class="n">row_specifier</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="n">columns</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">TableColumns</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">col</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">newcol</span> <span class="o">=</span> <span class="n">col</span><span class="p">[</span><span class="n">keep_mask</span><span class="p">]</span>
            <span class="n">newcol</span><span class="o">.</span><span class="n">info</span><span class="o">.</span><span class="n">parent_table</span> <span class="o">=</span> <span class="bp">self</span>
            <span class="n">columns</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">newcol</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_replace_cols</span><span class="p">(</span><span class="n">columns</span><span class="p">)</span>

        <span class="c1"># Revert groups to default (ungrouped) state</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_groups&quot;</span><span class="p">):</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_groups</span>

    <span class="k">def</span> <span class="nf">iterrows</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">names</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Iterate over rows of table returning a tuple of values for each row.</span>

<span class="sd">        This method is especially useful when only a subset of columns are needed.</span>

<span class="sd">        The ``iterrows`` method can be substantially faster than using the standard</span>
<span class="sd">        Table row iteration (e.g. ``for row in tbl:``), since that returns a new</span>
<span class="sd">        ``~astropy.table.Row`` object for each row and accessing a column in that</span>
<span class="sd">        row (e.g. ``row[&#39;col0&#39;]``) is slower than tuple access.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        names : list</span>
<span class="sd">            List of column names (default to all columns if no names provided)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        rows : iterable</span>
<span class="sd">            Iterator returns tuples of row values</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Create a table with three columns &#39;a&#39;, &#39;b&#39; and &#39;c&#39;::</span>

<span class="sd">            &gt;&gt;&gt; t = Table({&#39;a&#39;: [1, 2, 3],</span>
<span class="sd">            ...            &#39;b&#39;: [1.0, 2.5, 3.0],</span>
<span class="sd">            ...            &#39;c&#39;: [&#39;x&#39;, &#39;y&#39;, &#39;z&#39;]})</span>

<span class="sd">        To iterate row-wise using column names::</span>

<span class="sd">            &gt;&gt;&gt; for a, c in t.iterrows(&#39;a&#39;, &#39;c&#39;):</span>
<span class="sd">            ...     print(a, c)</span>
<span class="sd">            1 x</span>
<span class="sd">            2 y</span>
<span class="sd">            3 z</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">names</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">colnames</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">names</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">colnames</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2"> is not a valid column name&quot;</span><span class="p">)</span>

        <span class="n">cols</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">names</span><span class="p">)</span>
        <span class="n">out</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">cols</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out</span>

    <span class="k">def</span> <span class="nf">_set_of_names_in_colnames</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">names</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return ``names`` as a set if valid, or raise a `KeyError`.</span>

<span class="sd">        ``names`` is valid if all elements in it are in ``self.colnames``.</span>
<span class="sd">        If ``names`` is a string then it is interpreted as a single column</span>
<span class="sd">        name.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">names</span> <span class="o">=</span> <span class="p">{</span><span class="n">names</span><span class="p">}</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">else</span> <span class="nb">set</span><span class="p">(</span><span class="n">names</span><span class="p">)</span>
        <span class="n">invalid_names</span> <span class="o">=</span> <span class="n">names</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">colnames</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">invalid_names</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;column &quot;</span><span class="si">{</span><span class="n">invalid_names</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span><span class="si">}</span><span class="s1">&quot; does not exist&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">invalid_names</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;columns </span><span class="si">{</span><span class="n">invalid_names</span><span class="si">}</span><span class="s2"> do not exist&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">names</span>

    <span class="k">def</span> <span class="nf">remove_column</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Remove a column from the table.</span>

<span class="sd">        This can also be done with::</span>

<span class="sd">          del table[name]</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        name : str</span>
<span class="sd">            Name of column to remove</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Create a table with three columns &#39;a&#39;, &#39;b&#39; and &#39;c&#39;::</span>

<span class="sd">            &gt;&gt;&gt; t = Table([[1, 2, 3], [0.1, 0.2, 0.3], [&#39;x&#39;, &#39;y&#39;, &#39;z&#39;]],</span>
<span class="sd">            ...           names=(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;))</span>
<span class="sd">            &gt;&gt;&gt; print(t)</span>
<span class="sd">             a   b   c</span>
<span class="sd">            --- --- ---</span>
<span class="sd">              1 0.1   x</span>
<span class="sd">              2 0.2   y</span>
<span class="sd">              3 0.3   z</span>

<span class="sd">        Remove column &#39;b&#39; from the table::</span>

<span class="sd">            &gt;&gt;&gt; t.remove_column(&#39;b&#39;)</span>
<span class="sd">            &gt;&gt;&gt; print(t)</span>
<span class="sd">             a   c</span>
<span class="sd">            --- ---</span>
<span class="sd">              1   x</span>
<span class="sd">              2   y</span>
<span class="sd">              3   z</span>

<span class="sd">        To remove several columns at the same time use remove_columns.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">remove_columns</span><span class="p">([</span><span class="n">name</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">remove_columns</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">names</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Remove several columns from the table.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        names : str or iterable of str</span>
<span class="sd">            Names of the columns to remove</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Create a table with three columns &#39;a&#39;, &#39;b&#39; and &#39;c&#39;::</span>

<span class="sd">            &gt;&gt;&gt; t = Table([[1, 2, 3], [0.1, 0.2, 0.3], [&#39;x&#39;, &#39;y&#39;, &#39;z&#39;]],</span>
<span class="sd">            ...     names=(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;))</span>
<span class="sd">            &gt;&gt;&gt; print(t)</span>
<span class="sd">             a   b   c</span>
<span class="sd">            --- --- ---</span>
<span class="sd">              1 0.1   x</span>
<span class="sd">              2 0.2   y</span>
<span class="sd">              3 0.3   z</span>

<span class="sd">        Remove columns &#39;b&#39; and &#39;c&#39; from the table::</span>

<span class="sd">            &gt;&gt;&gt; t.remove_columns([&#39;b&#39;, &#39;c&#39;])</span>
<span class="sd">            &gt;&gt;&gt; print(t)</span>
<span class="sd">             a</span>
<span class="sd">            ---</span>
<span class="sd">              1</span>
<span class="sd">              2</span>
<span class="sd">              3</span>

<span class="sd">        Specifying only a single column also works. Remove column &#39;b&#39; from the table::</span>

<span class="sd">            &gt;&gt;&gt; t = Table([[1, 2, 3], [0.1, 0.2, 0.3], [&#39;x&#39;, &#39;y&#39;, &#39;z&#39;]],</span>
<span class="sd">            ...     names=(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;))</span>
<span class="sd">            &gt;&gt;&gt; t.remove_columns(&#39;b&#39;)</span>
<span class="sd">            &gt;&gt;&gt; print(t)</span>
<span class="sd">             a   c</span>
<span class="sd">            --- ---</span>
<span class="sd">              1   x</span>
<span class="sd">              2   y</span>
<span class="sd">              3   z</span>

<span class="sd">        This gives the same as using remove_column.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_set_of_names_in_colnames</span><span class="p">(</span><span class="n">names</span><span class="p">):</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_convert_string_dtype</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">in_kind</span><span class="p">,</span> <span class="n">out_kind</span><span class="p">,</span> <span class="n">encode_decode_func</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert string-like columns to/from bytestring and unicode (internal only).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        in_kind : str</span>
<span class="sd">            Input dtype.kind</span>
<span class="sd">        out_kind : str</span>
<span class="sd">            Output dtype.kind</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">itercols</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">col</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="n">in_kind</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="c1"># This requires ASCII and is faster by a factor of up to ~8, so</span>
                    <span class="c1"># try that first.</span>
                    <span class="n">newcol</span> <span class="o">=</span> <span class="n">col</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">out_kind</span><span class="p">)</span>
                <span class="k">except</span> <span class="p">(</span><span class="ne">UnicodeEncodeError</span><span class="p">,</span> <span class="ne">UnicodeDecodeError</span><span class="p">):</span>
                    <span class="n">newcol</span> <span class="o">=</span> <span class="n">col</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">encode_decode_func</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="s2">&quot;utf-8&quot;</span><span class="p">))</span>

                    <span class="c1"># Quasi-manually copy info attributes.  Unfortunately</span>
                    <span class="c1"># DataInfo.__set__ does not do the right thing in this case</span>
                    <span class="c1"># so newcol.info = col.info does not get the old info attributes.</span>
                    <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="p">(</span>
                        <span class="n">col</span><span class="o">.</span><span class="n">info</span><span class="o">.</span><span class="n">attr_names</span> <span class="o">-</span> <span class="n">col</span><span class="o">.</span><span class="n">info</span><span class="o">.</span><span class="n">_attrs_no_copy</span> <span class="o">-</span> <span class="p">{</span><span class="s2">&quot;dtype&quot;</span><span class="p">}</span>
                    <span class="p">):</span>
                        <span class="n">value</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">col</span><span class="o">.</span><span class="n">info</span><span class="p">,</span> <span class="n">attr</span><span class="p">))</span>
                        <span class="nb">setattr</span><span class="p">(</span><span class="n">newcol</span><span class="o">.</span><span class="n">info</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

                <span class="bp">self</span><span class="p">[</span><span class="n">col</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">newcol</span>

    <span class="k">def</span> <span class="nf">convert_bytestring_to_unicode</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert bytestring columns (dtype.kind=&#39;S&#39;) to unicode (dtype.kind=&#39;U&#39;)</span>
<span class="sd">        using UTF-8 encoding.</span>

<span class="sd">        Internally this changes string columns to represent each character</span>
<span class="sd">        in the string with a 4-byte UCS-4 equivalent, so it is inefficient</span>
<span class="sd">        for memory but allows scripts to manipulate string arrays with</span>
<span class="sd">        natural syntax.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_convert_string_dtype</span><span class="p">(</span><span class="s2">&quot;S&quot;</span><span class="p">,</span> <span class="s2">&quot;U&quot;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">char</span><span class="o">.</span><span class="n">decode</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">convert_unicode_to_bytestring</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert unicode columns (dtype.kind=&#39;U&#39;) to bytestring (dtype.kind=&#39;S&#39;)</span>
<span class="sd">        using UTF-8 encoding.</span>

<span class="sd">        When exporting a unicode string array to a file, it may be desirable</span>
<span class="sd">        to encode unicode columns as bytestrings.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_convert_string_dtype</span><span class="p">(</span><span class="s2">&quot;U&quot;</span><span class="p">,</span> <span class="s2">&quot;S&quot;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">char</span><span class="o">.</span><span class="n">encode</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">keep_columns</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">names</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Keep only the columns specified (remove the others).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        names : str or iterable of str</span>
<span class="sd">            The columns to keep. All other columns will be removed.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Create a table with three columns &#39;a&#39;, &#39;b&#39; and &#39;c&#39;::</span>

<span class="sd">            &gt;&gt;&gt; t = Table([[1, 2, 3],[0.1, 0.2, 0.3],[&#39;x&#39;, &#39;y&#39;, &#39;z&#39;]],</span>
<span class="sd">            ...           names=(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;))</span>
<span class="sd">            &gt;&gt;&gt; print(t)</span>
<span class="sd">             a   b   c</span>
<span class="sd">            --- --- ---</span>
<span class="sd">              1 0.1   x</span>
<span class="sd">              2 0.2   y</span>
<span class="sd">              3 0.3   z</span>

<span class="sd">        Keep only column &#39;a&#39; of the table::</span>

<span class="sd">            &gt;&gt;&gt; t.keep_columns(&#39;a&#39;)</span>
<span class="sd">            &gt;&gt;&gt; print(t)</span>
<span class="sd">             a</span>
<span class="sd">            ---</span>
<span class="sd">              1</span>
<span class="sd">              2</span>
<span class="sd">              3</span>

<span class="sd">        Keep columns &#39;a&#39; and &#39;c&#39; of the table::</span>

<span class="sd">            &gt;&gt;&gt; t = Table([[1, 2, 3],[0.1, 0.2, 0.3],[&#39;x&#39;, &#39;y&#39;, &#39;z&#39;]],</span>
<span class="sd">            ...           names=(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;))</span>
<span class="sd">            &gt;&gt;&gt; t.keep_columns([&#39;a&#39;, &#39;c&#39;])</span>
<span class="sd">            &gt;&gt;&gt; print(t)</span>
<span class="sd">             a   c</span>
<span class="sd">            --- ---</span>
<span class="sd">              1   x</span>
<span class="sd">              2   y</span>
<span class="sd">              3   z</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_set_of_names_in_colnames</span><span class="p">(</span><span class="n">names</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">colname</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">colnames</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">colname</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">names</span><span class="p">:</span>
                <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="n">colname</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">rename_column</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">new_name</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Rename a column.</span>

<span class="sd">        This can also be done directly by setting the ``name`` attribute</span>
<span class="sd">        of the ``info`` property of the column::</span>

<span class="sd">          table[name].info.name = new_name</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        name : str</span>
<span class="sd">            The current name of the column.</span>
<span class="sd">        new_name : str</span>
<span class="sd">            The new name for the column</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Create a table with three columns &#39;a&#39;, &#39;b&#39; and &#39;c&#39;::</span>

<span class="sd">            &gt;&gt;&gt; t = Table([[1,2],[3,4],[5,6]], names=(&#39;a&#39;,&#39;b&#39;,&#39;c&#39;))</span>
<span class="sd">            &gt;&gt;&gt; print(t)</span>
<span class="sd">             a   b   c</span>
<span class="sd">            --- --- ---</span>
<span class="sd">              1   3   5</span>
<span class="sd">              2   4   6</span>

<span class="sd">        Renaming column &#39;a&#39; to &#39;aa&#39;::</span>

<span class="sd">            &gt;&gt;&gt; t.rename_column(&#39;a&#39; , &#39;aa&#39;)</span>
<span class="sd">            &gt;&gt;&gt; print(t)</span>
<span class="sd">             aa  b   c</span>
<span class="sd">            --- --- ---</span>
<span class="sd">              1   3   5</span>
<span class="sd">              2   4   6</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Column </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2"> does not exist&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">info</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">new_name</span>

    <span class="k">def</span> <span class="nf">rename_columns</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">names</span><span class="p">,</span> <span class="n">new_names</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Rename multiple columns.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        names : list, tuple</span>
<span class="sd">            A list or tuple of existing column names.</span>
<span class="sd">        new_names : list, tuple</span>
<span class="sd">            A list or tuple of new column names.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Create a table with three columns &#39;a&#39;, &#39;b&#39;, &#39;c&#39;::</span>

<span class="sd">            &gt;&gt;&gt; t = Table([[1,2],[3,4],[5,6]], names=(&#39;a&#39;,&#39;b&#39;,&#39;c&#39;))</span>
<span class="sd">            &gt;&gt;&gt; print(t)</span>
<span class="sd">              a   b   c</span>
<span class="sd">             --- --- ---</span>
<span class="sd">              1   3   5</span>
<span class="sd">              2   4   6</span>

<span class="sd">        Renaming columns &#39;a&#39; to &#39;aa&#39; and &#39;b&#39; to &#39;bb&#39;::</span>

<span class="sd">            &gt;&gt;&gt; names = (&#39;a&#39;,&#39;b&#39;)</span>
<span class="sd">            &gt;&gt;&gt; new_names = (&#39;aa&#39;,&#39;bb&#39;)</span>
<span class="sd">            &gt;&gt;&gt; t.rename_columns(names, new_names)</span>
<span class="sd">            &gt;&gt;&gt; print(t)</span>
<span class="sd">             aa  bb   c</span>
<span class="sd">            --- --- ---</span>
<span class="sd">              1   3   5</span>
<span class="sd">              2   4   6</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_list_or_tuple_of_str</span><span class="p">(</span><span class="n">names</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;input &#39;names&#39; must be a tuple or a list of column names&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_list_or_tuple_of_str</span><span class="p">(</span><span class="n">new_names</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;input &#39;new_names&#39; must be a tuple or a list of column names&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">names</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_names</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;input &#39;names&#39; and &#39;new_names&#39; list arguments must be the same length&quot;</span>
            <span class="p">)</span>

        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">new_name</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="n">new_names</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rename_column</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">new_name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_set_row</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">colnames</span><span class="p">,</span> <span class="n">vals</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">vals</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">colnames</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;right hand side must be a sequence of values with &quot;</span>
                <span class="s2">&quot;the same length as the number of selected columns&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Keep track of original values before setting each column so that</span>
        <span class="c1"># setting row can be transactional.</span>
        <span class="n">orig_vals</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">cols</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">colnames</span><span class="p">,</span> <span class="n">vals</span><span class="p">):</span>
                <span class="n">orig_vals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cols</span><span class="p">[</span><span class="n">name</span><span class="p">][</span><span class="n">idx</span><span class="p">])</span>
                <span class="n">cols</span><span class="p">[</span><span class="n">name</span><span class="p">][</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="c1"># If anything went wrong first revert the row update then raise</span>
            <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">colnames</span><span class="p">,</span> <span class="n">orig_vals</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>
                <span class="n">cols</span><span class="p">[</span><span class="n">name</span><span class="p">][</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>
            <span class="k">raise</span>

    <span class="k">def</span> <span class="nf">add_row</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vals</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Add a new row to the end of the table.</span>

<span class="sd">        The ``vals`` argument can be:</span>

<span class="sd">        sequence (e.g. tuple or list)</span>
<span class="sd">            Column values in the same order as table columns.</span>
<span class="sd">        mapping (e.g. dict)</span>
<span class="sd">            Keys corresponding to column names.  Missing values will be</span>
<span class="sd">            filled with np.zeros for the column dtype.</span>
<span class="sd">        `None`</span>
<span class="sd">            All values filled with np.zeros for the column dtype.</span>

<span class="sd">        This method requires that the Table object &quot;owns&quot; the underlying array</span>
<span class="sd">        data.  In particular one cannot add a row to a Table that was</span>
<span class="sd">        initialized with copy=False from an existing array.</span>

<span class="sd">        The ``mask`` attribute should give (if desired) the mask for the</span>
<span class="sd">        values. The type of the mask should match that of the values, i.e. if</span>
<span class="sd">        ``vals`` is an iterable, then ``mask`` should also be an iterable</span>
<span class="sd">        with the same length, and if ``vals`` is a mapping, then ``mask``</span>
<span class="sd">        should be a dictionary.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        vals : tuple, list, dict or None</span>
<span class="sd">            Use the specified values in the new row</span>
<span class="sd">        mask : tuple, list, dict or None</span>
<span class="sd">            Use the specified mask values in the new row</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Create a table with three columns &#39;a&#39;, &#39;b&#39; and &#39;c&#39;::</span>

<span class="sd">           &gt;&gt;&gt; t = Table([[1,2],[4,5],[7,8]], names=(&#39;a&#39;,&#39;b&#39;,&#39;c&#39;))</span>
<span class="sd">           &gt;&gt;&gt; print(t)</span>
<span class="sd">            a   b   c</span>
<span class="sd">           --- --- ---</span>
<span class="sd">             1   4   7</span>
<span class="sd">             2   5   8</span>

<span class="sd">        Adding a new row with entries &#39;3&#39; in &#39;a&#39;, &#39;6&#39; in &#39;b&#39; and &#39;9&#39; in &#39;c&#39;::</span>

<span class="sd">           &gt;&gt;&gt; t.add_row([3,6,9])</span>
<span class="sd">           &gt;&gt;&gt; print(t)</span>
<span class="sd">             a   b   c</span>
<span class="sd">             --- --- ---</span>
<span class="sd">             1   4   7</span>
<span class="sd">             2   5   8</span>
<span class="sd">             3   6   9</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">insert_row</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="n">vals</span><span class="p">,</span> <span class="n">mask</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">insert_row</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">vals</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Add a new row before the given ``index`` position in the table.</span>

<span class="sd">        The ``vals`` argument can be:</span>

<span class="sd">        sequence (e.g. tuple or list)</span>
<span class="sd">            Column values in the same order as table columns.</span>
<span class="sd">        mapping (e.g. dict)</span>
<span class="sd">            Keys corresponding to column names.  Missing values will be</span>
<span class="sd">            filled with np.zeros for the column dtype.</span>
<span class="sd">        `None`</span>
<span class="sd">            All values filled with np.zeros for the column dtype.</span>

<span class="sd">        The ``mask`` attribute should give (if desired) the mask for the</span>
<span class="sd">        values. The type of the mask should match that of the values, i.e. if</span>
<span class="sd">        ``vals`` is an iterable, then ``mask`` should also be an iterable</span>
<span class="sd">        with the same length, and if ``vals`` is a mapping, then ``mask``</span>
<span class="sd">        should be a dictionary.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        vals : tuple, list, dict or None</span>
<span class="sd">            Use the specified values in the new row</span>
<span class="sd">        mask : tuple, list, dict or None</span>
<span class="sd">            Use the specified mask values in the new row</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">colnames</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">colnames</span>

        <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="o">-</span><span class="n">N</span> <span class="ow">or</span> <span class="n">index</span> <span class="o">&gt;</span> <span class="n">N</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Index </span><span class="si">{</span><span class="n">index</span><span class="si">}</span><span class="s2"> is out of bounds for table with length </span><span class="si">{</span><span class="n">N</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">index</span> <span class="o">+=</span> <span class="n">N</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">vals</span><span class="p">,</span> <span class="n">Mapping</span><span class="p">)</span> <span class="ow">or</span> <span class="n">vals</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># From the vals and/or mask mappings create the corresponding lists</span>
            <span class="c1"># that have entries for each table column.</span>
            <span class="k">if</span> <span class="n">mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">Mapping</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Mismatch between type of vals and mask&quot;</span><span class="p">)</span>

            <span class="c1"># Now check that the mask is specified for the same keys as the</span>
            <span class="c1"># values, otherwise things get really confusing.</span>
            <span class="k">if</span> <span class="n">mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">set</span><span class="p">(</span><span class="n">vals</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">!=</span> <span class="nb">set</span><span class="p">(</span><span class="n">mask</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;keys in mask should match keys in vals&quot;</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">vals</span> <span class="ow">and</span> <span class="nb">any</span><span class="p">(</span><span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">colnames</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">vals</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Keys in vals must all be valid column names&quot;</span><span class="p">)</span>

            <span class="n">vals_list</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">mask_list</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">colnames</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">vals</span> <span class="ow">and</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">vals</span><span class="p">:</span>
                    <span class="n">vals_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">vals</span><span class="p">[</span><span class="n">name</span><span class="p">])</span>
                    <span class="n">mask_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">False</span> <span class="k">if</span> <span class="n">mask</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">mask</span><span class="p">[</span><span class="n">name</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">col</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
                    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="s2">&quot;dtype&quot;</span><span class="p">):</span>
                        <span class="c1"># Make a placeholder zero element of the right type which is masked.</span>
                        <span class="c1"># This assumes the appropriate insert() method will broadcast a</span>
                        <span class="c1"># numpy scalar to the right shape.</span>
                        <span class="n">vals_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">col</span><span class="o">.</span><span class="n">dtype</span><span class="p">))</span>

                        <span class="c1"># For masked table any unsupplied values are masked by default.</span>
                        <span class="n">mask_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">masked</span> <span class="ow">and</span> <span class="n">vals</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Value must be supplied for column &#39;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">&#39;&quot;</span><span class="p">)</span>

            <span class="n">vals</span> <span class="o">=</span> <span class="n">vals_list</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">mask_list</span>

        <span class="k">if</span> <span class="n">isiterable</span><span class="p">(</span><span class="n">vals</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="n">isiterable</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">Mapping</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Mismatch between type of vals and mask&quot;</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">vals</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Mismatch between number of vals and columns&quot;</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">mask</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Mismatch between number of masks and columns&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">mask</span> <span class="o">=</span> <span class="p">[</span><span class="kc">False</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Vals must be an iterable or mapping or None&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">N</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">any</span><span class="p">(</span>
            <span class="nb">isinstance</span><span class="p">(</span><span class="n">column</span><span class="p">,</span> <span class="n">BaseColumn</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">Quantity</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">column</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">values</span><span class="p">(),</span> <span class="n">vals</span><span class="p">)</span>
        <span class="p">):</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Units from inserted quantities will be ignored.&quot;</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">QTable</span><span class="p">):</span>
                <span class="n">suggested_units</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">column</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">values</span><span class="p">(),</span> <span class="n">vals</span><span class="p">):</span>
                    <span class="n">u</span> <span class="o">=</span> <span class="n">column</span><span class="o">.</span><span class="n">unit</span> <span class="ow">or</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="s2">&quot;unit&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
                    <span class="n">suggested_units</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">u</span><span class="p">)</span> <span class="k">if</span> <span class="n">u</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span><span class="p">)</span>
                <span class="k">del</span> <span class="n">u</span>

                <span class="n">msg</span> <span class="o">+=</span> <span class="p">(</span>
                    <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">If you were hoping to fill a QTable row by row, &quot;</span>
                    <span class="s2">&quot;also initialize the units before starting, for instance</span><span class="se">\n</span><span class="s2">&quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;QTable(names=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">colnames</span><span class="si">}</span><span class="s2">, units=</span><span class="si">{</span><span class="n">suggested_units</span><span class="si">}</span><span class="s2">)&quot;</span>
                <span class="p">)</span>
                <span class="k">del</span> <span class="n">suggested_units</span>

            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">category</span><span class="o">=</span><span class="ne">UserWarning</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
            <span class="k">del</span> <span class="n">msg</span>

        <span class="c1"># Insert val at index for each column</span>
        <span class="n">columns</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">TableColumns</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">mask_</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">colnames</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">values</span><span class="p">(),</span> <span class="n">vals</span><span class="p">,</span> <span class="n">mask</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="c1"># If new val is masked and the existing column does not support masking</span>
                <span class="c1"># then upgrade the column to a mask-enabled type: either the table-level</span>
                <span class="c1"># default ColumnClass or else MaskedColumn.</span>
                <span class="k">if</span> <span class="p">(</span>
                    <span class="n">mask_</span>
                    <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">Column</span><span class="p">)</span>
                    <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">MaskedColumn</span><span class="p">)</span>
                <span class="p">):</span>
                    <span class="n">col_cls</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">ColumnClass</span>
                        <span class="k">if</span> <span class="nb">issubclass</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ColumnClass</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">MaskedColumn</span><span class="p">)</span>
                        <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">MaskedColumn</span>
                    <span class="p">)</span>
                    <span class="n">col</span> <span class="o">=</span> <span class="n">col_cls</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

                <span class="n">newcol</span> <span class="o">=</span> <span class="n">col</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">newcol</span><span class="p">)</span> <span class="o">!=</span> <span class="n">N</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Incorrect length for column </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2"> after inserting </span><span class="si">{</span><span class="n">val</span><span class="si">}</span><span class="s2">&quot;</span>
                        <span class="sa">f</span><span class="s2">&quot; (expected </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">newcol</span><span class="p">)</span><span class="si">}</span><span class="s2">, got </span><span class="si">{</span><span class="n">N</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="si">}</span><span class="s2">)&quot;</span>
                    <span class="p">)</span>
                <span class="n">newcol</span><span class="o">.</span><span class="n">info</span><span class="o">.</span><span class="n">parent_table</span> <span class="o">=</span> <span class="bp">self</span>

                <span class="c1"># Set mask if needed and possible</span>
                <span class="k">if</span> <span class="n">mask_</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">newcol</span><span class="p">,</span> <span class="s2">&quot;mask&quot;</span><span class="p">):</span>
                        <span class="n">newcol</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                            <span class="sa">f</span><span class="s2">&quot;mask was supplied for column &#39;</span><span class="si">{</span><span class="n">col</span><span class="o">.</span><span class="n">info</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">&#39; &quot;</span>
                            <span class="s2">&quot;but it does not support masked values&quot;</span>
                        <span class="p">)</span>

                <span class="n">columns</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">newcol</span>

            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Unable to insert row because of exception in column &#39;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">&#39;:</span><span class="se">\n</span><span class="si">{</span><span class="n">err</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span> <span class="kn">from</span> <span class="nn">err</span>

        <span class="k">for</span> <span class="n">table_index</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">indices</span><span class="p">:</span>
            <span class="n">table_index</span><span class="o">.</span><span class="n">insert_row</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">vals</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_replace_cols</span><span class="p">(</span><span class="n">columns</span><span class="p">)</span>

        <span class="c1"># Revert groups to default (ungrouped) state</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_groups&quot;</span><span class="p">):</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_groups</span>

    <span class="k">def</span> <span class="nf">_replace_cols</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">columns</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">col</span><span class="p">,</span> <span class="n">new_col</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">values</span><span class="p">(),</span> <span class="n">columns</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
            <span class="n">new_col</span><span class="o">.</span><span class="n">info</span><span class="o">.</span><span class="n">indices</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">col</span><span class="o">.</span><span class="n">info</span><span class="o">.</span><span class="n">indices</span><span class="p">:</span>
                <span class="n">index</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="n">index</span><span class="o">.</span><span class="n">col_position</span><span class="p">(</span><span class="n">col</span><span class="o">.</span><span class="n">info</span><span class="o">.</span><span class="n">name</span><span class="p">)]</span> <span class="o">=</span> <span class="n">new_col</span>
                <span class="n">new_col</span><span class="o">.</span><span class="n">info</span><span class="o">.</span><span class="n">indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="n">columns</span>

    <span class="k">def</span> <span class="nf">setdefault</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">default</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Ensure a column named ``name`` exists.</span>

<span class="sd">        If ``name`` is already present then ``default`` is ignored.</span>
<span class="sd">        Otherwise ``default`` can be any data object which is acceptable as</span>
<span class="sd">        a `~astropy.table.Table` column object or can be converted.  This</span>
<span class="sd">        includes mixin columns and scalar or length=1 objects which get</span>
<span class="sd">        broadcast to match the table length.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        name : str</span>
<span class="sd">            Name of the column.</span>
<span class="sd">        default : object</span>
<span class="sd">            Data object for the new column.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        `~astropy.table.Column`, `~astropy.table.MaskedColumn` or mixin-column type</span>
<span class="sd">            The column named ``name`` if it is present already, or the</span>
<span class="sd">            validated ``default`` converted to a column otherwise.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        TypeError</span>
<span class="sd">            If the table is empty and ``default`` is a scalar object.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Start with a simple table::</span>

<span class="sd">          &gt;&gt;&gt; t0 = Table({&quot;a&quot;: [&quot;Ham&quot;, &quot;Spam&quot;]})</span>
<span class="sd">          &gt;&gt;&gt; t0</span>
<span class="sd">          &lt;Table length=2&gt;</span>
<span class="sd">           a</span>
<span class="sd">          str4</span>
<span class="sd">          ----</span>
<span class="sd">           Ham</span>
<span class="sd">          Spam</span>

<span class="sd">        Trying to add a column that already exists does not modify it::</span>

<span class="sd">          &gt;&gt;&gt; t0.setdefault(&quot;a&quot;, [&quot;Breakfast&quot;])</span>
<span class="sd">          &lt;Column name=&#39;a&#39; dtype=&#39;str4&#39; length=2&gt;</span>
<span class="sd">           Ham</span>
<span class="sd">          Spam</span>
<span class="sd">          &gt;&gt;&gt; t0</span>
<span class="sd">          &lt;Table length=2&gt;</span>
<span class="sd">           a</span>
<span class="sd">          str4</span>
<span class="sd">          ----</span>
<span class="sd">           Ham</span>
<span class="sd">          Spam</span>

<span class="sd">        But if the column does not exist it will be created with the</span>
<span class="sd">        default value::</span>

<span class="sd">          &gt;&gt;&gt; t0.setdefault(&quot;approved&quot;, False)</span>
<span class="sd">          &lt;Column name=&#39;approved&#39; dtype=&#39;bool&#39; length=2&gt;</span>
<span class="sd">          False</span>
<span class="sd">          False</span>
<span class="sd">          &gt;&gt;&gt; t0</span>
<span class="sd">          &lt;Table length=2&gt;</span>
<span class="sd">           a   approved</span>
<span class="sd">          str4   bool</span>
<span class="sd">          ---- --------</span>
<span class="sd">           Ham    False</span>
<span class="sd">          Spam    False</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="bp">self</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">default</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Perform a dictionary-style update and merge metadata.</span>

<span class="sd">        The argument ``other`` must be a |Table|, or something that can be used</span>
<span class="sd">        to initialize a table. Columns from (possibly converted) ``other`` are</span>
<span class="sd">        added to this table. In case of matching column names the column from</span>
<span class="sd">        this table is replaced with the one from ``other``. If ``other`` is a</span>
<span class="sd">        |Table| instance then ``|=`` is available as alternate syntax for in-place</span>
<span class="sd">        update and ``|`` can be used merge data to a new table.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : table-like</span>
<span class="sd">            Data to update this table with.</span>
<span class="sd">        copy : bool</span>
<span class="sd">            Whether the updated columns should be copies of or references to</span>
<span class="sd">            the originals.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        add_columns, astropy.table.hstack, replace_column</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Update a table with another table::</span>

<span class="sd">            &gt;&gt;&gt; t1 = Table({&#39;a&#39;: [&#39;foo&#39;, &#39;bar&#39;], &#39;b&#39;: [0., 0.]}, meta={&#39;i&#39;: 0})</span>
<span class="sd">            &gt;&gt;&gt; t2 = Table({&#39;b&#39;: [1., 2.], &#39;c&#39;: [7., 11.]}, meta={&#39;n&#39;: 2})</span>
<span class="sd">            &gt;&gt;&gt; t1.update(t2)</span>
<span class="sd">            &gt;&gt;&gt; t1</span>
<span class="sd">            &lt;Table length=2&gt;</span>
<span class="sd">             a      b       c</span>
<span class="sd">            str3 float64 float64</span>
<span class="sd">            ---- ------- -------</span>
<span class="sd">             foo     1.0     7.0</span>
<span class="sd">             bar     2.0    11.0</span>
<span class="sd">            &gt;&gt;&gt; t1.meta</span>
<span class="sd">            {&#39;i&#39;: 0, &#39;n&#39;: 2}</span>

<span class="sd">        Update a table with a dictionary::</span>

<span class="sd">            &gt;&gt;&gt; t = Table({&#39;a&#39;: [&#39;foo&#39;, &#39;bar&#39;], &#39;b&#39;: [0., 0.]})</span>
<span class="sd">            &gt;&gt;&gt; t.update({&#39;b&#39;: [1., 2.]})</span>
<span class="sd">            &gt;&gt;&gt; t</span>
<span class="sd">            &lt;Table length=2&gt;</span>
<span class="sd">             a      b</span>
<span class="sd">            str3 float64</span>
<span class="sd">            ---- -------</span>
<span class="sd">             foo     1.0</span>
<span class="sd">             bar     2.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">.operations</span> <span class="kn">import</span> <span class="n">_merge_table_meta</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Table</span><span class="p">):</span>
            <span class="n">other</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">)</span>
        <span class="n">common_cols</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">colnames</span><span class="p">)</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">colnames</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">other</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">common_cols</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">replace_column</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">add_column</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">)</span>
        <span class="n">_merge_table_meta</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="p">[</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">],</span> <span class="n">metadata_conflicts</span><span class="o">=</span><span class="s2">&quot;silent&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">argsort</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">keys</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the indices which would sort the table according to one or</span>
<span class="sd">        more key columns.  This simply calls the `numpy.argsort` function on</span>
<span class="sd">        the table with the ``order`` parameter set to ``keys``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        keys : str or list of str</span>
<span class="sd">            The column name(s) to order the table by</span>
<span class="sd">        kind : {&#39;quicksort&#39;, &#39;mergesort&#39;, &#39;heapsort&#39;, &#39;stable&#39;}, optional</span>
<span class="sd">            Sorting algorithm used by ``numpy.argsort``.</span>
<span class="sd">        reverse : bool</span>
<span class="sd">            Sort in reverse order (default=False)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        index_array : ndarray, int</span>
<span class="sd">            Array of indices that sorts the table by the specified key</span>
<span class="sd">            column(s).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">keys</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">keys</span> <span class="o">=</span> <span class="p">[</span><span class="n">keys</span><span class="p">]</span>

        <span class="c1"># use index sorted order if possible</span>
        <span class="k">if</span> <span class="n">keys</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">index</span> <span class="o">=</span> <span class="n">get_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="n">keys</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">index</span><span class="o">.</span><span class="n">sorted_data</span><span class="p">())</span>
                <span class="k">return</span> <span class="n">idx</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="n">reverse</span> <span class="k">else</span> <span class="n">idx</span>

        <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="n">keys</span><span class="p">:</span>
            <span class="c1"># For multiple keys return a structured array which gets sorted,</span>
            <span class="c1"># while for a single key return a single ndarray.  Sorting a</span>
            <span class="c1"># one-column structured array is slower than ndarray (e.g. a</span>
            <span class="c1"># factor of ~6 for a 10 million long random array), and much slower</span>
            <span class="c1"># for in principle sortable columns like Time, which get stored as</span>
            <span class="c1"># object arrays.</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">keys</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;order&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">keys</span>
                <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_array</span><span class="p">(</span><span class="n">names</span><span class="o">=</span><span class="n">keys</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">keys</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># No keys provided so sort on all columns.</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_array</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">kind</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;kind&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">kind</span>

        <span class="c1"># np.argsort will look for a possible .argsort method (e.g., for Time),</span>
        <span class="c1"># and if that fails cast to an array and try sorting that way.</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">idx</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="n">reverse</span> <span class="k">else</span> <span class="n">idx</span>

    <span class="k">def</span> <span class="nf">sort</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">keys</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sort the table according to one or more keys. This operates</span>
<span class="sd">        on the existing table and does not return a new table.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        keys : str or list of str</span>
<span class="sd">            The key(s) to order the table by. If None, use the</span>
<span class="sd">            primary index of the Table.</span>
<span class="sd">        kind : {&#39;quicksort&#39;, &#39;mergesort&#39;, &#39;heapsort&#39;, &#39;stable&#39;}, optional</span>
<span class="sd">            Sorting algorithm used by ``numpy.argsort``.</span>
<span class="sd">        reverse : bool</span>
<span class="sd">            Sort in reverse order (default=False)</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Create a table with 3 columns::</span>

<span class="sd">            &gt;&gt;&gt; t = Table([[&#39;Max&#39;, &#39;Jo&#39;, &#39;John&#39;], [&#39;Miller&#39;, &#39;Miller&#39;, &#39;Jackson&#39;],</span>
<span class="sd">            ...            [12, 15, 18]], names=(&#39;firstname&#39;, &#39;name&#39;, &#39;tel&#39;))</span>
<span class="sd">            &gt;&gt;&gt; print(t)</span>
<span class="sd">            firstname   name  tel</span>
<span class="sd">            --------- ------- ---</span>
<span class="sd">                  Max  Miller  12</span>
<span class="sd">                   Jo  Miller  15</span>
<span class="sd">                 John Jackson  18</span>

<span class="sd">        Sorting according to standard sorting rules, first &#39;name&#39; then &#39;firstname&#39;::</span>

<span class="sd">            &gt;&gt;&gt; t.sort([&#39;name&#39;, &#39;firstname&#39;])</span>
<span class="sd">            &gt;&gt;&gt; print(t)</span>
<span class="sd">            firstname   name  tel</span>
<span class="sd">            --------- ------- ---</span>
<span class="sd">                 John Jackson  18</span>
<span class="sd">                   Jo  Miller  15</span>
<span class="sd">                  Max  Miller  12</span>

<span class="sd">        Sorting according to standard sorting rules, first &#39;firstname&#39; then &#39;tel&#39;,</span>
<span class="sd">        in reverse order::</span>

<span class="sd">            &gt;&gt;&gt; t.sort([&#39;firstname&#39;, &#39;tel&#39;], reverse=True)</span>
<span class="sd">            &gt;&gt;&gt; print(t)</span>
<span class="sd">            firstname   name  tel</span>
<span class="sd">            --------- ------- ---</span>
<span class="sd">                  Max  Miller  12</span>
<span class="sd">                 John Jackson  18</span>
<span class="sd">                   Jo  Miller  15</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">keys</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">indices</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Table sort requires input keys or a table index&quot;</span><span class="p">)</span>
            <span class="n">keys</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">info</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">indices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">columns</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">keys</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">keys</span> <span class="o">=</span> <span class="p">[</span><span class="n">keys</span><span class="p">]</span>

        <span class="n">indexes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">keys</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="n">kind</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="n">reverse</span><span class="p">)</span>

        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">index_mode</span><span class="p">(</span><span class="s2">&quot;freeze&quot;</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                <span class="c1"># Make a new sorted column.  This requires that take() also copies</span>
                <span class="c1"># relevant info attributes for mixin columns.</span>
                <span class="n">new_col</span> <span class="o">=</span> <span class="n">col</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">indexes</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

                <span class="c1"># First statement in try: will succeed if the column supports an in-place</span>
                <span class="c1"># update, and matches the legacy behavior of astropy Table.  However,</span>
                <span class="c1"># some mixin classes may not support this, so in that case just drop</span>
                <span class="c1"># in the entire new column. See #9553 and #9536 for discussion.</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">col</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">new_col</span>
                <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                    <span class="c1"># In-place update failed for some reason, exception class not</span>
                    <span class="c1"># predictable for arbitrary mixin.</span>
                    <span class="bp">self</span><span class="p">[</span><span class="n">col</span><span class="o">.</span><span class="n">info</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_col</span>

    <span class="k">def</span> <span class="nf">reverse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reverse the row order of table rows.  The table is reversed</span>
<span class="sd">        in place and there are no function arguments.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Create a table with three columns::</span>

<span class="sd">            &gt;&gt;&gt; t = Table([[&#39;Max&#39;, &#39;Jo&#39;, &#39;John&#39;], [&#39;Miller&#39;,&#39;Miller&#39;,&#39;Jackson&#39;],</span>
<span class="sd">            ...         [12,15,18]], names=(&#39;firstname&#39;,&#39;name&#39;,&#39;tel&#39;))</span>
<span class="sd">            &gt;&gt;&gt; print(t)</span>
<span class="sd">            firstname   name  tel</span>
<span class="sd">            --------- ------- ---</span>
<span class="sd">                  Max  Miller  12</span>
<span class="sd">                   Jo  Miller  15</span>
<span class="sd">                 John Jackson  18</span>

<span class="sd">        Reversing order::</span>

<span class="sd">            &gt;&gt;&gt; t.reverse()</span>
<span class="sd">            &gt;&gt;&gt; print(t)</span>
<span class="sd">            firstname   name  tel</span>
<span class="sd">            --------- ------- ---</span>
<span class="sd">                 John Jackson  18</span>
<span class="sd">                   Jo  Miller  15</span>
<span class="sd">                  Max  Miller  12</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="c1"># First statement in try: will succeed if the column supports an in-place</span>
            <span class="c1"># update, and matches the legacy behavior of astropy Table.  However,</span>
            <span class="c1"># some mixin classes may not support this, so in that case just drop</span>
            <span class="c1"># in the entire new column. See #9836, #9553, and #9536 for discussion.</span>
            <span class="n">new_col</span> <span class="o">=</span> <span class="n">col</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">col</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">new_col</span>
            <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                <span class="c1"># In-place update failed for some reason, exception class not</span>
                <span class="c1"># predictable for arbitrary mixin.</span>
                <span class="bp">self</span><span class="p">[</span><span class="n">col</span><span class="o">.</span><span class="n">info</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_col</span>

        <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">indices</span><span class="p">:</span>
            <span class="n">index</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">round</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">decimals</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Round numeric columns in-place to the specified number of decimals.</span>
<span class="sd">        Non-numeric columns will be ignored.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Create three columns with different types:</span>

<span class="sd">            &gt;&gt;&gt; t = Table([[1, 4, 5], [-25.55, 12.123, 85],</span>
<span class="sd">            ...     [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]], names=(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;))</span>
<span class="sd">            &gt;&gt;&gt; print(t)</span>
<span class="sd">             a    b     c</span>
<span class="sd">            --- ------ ---</span>
<span class="sd">              1 -25.55   a</span>
<span class="sd">              4 12.123   b</span>
<span class="sd">              5   85.0   c</span>

<span class="sd">        Round them all to 0:</span>

<span class="sd">            &gt;&gt;&gt; t.round(0)</span>
<span class="sd">            &gt;&gt;&gt; print(t)</span>
<span class="sd">             a    b    c</span>
<span class="sd">            --- ----- ---</span>
<span class="sd">              1 -26.0   a</span>
<span class="sd">              4  12.0   b</span>
<span class="sd">              5  85.0   c</span>

<span class="sd">        Round column &#39;a&#39; to -1 decimal:</span>

<span class="sd">            &gt;&gt;&gt; t.round({&#39;a&#39;:-1})</span>
<span class="sd">            &gt;&gt;&gt; print(t)</span>
<span class="sd">             a    b    c</span>
<span class="sd">            --- ----- ---</span>
<span class="sd">              0 -26.0   a</span>
<span class="sd">              0  12.0   b</span>
<span class="sd">              0  85.0   c</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        decimals: int, dict</span>
<span class="sd">            Number of decimals to round the columns to. If a dict is given,</span>
<span class="sd">            the columns will be rounded to the number specified as the value.</span>
<span class="sd">            If a certain column is not in the dict given, it will remain the</span>
<span class="sd">            same.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">decimals</span><span class="p">,</span> <span class="n">Mapping</span><span class="p">):</span>
            <span class="n">decimal_values</span> <span class="o">=</span> <span class="n">decimals</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>
            <span class="n">column_names</span> <span class="o">=</span> <span class="n">decimals</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">decimals</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">decimal_values</span> <span class="o">=</span> <span class="n">itertools</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">decimals</span><span class="p">)</span>
            <span class="n">column_names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">colnames</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;&#39;decimals&#39; argument must be an int or a dict&quot;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">colname</span><span class="p">,</span> <span class="n">decimal</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">column_names</span><span class="p">,</span> <span class="n">decimal_values</span><span class="p">):</span>
            <span class="n">col</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="n">colname</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">col</span><span class="o">.</span><span class="n">info</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">number</span><span class="p">):</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">around</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">decimals</span><span class="o">=</span><span class="n">decimal</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">col</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                    <span class="c1"># Bug in numpy see https://github.com/numpy/numpy/issues/15438</span>
                    <span class="n">col</span><span class="p">[()]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">around</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">decimals</span><span class="o">=</span><span class="n">decimal</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">copy_data</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a copy of the table.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        copy_data : bool</span>
<span class="sd">            If `True` (the default), copy the underlying data array and make</span>
<span class="sd">            a deep copy of the ``meta`` attribute. Otherwise, use the same</span>
<span class="sd">            data array and make a shallow (key-only) copy of ``meta``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy_data</span><span class="p">)</span>

        <span class="c1"># If the current table is grouped then do the same in the copy</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_groups&quot;</span><span class="p">):</span>
            <span class="n">out</span><span class="o">.</span><span class="n">_groups</span> <span class="o">=</span> <span class="n">groups</span><span class="o">.</span><span class="n">TableGroups</span><span class="p">(</span>
                <span class="n">out</span><span class="p">,</span> <span class="n">indices</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_groups</span><span class="o">.</span><span class="n">_indices</span><span class="p">,</span> <span class="n">keys</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_groups</span><span class="o">.</span><span class="n">_keys</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">out</span>

    <span class="k">def</span> <span class="nf">__deepcopy__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">memo</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">out</span><span class="o">.</span><span class="n">colnames</span><span class="p">:</span>
            <span class="n">out</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="fm">__setitem__</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">name</span><span class="p">]),</span> <span class="n">validated</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">out</span><span class="o">.</span><span class="n">meta</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">meta</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out</span>

    <span class="k">def</span> <span class="nf">__copy__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rows_equal</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="n">eq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__eq__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
            <span class="c1"># bitwise operators on bool values not reliable (e.g. `bool(~True) == True`)</span>
            <span class="c1"># and are deprecated in Python 3.12</span>
            <span class="c1"># see https://github.com/python/cpython/pull/103487</span>
            <span class="k">return</span> <span class="ow">not</span> <span class="n">eq</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="o">~</span><span class="n">eq</span>

    <span class="k">def</span> <span class="nf">_rows_equal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Row-wise comparison of table with any other object.</span>

<span class="sd">        This is actual implementation for __eq__.</span>

<span class="sd">        Returns a 1-D boolean numpy array showing result of row-wise comparison,</span>
<span class="sd">        or a bool (False) in cases where comparison isn&#39;t possible (uncomparable dtypes</span>
<span class="sd">        or unbroadcastable shapes). Intended to follow legacy numpy&#39;s elementwise</span>
<span class="sd">        comparison rules.</span>

<span class="sd">        This is the same as the ``==`` comparison for tables.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : Table or DataFrame or ndarray</span>
<span class="sd">             An object to compare with table</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Comparing one Table with other::</span>

<span class="sd">            &gt;&gt;&gt; t1 = Table([[1,2],[4,5],[7,8]], names=(&#39;a&#39;,&#39;b&#39;,&#39;c&#39;))</span>
<span class="sd">            &gt;&gt;&gt; t2 = Table([[1,2],[4,5],[7,8]], names=(&#39;a&#39;,&#39;b&#39;,&#39;c&#39;))</span>
<span class="sd">            &gt;&gt;&gt; t1._rows_equal(t2)</span>
<span class="sd">            array([ True,  True])</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Table</span><span class="p">):</span>
            <span class="n">other</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">as_array</span><span class="p">()</span>

        <span class="n">self_is_masked</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_masked_columns</span>
        <span class="n">other_is_masked</span> <span class="o">=</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">)</span>

        <span class="n">allowed_numpy_exceptions</span> <span class="o">=</span> <span class="p">(</span>
            <span class="ne">TypeError</span><span class="p">,</span>
            <span class="ne">ValueError</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">NUMPY_LT_1_25</span> <span class="k">else</span> <span class="ne">DeprecationWarning</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="c1"># One table is masked and the other is not</span>
        <span class="k">if</span> <span class="n">self_is_masked</span> <span class="o">^</span> <span class="n">other_is_masked</span><span class="p">:</span>
            <span class="c1"># remap variables to a and b where a is masked and b isn&#39;t</span>
            <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="p">(</span>
                <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">as_array</span><span class="p">(),</span> <span class="n">other</span><span class="p">)</span> <span class="k">if</span> <span class="n">self_is_masked</span> <span class="k">else</span> <span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_array</span><span class="p">())</span>
            <span class="p">)</span>

            <span class="c1"># If mask is True, then by definition the row doesn&#39;t match</span>
            <span class="c1"># because the other array is not masked.</span>
            <span class="n">false_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="p">[(</span><span class="n">n</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">a</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span><span class="p">])</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">data</span> <span class="o">==</span> <span class="n">b</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">mask</span> <span class="o">==</span> <span class="n">false_mask</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">allowed_numpy_exceptions</span><span class="p">:</span>
                <span class="c1"># numpy may complain that structured array are not comparable (TypeError)</span>
                <span class="c1"># or that operands are not brodcastable (ValueError)</span>
                <span class="c1"># see https://github.com/astropy/astropy/issues/13421</span>
                <span class="n">result</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_array</span><span class="p">()</span> <span class="o">==</span> <span class="n">other</span>
            <span class="k">except</span> <span class="n">allowed_numpy_exceptions</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">values_equal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Element-wise comparison of table with another table, list, or scalar.</span>

<span class="sd">        Returns a ``Table`` with the same columns containing boolean values</span>
<span class="sd">        showing result of comparison.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : table-like object or list or scalar</span>
<span class="sd">             Object to compare with table</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Compare one Table with other::</span>

<span class="sd">          &gt;&gt;&gt; t1 = Table([[1, 2], [4, 5], [-7, 8]], names=(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;))</span>
<span class="sd">          &gt;&gt;&gt; t2 = Table([[1, 2], [-4, 5], [7, 8]], names=(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;))</span>
<span class="sd">          &gt;&gt;&gt; t1.values_equal(t2)</span>
<span class="sd">          &lt;Table length=2&gt;</span>
<span class="sd">           a     b     c</span>
<span class="sd">          bool  bool  bool</span>
<span class="sd">          ---- ----- -----</span>
<span class="sd">          True False False</span>
<span class="sd">          True  True  True</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Table</span><span class="p">):</span>
            <span class="n">names</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">colnames</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">other</span> <span class="o">=</span> <span class="n">Table</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="n">names</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">colnames</span>
            <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                <span class="c1"># Broadcast other into a dict, so e.g. other = 2 will turn into</span>
                <span class="c1"># other = {&#39;a&#39;: 2, &#39;b&#39;: 2} and then equality does a</span>
                <span class="c1"># column-by-column broadcasting.</span>
                <span class="n">names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">colnames</span>
                <span class="n">other</span> <span class="o">=</span> <span class="p">{</span><span class="n">name</span><span class="p">:</span> <span class="n">other</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">names</span><span class="p">}</span>

        <span class="c1"># Require column names match but do not require same column order</span>
        <span class="k">if</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">colnames</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">set</span><span class="p">(</span><span class="n">names</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;cannot compare tables with different column names&quot;</span><span class="p">)</span>

        <span class="n">eqs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">names</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">np</span><span class="o">.</span><span class="n">broadcast</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">name</span><span class="p">],</span> <span class="n">other</span><span class="p">[</span><span class="n">name</span><span class="p">])</span>  <span class="c1"># Check if broadcast-able</span>
                <span class="c1"># Catch the numpy FutureWarning related to equality checking,</span>
                <span class="c1"># &quot;elementwise comparison failed; returning scalar instead, but</span>
                <span class="c1">#  in the future will perform elementwise comparison&quot;.  Turn this</span>
                <span class="c1"># into an exception since the scalar answer is not what we want.</span>
                <span class="k">with</span> <span class="n">warnings</span><span class="o">.</span><span class="n">catch_warnings</span><span class="p">(</span><span class="n">record</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="k">as</span> <span class="n">warns</span><span class="p">:</span>
                    <span class="n">warnings</span><span class="o">.</span><span class="n">simplefilter</span><span class="p">(</span><span class="s2">&quot;always&quot;</span><span class="p">)</span>
                    <span class="n">eq</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">==</span> <span class="n">other</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
                    <span class="k">if</span> <span class="p">(</span>
                        <span class="n">warns</span>
                        <span class="ow">and</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">warns</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">category</span><span class="p">,</span> <span class="ne">FutureWarning</span><span class="p">)</span>
                        <span class="ow">and</span> <span class="s2">&quot;elementwise comparison failed&quot;</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="n">warns</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">message</span><span class="p">)</span>
                    <span class="p">):</span>
                        <span class="k">raise</span> <span class="ne">FutureWarning</span><span class="p">(</span><span class="n">warns</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">message</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;unable to compare column </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span> <span class="kn">from</span> <span class="nn">err</span>

            <span class="c1"># Be strict about the result from the comparison. E.g. SkyCoord __eq__ is just</span>
            <span class="c1"># broken and completely ignores that it should return an array.</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span>
                <span class="nb">isinstance</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>
                <span class="ow">and</span> <span class="n">eq</span><span class="o">.</span><span class="n">dtype</span> <span class="ow">is</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s2">&quot;bool&quot;</span><span class="p">)</span>
                <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">eq</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;comparison for column </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2"> returned </span><span class="si">{</span><span class="n">eq</span><span class="si">}</span><span class="s2"> &quot;</span>
                    <span class="s2">&quot;instead of the expected boolean ndarray&quot;</span>
                <span class="p">)</span>

            <span class="n">eqs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">eq</span><span class="p">)</span>

        <span class="n">out</span> <span class="o">=</span> <span class="n">Table</span><span class="p">(</span><span class="n">eqs</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="n">names</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">out</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">groups</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_groups&quot;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_groups</span> <span class="o">=</span> <span class="n">groups</span><span class="o">.</span><span class="n">TableGroups</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_groups</span>

    <span class="k">def</span> <span class="nf">group_by</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">keys</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Group this table by the specified ``keys``.</span>

<span class="sd">        This effectively splits the table into groups which correspond to unique</span>
<span class="sd">        values of the ``keys`` grouping object.  The output is a new</span>
<span class="sd">        `~astropy.table.TableGroups` which contains a copy of this table but</span>
<span class="sd">        sorted by row according to ``keys``.</span>

<span class="sd">        The ``keys`` input to `group_by` can be specified in different ways:</span>

<span class="sd">          - String or list of strings corresponding to table column name(s)</span>
<span class="sd">          - Numpy array (homogeneous or structured) with same length as this table</span>
<span class="sd">          - `~astropy.table.Table` with same length as this table</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        keys : str, list of str, numpy array, or `~astropy.table.Table`</span>
<span class="sd">            Key grouping object</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        out : `~astropy.table.Table`</span>
<span class="sd">            New table with groups set</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">groups</span><span class="o">.</span><span class="n">table_group_by</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">keys</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">to_pandas</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">use_nullable_int</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a :class:`pandas.DataFrame` instance.</span>

<span class="sd">        The index of the created DataFrame is controlled by the ``index``</span>
<span class="sd">        argument.  For ``index=True`` or the default ``None``, an index will be</span>
<span class="sd">        specified for the DataFrame if there is a primary key index on the</span>
<span class="sd">        Table *and* if it corresponds to a single column.  If ``index=False``</span>
<span class="sd">        then no DataFrame index will be specified.  If ``index`` is the name of</span>
<span class="sd">        a column in the table then that will be the DataFrame index.</span>

<span class="sd">        In addition to vanilla columns or masked columns, this supports Table</span>
<span class="sd">        mixin columns like Quantity, Time, or SkyCoord.  In many cases these</span>
<span class="sd">        objects have no analog in pandas and will be converted to a &quot;encoded&quot;</span>
<span class="sd">        representation using only Column or MaskedColumn.  The exception is</span>
<span class="sd">        Time or TimeDelta columns, which will be converted to the corresponding</span>
<span class="sd">        representation in pandas using ``np.datetime64`` or ``np.timedelta64``.</span>
<span class="sd">        See the example below.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        index : None, bool, str</span>
<span class="sd">            Specify DataFrame index mode</span>
<span class="sd">        use_nullable_int : bool, default=True</span>
<span class="sd">            Convert integer MaskedColumn to pandas nullable integer type.</span>
<span class="sd">            If ``use_nullable_int=False`` or the pandas version does not support</span>
<span class="sd">            nullable integer types (version &lt; 0.24), then the column is converted</span>
<span class="sd">            to float with NaN for missing elements and a warning is issued.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dataframe : :class:`pandas.DataFrame`</span>
<span class="sd">            A pandas :class:`pandas.DataFrame` instance</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ImportError</span>
<span class="sd">            If pandas is not installed</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the Table has multi-dimensional columns</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Here we convert a table with a few mixins to a</span>
<span class="sd">        :class:`pandas.DataFrame` instance.</span>

<span class="sd">          &gt;&gt;&gt; import pandas as pd</span>
<span class="sd">          &gt;&gt;&gt; from astropy.table import QTable</span>
<span class="sd">          &gt;&gt;&gt; import astropy.units as u</span>
<span class="sd">          &gt;&gt;&gt; from astropy.time import Time, TimeDelta</span>
<span class="sd">          &gt;&gt;&gt; from astropy.coordinates import SkyCoord</span>

<span class="sd">          &gt;&gt;&gt; q = [1, 2] * u.m</span>
<span class="sd">          &gt;&gt;&gt; tm = Time([1998, 2002], format=&#39;jyear&#39;)</span>
<span class="sd">          &gt;&gt;&gt; sc = SkyCoord([5, 6], [7, 8], unit=&#39;deg&#39;)</span>
<span class="sd">          &gt;&gt;&gt; dt = TimeDelta([3, 200] * u.s)</span>

<span class="sd">          &gt;&gt;&gt; t = QTable([q, tm, sc, dt], names=[&#39;q&#39;, &#39;tm&#39;, &#39;sc&#39;, &#39;dt&#39;])</span>

<span class="sd">          &gt;&gt;&gt; df = t.to_pandas(index=&#39;tm&#39;)</span>
<span class="sd">          &gt;&gt;&gt; with pd.option_context(&#39;display.max_columns&#39;, 20):</span>
<span class="sd">          ...     print(df)</span>
<span class="sd">                        q  sc.ra  sc.dec              dt</span>
<span class="sd">          tm</span>
<span class="sd">          1998-01-01  1.0    5.0     7.0 0 days 00:00:03</span>
<span class="sd">          2002-01-01  2.0    6.0     8.0 0 days 00:03:20</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">pandas</span> <span class="kn">import</span> <span class="n">DataFrame</span><span class="p">,</span> <span class="n">Series</span>

        <span class="k">if</span> <span class="n">index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">False</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">index</span> <span class="ow">in</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">True</span><span class="p">):</span>
                <span class="c1"># Default is to use the table primary key if available and a single column</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">primary_key</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">primary_key</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">primary_key</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">index</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">index</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">colnames</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s2">&quot;index must be None, False, True or a table column name&quot;</span>
                    <span class="p">)</span>

        <span class="k">def</span> <span class="nf">_encode_mixins</span><span class="p">(</span><span class="n">tbl</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;Encode a Table ``tbl`` that may have mixin columns to a Table with only</span>
<span class="sd">            astropy Columns + appropriate meta-data to allow subsequent decoding.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="kn">from</span> <span class="nn">astropy.time</span> <span class="kn">import</span> <span class="n">TimeBase</span><span class="p">,</span> <span class="n">TimeDelta</span>

            <span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">serialize</span>

            <span class="c1"># Convert any Time or TimeDelta columns and pay attention to masking</span>
            <span class="n">time_cols</span> <span class="o">=</span> <span class="p">[</span><span class="n">col</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">tbl</span><span class="o">.</span><span class="n">itercols</span><span class="p">()</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">TimeBase</span><span class="p">)]</span>
            <span class="k">if</span> <span class="n">time_cols</span><span class="p">:</span>
                <span class="c1"># Make a light copy of table and clear any indices</span>
                <span class="n">new_cols</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">tbl</span><span class="o">.</span><span class="n">itercols</span><span class="p">():</span>
                    <span class="n">new_col</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">col_copy</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">copy_indices</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="k">if</span> <span class="n">col</span><span class="o">.</span><span class="n">info</span><span class="o">.</span><span class="n">indices</span> <span class="k">else</span> <span class="n">col</span>
                    <span class="p">)</span>
                    <span class="n">new_cols</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_col</span><span class="p">)</span>
                <span class="n">tbl</span> <span class="o">=</span> <span class="n">tbl</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">new_cols</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

                <span class="c1"># Certain subclasses (e.g. TimeSeries) may generate new indices on</span>
                <span class="c1"># table creation, so make sure there are no indices on the table.</span>
                <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">tbl</span><span class="o">.</span><span class="n">itercols</span><span class="p">():</span>
                    <span class="n">col</span><span class="o">.</span><span class="n">info</span><span class="o">.</span><span class="n">indices</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>

                <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">time_cols</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">TimeDelta</span><span class="p">):</span>
                        <span class="c1"># Convert to nanoseconds (matches astropy datetime64 support)</span>
                        <span class="n">new_col</span> <span class="o">=</span> <span class="p">(</span><span class="n">col</span><span class="o">.</span><span class="n">sec</span> <span class="o">*</span> <span class="mf">1e9</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;timedelta64[ns]&quot;</span><span class="p">)</span>
                        <span class="n">nat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">timedelta64</span><span class="p">(</span><span class="s2">&quot;NaT&quot;</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">new_col</span> <span class="o">=</span> <span class="n">col</span><span class="o">.</span><span class="n">datetime64</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                        <span class="n">nat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">datetime64</span><span class="p">(</span><span class="s2">&quot;NaT&quot;</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">col</span><span class="o">.</span><span class="n">masked</span><span class="p">:</span>
                        <span class="n">new_col</span><span class="p">[</span><span class="n">col</span><span class="o">.</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">nat</span>
                    <span class="n">tbl</span><span class="p">[</span><span class="n">col</span><span class="o">.</span><span class="n">info</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_col</span>

            <span class="c1"># Convert the table to one with no mixins, only Column objects.</span>
            <span class="n">encode_tbl</span> <span class="o">=</span> <span class="n">serialize</span><span class="o">.</span><span class="n">represent_mixins_as_columns</span><span class="p">(</span><span class="n">tbl</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">encode_tbl</span>

        <span class="n">tbl</span> <span class="o">=</span> <span class="n">_encode_mixins</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="n">badcols</span> <span class="o">=</span> <span class="p">[</span><span class="n">name</span> <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">col</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">col</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">badcols</span><span class="p">:</span>
            <span class="c1"># fmt: off</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s1">&#39;Cannot convert a table with multidimensional columns to a &#39;</span>
                <span class="sa">f</span><span class="s1">&#39;pandas DataFrame. Offending columns are: </span><span class="si">{</span><span class="n">badcols</span><span class="si">}</span><span class="se">\n</span><span class="s1">&#39;</span>
                <span class="sa">f</span><span class="s1">&#39;One can filter out such columns using:</span><span class="se">\n</span><span class="s1">&#39;</span>
                <span class="sa">f</span><span class="s1">&#39;names = [name for name in tbl.colnames if len(tbl[name].shape) &lt;= 1]</span><span class="se">\n</span><span class="s1">&#39;</span>
                <span class="sa">f</span><span class="s1">&#39;tbl[names].to_pandas(...)&#39;</span>
            <span class="p">)</span>
            <span class="c1"># fmt: on</span>

        <span class="n">out</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">column</span> <span class="ow">in</span> <span class="n">tbl</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">column</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="s2">&quot;isnative&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">):</span>
                <span class="n">out</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">column</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">out</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">column</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">byteswap</span><span class="p">()</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">column</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">newbyteorder</span><span class="p">(</span><span class="s2">&quot;=&quot;</span><span class="p">))</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">column</span><span class="p">,</span> <span class="n">MaskedColumn</span><span class="p">)</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">column</span><span class="o">.</span><span class="n">mask</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">column</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;i&quot;</span><span class="p">,</span> <span class="s2">&quot;u&quot;</span><span class="p">]:</span>
                    <span class="n">pd_dtype</span> <span class="o">=</span> <span class="n">column</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">name</span>
                    <span class="k">if</span> <span class="n">use_nullable_int</span><span class="p">:</span>
                        <span class="c1"># Convert int64 to Int64, uint32 to UInt32, etc for nullable types</span>
                        <span class="n">pd_dtype</span> <span class="o">=</span> <span class="n">pd_dtype</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;i&quot;</span><span class="p">,</span> <span class="s2">&quot;I&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;u&quot;</span><span class="p">,</span> <span class="s2">&quot;U&quot;</span><span class="p">)</span>
                    <span class="n">out</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">Series</span><span class="p">(</span><span class="n">out</span><span class="p">[</span><span class="n">name</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">pd_dtype</span><span class="p">)</span>

                    <span class="c1"># If pandas is older than 0.24 the type may have turned to float</span>
                    <span class="k">if</span> <span class="n">column</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">!=</span> <span class="n">out</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span><span class="p">:</span>
                        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                            <span class="sa">f</span><span class="s2">&quot;converted column &#39;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">&#39; from </span><span class="si">{</span><span class="n">column</span><span class="o">.</span><span class="n">dtype</span><span class="si">}</span><span class="s2"> to&quot;</span>
                            <span class="sa">f</span><span class="s2">&quot; </span><span class="si">{</span><span class="n">out</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                            <span class="n">TableReplaceWarning</span><span class="p">,</span>
                            <span class="n">stacklevel</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
                        <span class="p">)</span>
                <span class="k">elif</span> <span class="n">column</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;f&quot;</span><span class="p">,</span> <span class="s2">&quot;c&quot;</span><span class="p">]:</span>
                    <span class="n">out</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">column</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">object</span><span class="p">)</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>

        <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">if</span> <span class="n">index</span><span class="p">:</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>

            <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;index&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">idx</span>

            <span class="c1"># We add the table index to Series inputs (MaskedColumn with int values) to override</span>
            <span class="c1"># its default RangeIndex, see #11432</span>
            <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">out</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">Series</span><span class="p">):</span>
                    <span class="n">v</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">idx</span>

        <span class="n">df</span> <span class="o">=</span> <span class="n">DataFrame</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">index</span><span class="p">:</span>
            <span class="c1"># Explicitly set the pandas DataFrame index to the original table</span>
            <span class="c1"># index name.</span>
            <span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">idx</span><span class="o">.</span><span class="n">info</span><span class="o">.</span><span class="n">name</span>

        <span class="k">return</span> <span class="n">df</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_pandas</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">dataframe</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">units</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a `~astropy.table.Table` from a :class:`pandas.DataFrame` instance.</span>

<span class="sd">        In addition to converting generic numeric or string columns, this supports</span>
<span class="sd">        conversion of pandas Date and Time delta columns to `~astropy.time.Time`</span>
<span class="sd">        and `~astropy.time.TimeDelta` columns, respectively.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dataframe : :class:`pandas.DataFrame`</span>
<span class="sd">            A pandas :class:`pandas.DataFrame` instance</span>
<span class="sd">        index : bool</span>
<span class="sd">            Include the index column in the returned table (default=False)</span>
<span class="sd">        units: dict</span>
<span class="sd">            A dict mapping column names to a `~astropy.units.Unit`.</span>
<span class="sd">            The columns will have the specified unit in the Table.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        table : `~astropy.table.Table`</span>
<span class="sd">            A `~astropy.table.Table` (or subclass) instance</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ImportError</span>
<span class="sd">            If pandas is not installed</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Here we convert a :class:`pandas.DataFrame` instance</span>
<span class="sd">        to a `~astropy.table.QTable`.</span>

<span class="sd">          &gt;&gt;&gt; import numpy as np</span>
<span class="sd">          &gt;&gt;&gt; import pandas as pd</span>
<span class="sd">          &gt;&gt;&gt; from astropy.table import QTable</span>

<span class="sd">          &gt;&gt;&gt; time = pd.Series([&#39;1998-01-01&#39;, &#39;2002-01-01&#39;], dtype=&#39;datetime64[ns]&#39;)</span>
<span class="sd">          &gt;&gt;&gt; dt = pd.Series(np.array([1, 300], dtype=&#39;timedelta64[s]&#39;))</span>
<span class="sd">          &gt;&gt;&gt; df = pd.DataFrame({&#39;time&#39;: time})</span>
<span class="sd">          &gt;&gt;&gt; df[&#39;dt&#39;] = dt</span>
<span class="sd">          &gt;&gt;&gt; df[&#39;x&#39;] = [3., 4.]</span>
<span class="sd">          &gt;&gt;&gt; with pd.option_context(&#39;display.max_columns&#39;, 20):</span>
<span class="sd">          ...     print(df)</span>
<span class="sd">                  time              dt    x</span>
<span class="sd">          0 1998-01-01 0 days 00:00:01  3.0</span>
<span class="sd">          1 2002-01-01 0 days 00:05:00  4.0</span>

<span class="sd">          &gt;&gt;&gt; QTable.from_pandas(df)</span>
<span class="sd">          &lt;QTable length=2&gt;</span>
<span class="sd">                    time              dt       x</span>
<span class="sd">                    Time          TimeDelta float64</span>
<span class="sd">          ----------------------- --------- -------</span>
<span class="sd">          1998-01-01T00:00:00.000       1.0     3.0</span>
<span class="sd">          2002-01-01T00:00:00.000     300.0     4.0</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>

        <span class="n">names</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">dataframe</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>
        <span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="n">dataframe</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">names</span><span class="p">]</span>
        <span class="n">datas</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">column</span><span class="p">)</span> <span class="k">for</span> <span class="n">column</span> <span class="ow">in</span> <span class="n">columns</span><span class="p">]</span>
        <span class="n">masks</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">column</span><span class="o">.</span><span class="n">isnull</span><span class="p">())</span> <span class="k">for</span> <span class="n">column</span> <span class="ow">in</span> <span class="n">columns</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">index</span><span class="p">:</span>
            <span class="n">index_name</span> <span class="o">=</span> <span class="n">dataframe</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">name</span> <span class="ow">or</span> <span class="s2">&quot;index&quot;</span>
            <span class="k">while</span> <span class="n">index_name</span> <span class="ow">in</span> <span class="n">names</span><span class="p">:</span>
                <span class="n">index_name</span> <span class="o">=</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="n">index_name</span> <span class="o">+</span> <span class="s2">&quot;_&quot;</span>
            <span class="n">names</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">index_name</span><span class="p">)</span>
            <span class="n">columns</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">dataframe</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>
            <span class="n">datas</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">dataframe</span><span class="o">.</span><span class="n">index</span><span class="p">))</span>
            <span class="n">masks</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dataframe</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">units</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">units</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">names</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">units</span><span class="p">,</span> <span class="n">Mapping</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Expected a Mapping &quot;column-name&quot; -&gt; &quot;unit&quot;&#39;</span><span class="p">)</span>

            <span class="n">not_found</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">units</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">names</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">not_found</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;`units` contains additional columns: </span><span class="si">{</span><span class="n">not_found</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="n">units</span> <span class="o">=</span> <span class="p">[</span><span class="n">units</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">names</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">column</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">unit</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="n">columns</span><span class="p">,</span> <span class="n">datas</span><span class="p">,</span> <span class="n">masks</span><span class="p">,</span> <span class="n">units</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">column</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;u&quot;</span><span class="p">,</span> <span class="s2">&quot;i&quot;</span><span class="p">]</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">mask</span><span class="p">):</span>
                <span class="c1"># Special-case support for pandas nullable int</span>
                <span class="n">np_dtype</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">column</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="n">column</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np_dtype</span><span class="p">)</span>
                <span class="n">data</span><span class="p">[</span><span class="o">~</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">column</span><span class="p">[</span><span class="o">~</span><span class="n">mask</span><span class="p">]</span>
                <span class="n">out</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">MaskedColumn</span><span class="p">(</span>
                    <span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">mask</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="n">unit</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span>
                <span class="p">)</span>
                <span class="k">continue</span>

            <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s2">&quot;O&quot;</span><span class="p">:</span>
                <span class="c1"># If all elements of an object array are string-like or np.nan</span>
                <span class="c1"># then coerce back to a native numpy str/unicode array.</span>
                <span class="n">string_types</span> <span class="o">=</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="nb">bytes</span><span class="p">)</span>
                <span class="n">nan</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">string_types</span><span class="p">)</span> <span class="ow">or</span> <span class="n">x</span> <span class="ow">is</span> <span class="n">nan</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">data</span><span class="p">):</span>
                    <span class="c1"># Force any missing (null) values to b&#39;&#39;.  Numpy will</span>
                    <span class="c1"># upcast to str/unicode as needed.</span>
                    <span class="n">data</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="sa">b</span><span class="s2">&quot;&quot;</span>

                    <span class="c1"># When the numpy object array is represented as a list then</span>
                    <span class="c1"># numpy initializes to the correct string or unicode type.</span>
                    <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>

            <span class="c1"># Numpy datetime64</span>
            <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s2">&quot;M&quot;</span><span class="p">:</span>
                <span class="kn">from</span> <span class="nn">astropy.time</span> <span class="kn">import</span> <span class="n">Time</span>

                <span class="n">out</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">Time</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s2">&quot;datetime64&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">mask</span><span class="p">):</span>
                    <span class="n">out</span><span class="p">[</span><span class="n">name</span><span class="p">][</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked</span>
                <span class="n">out</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">format</span> <span class="o">=</span> <span class="s2">&quot;isot&quot;</span>

            <span class="c1"># Numpy timedelta64</span>
            <span class="k">elif</span> <span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s2">&quot;m&quot;</span><span class="p">:</span>
                <span class="kn">from</span> <span class="nn">astropy.time</span> <span class="kn">import</span> <span class="n">TimeDelta</span>

                <span class="n">data_sec</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;timedelta64[ns]&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span> <span class="o">/</span> <span class="mf">1e9</span>
                <span class="n">out</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">TimeDelta</span><span class="p">(</span><span class="n">data_sec</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s2">&quot;sec&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">mask</span><span class="p">):</span>
                    <span class="n">out</span><span class="p">[</span><span class="n">name</span><span class="p">][</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">mask</span><span class="p">):</span>
                    <span class="n">out</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">MaskedColumn</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">mask</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="n">unit</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">out</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="n">unit</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>

    <span class="n">info</span> <span class="o">=</span> <span class="n">TableInfo</span><span class="p">()</span></div>



<span class="k">class</span> <span class="nc">QTable</span><span class="p">(</span><span class="n">Table</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A class to represent tables of heterogeneous data.</span>

<span class="sd">    `~astropy.table.QTable` provides a class for heterogeneous tabular data</span>
<span class="sd">    which can be easily modified, for instance adding columns or new rows.</span>

<span class="sd">    The `~astropy.table.QTable` class is identical to `~astropy.table.Table`</span>
<span class="sd">    except that columns with an associated ``unit`` attribute are converted to</span>
<span class="sd">    `~astropy.units.Quantity` objects.</span>

<span class="sd">    For more information see:</span>

<span class="sd">    - https://docs.astropy.org/en/stable/table/</span>
<span class="sd">    - https://docs.astropy.org/en/stable/table/mixin_columns.html</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : numpy ndarray, dict, list, table-like object, optional</span>
<span class="sd">        Data to initialize table.</span>
<span class="sd">    masked : bool, optional</span>
<span class="sd">        Specify whether the table is masked.</span>
<span class="sd">    names : list, optional</span>
<span class="sd">        Specify column names.</span>
<span class="sd">    dtype : list, optional</span>
<span class="sd">        Specify column data types.</span>
<span class="sd">    meta : dict, optional</span>
<span class="sd">        Metadata associated with the table.</span>
<span class="sd">    copy : bool, optional</span>
<span class="sd">        Copy the input data. If the input is a (Q)Table the ``meta`` is always</span>
<span class="sd">        copied regardless of the ``copy`` parameter.</span>
<span class="sd">        Default is True.</span>
<span class="sd">    rows : numpy ndarray, list of list, optional</span>
<span class="sd">        Row-oriented data for table instead of ``data`` argument.</span>
<span class="sd">    copy_indices : bool, optional</span>
<span class="sd">        Copy any indices in the input data. Default is True.</span>
<span class="sd">    units : list, dict, optional</span>
<span class="sd">        List or dict of units to apply to columns.</span>
<span class="sd">    descriptions : list, dict, optional</span>
<span class="sd">        List or dict of descriptions to apply to columns.</span>
<span class="sd">    **kwargs : dict, optional</span>
<span class="sd">        Additional keyword args when converting table-like object.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">_is_mixin_for_table</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">col</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determine if ``col`` should be added to the table directly as</span>
<span class="sd">        a mixin column.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">has_info_class</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">MixinInfo</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_convert_col_for_table</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">col</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">Column</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="s2">&quot;unit&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># We need to turn the column into a quantity; use subok=True to allow</span>
            <span class="c1"># Quantity subclasses identified in the unit (such as u.mag()).</span>
            <span class="n">q_cls</span> <span class="o">=</span> <span class="n">Masked</span><span class="p">(</span><span class="n">Quantity</span><span class="p">)</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">MaskedColumn</span><span class="p">)</span> <span class="k">else</span> <span class="n">Quantity</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">qcol</span> <span class="o">=</span> <span class="n">q_cls</span><span class="p">(</span><span class="n">col</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">col</span><span class="o">.</span><span class="n">unit</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">COPY_IF_NEEDED</span><span class="p">,</span> <span class="n">subok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;column </span><span class="si">{</span><span class="n">col</span><span class="o">.</span><span class="n">info</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2"> has a unit but is kept as &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;a </span><span class="si">{</span><span class="n">col</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> as an attempt to &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;convert it to Quantity failed with:</span><span class="se">\n</span><span class="si">{</span><span class="n">exc</span><span class="si">!r}</span><span class="s2">&quot;</span><span class="p">,</span>
                    <span class="n">AstropyUserWarning</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">qcol</span><span class="o">.</span><span class="n">info</span> <span class="o">=</span> <span class="n">col</span><span class="o">.</span><span class="n">info</span>
                <span class="n">qcol</span><span class="o">.</span><span class="n">info</span><span class="o">.</span><span class="n">indices</span> <span class="o">=</span> <span class="n">col</span><span class="o">.</span><span class="n">info</span><span class="o">.</span><span class="n">indices</span>
                <span class="n">col</span> <span class="o">=</span> <span class="n">qcol</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">col</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">_convert_col_for_table</span><span class="p">(</span><span class="n">col</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">col</span>
</pre></div>
        </article>
      </div>
      <footer>
        
        <div class="related-pages">
          
          
        </div>
        <div class="bottom-of-page">
          <div class="left-details">
            <div class="copyright">
                Copyright &#169; 2024, R. Laugier
            </div>
            Made with <a href="https://www.sphinx-doc.org/">Sphinx</a> and <a class="muted-link" href="https://pradyunsg.me">@pradyunsg</a>'s
            
            <a href="https://github.com/pradyunsg/furo">Furo</a>
            
          </div>
          <div class="right-details">
            
          </div>
        </div>
        
      </footer>
    </div>
    <aside class="toc-drawer no-toc">
      
      
      
    </aside>
  </div>
</div><script src="../../../_static/documentation_options.js?v=47de8214"></script>
    <script src="../../../_static/doctools.js?v=9a2dae69"></script>
    <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../_static/scripts/furo.js?v=5fa4622c"></script>
    <script src="../../../_static/design-tabs.js?v=36754332"></script>
    </body>
</html>